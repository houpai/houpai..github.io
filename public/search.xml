<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>html内容禁止选择、复制、右键等</title>
    <url>/2021/06/23/HTML%E9%A1%B5%E9%9D%A2%E5%86%85%E5%AE%B9%E7%A6%81%E6%AD%A2%E9%80%89%E6%8B%A9%E3%80%81%E5%A4%8D%E5%88%B6%E3%80%81%E5%8F%B3%E9%94%AE/</url>
    <content><![CDATA[<p>html内容禁止选择、复制、右键…</p>
<span id="more"></span>

<h4 id="HTML页面内容禁止选择、复制、右键"><a href="#HTML页面内容禁止选择、复制、右键" class="headerlink" title="HTML页面内容禁止选择、复制、右键"></a>HTML页面内容禁止选择、复制、右键</h4><pre><code class="html">&lt;body leftmargin=0 topmargin=0 oncontextmenu=&#39;return false&#39; ondragstart=&#39;return false&#39; onselectstart =&#39;return false&#39; onselect=&#39;document.selection.empty()&#39; oncopy=&#39;document.selection.empty()&#39; onbeforecopy=&#39;return false&#39; onmouseup=&#39;document.selection.empty()&#39;&gt;
&lt;/body&gt;
</code></pre>
<h4 id="禁止网页另存为：在body后面加入以下代码："><a href="#禁止网页另存为：在body后面加入以下代码：" class="headerlink" title="禁止网页另存为：在body后面加入以下代码："></a>禁止网页另存为：在body后面加入以下代码：</h4><pre><code class="html">&lt;noscript&gt; 
    &lt;iframe src=&quot;*.htm&quot;&gt;&lt;/iframe&gt; 
&lt;/noscript&gt; 
</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title>100行代码实现一个迷你Vue</title>
    <url>/2021/10/14/100%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%BF%B7%E4%BD%A0Vue/</url>
    <content><![CDATA[<p>100行代码实现一个迷你Vue…</p>
<span id="more"></span>

<h2 id="从MVVM谈起"><a href="#从MVVM谈起" class="headerlink" title="从MVVM谈起"></a>从MVVM谈起</h2><p>MVVM全称是Model-View-ViewModel。经历过还没有React、Vue等框架的那个年代的前端们应该都知道，手动去同步页面上的数据与视图是一件多么麻烦的事情，特别是在数据和交互较复杂的页面上，手动同步会带来代码冗余、容易出错、难以追踪错误等问题。</p>
<p>MVVM框架的出现解决了这个问题。我们只要建立好数据结构以及数据与视图的对应关系，在之后的开发中，只需要把关注点放在处理数据上，框架会自动帮我们处理好数据变动带来的视图更新。</p>
<h2 id="如何造一个MVVM"><a href="#如何造一个MVVM" class="headerlink" title="如何造一个MVVM"></a>如何造一个MVVM</h2><p>MVVM的核心功能在于将数据和视图关联起来。即监听数据变动的事件，事件触发时对关联这个数据的视图进行更新。</p>
<p>我们先明确想要实现的功能，再去思考怎么实现。这里用一个例子来说明： 现在有格式如下的数据</p>
<pre><code class="js">let data = &#123; text: &#39;world&#39; &#125;;            
</code></pre>
<p>以及语法如下的视图</p>
<pre><code class="html">&lt;body&gt;
    &lt;div&gt;hello&lt;/div&gt;
    &lt;div&gt;&#123;&#123; text &#125;&#125;&lt;/div&gt;
&lt;/body&gt;
</code></pre>
<p>咱们想要实现的是： 初始化后，<div></div>会被解析为<div>world</div>渲染到页面上。执行data.text = ‘vue’ 后，该DOM节点会被重新解析为<div>vue</div>，并在页面上更新。</p>
<p>要达到这个效果，我们需要做的东西有：</p>
<ol>
<li>能监听数据变化的观察者（Observer），来监听data.text的变化</li>
<li>编译DOM的编译器（Compiler），将<div></div>中的text替换成对应数据，并更新该DOM节点。</li>
<li>连接Observer和Compiler的桥梁（Dependence &amp; Watcher），它的作用是当Observer监听到某数据变化时，去通知所有依赖该数据的Compiler，让它们重新编译并更新DOM。</li>
</ol>
<p>OK，思路整理完毕，接下来一步步实现。</p>
<h2 id="动手实现迷你Vue"><a href="#动手实现迷你Vue" class="headerlink" title="动手实现迷你Vue"></a>动手实现迷你Vue</h2><h2 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h2><p>数据是存放在data对象上的，要监听数据变化也就是监听对象的键值变化（这里先不讨论有数组的情况），此时可以借助Reflect的defineProperty来实现。</p>
<p>先来做个小实验，执行下列代码</p>
<pre><code class="js">let data = &#123; text: &#39;world&#39; &#125;;
let val = data.text;
Reflect.defineProperty(data, &#39;text&#39;, &#123;
    get () &#123;
        console.log(&#39;get: &#39; + val);
        return val;
    &#125;,
    set (newVal) &#123;
        console.log(&#39;set: &#39; + newVal);
        val = newVal;
    &#125;
&#125;);
data.text = &#39;vue&#39;;
console.log(data.text);

// 控制台输出如下
// &#39;set: vue&#39;
// &#39;get: vue&#39;
// &#39;vue&#39;
</code></pre>
<p>可以看到date.text设值和取值的过程都被监听到了，这样我们可以在getter和setter中加入逻辑来完成对数据变动的监听。</p>
<p>虽然监听成功了，但是还需要对这个方法加工一下，使其能够应对对象有多个键以及对象里面还有对象的情况</p>
<pre><code class="js">let data = &#123; text: &#39;world&#39; &#125;;

function observe (data) &#123; // 监听对象
    if (Object.prototype.toString.call(data) === &#39;[object Object]&#39;) &#123; // 确保监听对象是Object
        for (let prop in data) &#123;
            defineReactive(data, prop, data[prop]);
        &#125;
    &#125;
&#125;

function defineReactive (obj, key, val) &#123; // 对对象的key进行监听
    Reflect.defineProperty(obj, key, &#123;
        enumerable: true,
        configurable: true,
        get () &#123;
            return val;
        &#125;,
        set (newVal) &#123;
            if (newVal === val) return;
            val = newVal;
            observe(newVal); // 监听新的键值
        &#125;
    &#125;);
    observe(val); // 递归监听对象的键值
&#125;

observe(data);
</code></pre>
<p>这时我们已经能够对data对象里的数据变动进行监听了。这里要注意的是，直接对对象的一个新key赋值是不会被监听到的（因为这个新的key并没有被设置getter/setter），所以需要在一开始就把data中需要的key先列出来，使其被监听到。</p>
<p>接下来我们为每个key构造一个容器。这个容器（Dependence）需要能够接受这个key的数据变动事件，然后通知给关心该事件的所有订阅者（Subscription），所以它的方法应该有：1. 添加订阅者 2. 删除订阅者 3. 通知所有订阅者。这一步我们不去管订阅者怎么实现，先把这个容器写出来，后面再完善。</p>
<pre><code class="js">class Dep &#123;
    constructor () &#123;
        this.subs = new Set();
    &#125;
    addSub (sub) &#123; // 添加订阅者，因为用了Set，所以这里可以保证添加进来的订阅者不会重复
        this.subs.add(sub);
    &#125;
    removeSub (sub) &#123; // 删除订阅者
        this.subs.delete(sub);
    &#125;
    notify () &#123; // 通知所有订阅者（调用每个订阅者的update方法）
        for (let sub of this.subs) &#123;
            sub.update();
        &#125;
    &#125;
&#125;
</code></pre>
<p>然后把这个容器和前面的defineReactive函数结合起来</p>
<pre><code class="js">function defineReactive (obj, key, val) &#123;
    const dep = new Dep(); // 为每个key构造一个存放关心该key的订阅者的容器
    Reflect.defineProperty(obj, key, &#123;
        enumerable: true,
        configurable: true,
        get () &#123;
            return val;
        &#125;,
        set (newVal) &#123;
            if (newVal === val) return;
            val = newVal;
            observe(newVal);
            dep.notify(); // 当key变化时通知该容器下的所有订阅者
        &#125;
    &#125;);
    observe(val);
&#125;
</code></pre>
<p>观察者（Observer）已经基本上完成了。下一步我们来实现编译器（Compiler）。</p>
<h2 id="Compiler"><a href="#Compiler" class="headerlink" title="Compiler"></a>Compiler</h2><p>现在我们需要一个编译器来遍历DOM树，并把需要编译的部分替换成编译的结果。</p>
<p>第一步是模板编译。</p>
<p>我们以一个简单例子开始，定义一个数据源</p>
<pre><code class="js">let data = &#123; text: &#39;world&#39; &#125;;
</code></pre>
<pre><code class="js">以及这样一段模板：hello &#123;&#123; text &#125;&#125; !
我们想要的编译效果是，把&#123;&#123;&#125;&#125;之外的内容用字符串原封不动地输出，把&#123;&#123;&#125;&#125;之内的代码作为js表达式输出，然后把它们拼接到一起，供之后的代码使用。要实现这个效果，需要对模板进行正则解析
</code></pre>
<pre><code class="js">function textToExp (text) &#123;
    let pieces = text.split(/(&#123;&#123;.+?&#125;&#125;)/g);
    pieces = pieces.map(piece =&gt; &#123;
        if (piece.match(/&#123;&#123;.+?&#125;&#125;/g)) &#123; // &#123;&#123;&#125;&#125;内的代码，以js表达式输出
            piece = '(' + piece.replace(/^&#123;&#123;|&#125;&#125;$/g, &#39;&#39;) + &#39;)&#39;;
        &#125; else &#123; // &#123;&#123;&#125;&#125;外的代码，以字符串输出
            piece = '`' + piece.replace(/`/g, '\\`') + '`'; // 需要对字符串中的`转义
        &#125;
        return piece;
    &#125;);
    return pieces.join('+');
&#125;

console.log(textToExp('hello &#123;&#123; text &#125;&#125; !&#39;));

// 控制台输出
// &#39;`hello `+( text )+` !`&#39;
</code></pre>
<p>拼接好的这段字符串可以用Function的构造函数转化成可执行代码，用法类似这样</p>
<pre><code class="js">function expToFunc (exp) &#123;
    return new Function(&#39;return &#39; + exp);
&#125;

let fn = expToFunc(&#39;`hi ` + name&#39;);
let name = &#39;nossika&#39;;

console.log(fn());

// 控制台输出
// &#39;hi nossika&#39;
</code></pre>
<p>但这样有一个问题，数据源data是一个对象，如何把表达式中的变量对应到data的属性上（比如text要对应到data.text）？</p>
<p>这个问题好像只要编译的时候在变量前面加上前缀data.编译成data.key这样的格式就可以解决。但是表达式不一定只是类似于的一个简单变量，也有可能是类似于 hi undefined的一些复杂情况，这时候可能就得再引入一个词法解析器来把表达式解析成抽象语法树，才能找出并操作里面的变量。</p>
<p>有个方法可以方便地解决这个加前缀的问题：使用with。虽然with并不被推荐使用，但对于这个问题使用with确实能省事不少。下面使用with来改造一下expToFunc函数，结合模板编译的例子 测试一下：</p>
<pre><code class="js">let data = &#123; text: &#39;world&#39; &#125;;

function expToFunc (exp, scope) &#123;
    // 把数据源绑定到函数的this，函数内部加上with(this)&#123;&#125;，这样函数内的变量访问的就是数据源上的key
    return new Function(&#39;with(this)&#123;return &#39; + exp + &#39;&#125;&#39;).bind(scope); 
&#125;

let fn = expToFunc(&#39;`hello `+( text )+` !`&#39;, data);

console.log(fn());

// 控制台输出
// &#39;hello world !&#39;
</code></pre>
<p>现在我们已经能够结合数据源对文本进行编译了，但我们需要的功能是：传入一个DOM树和数据源，DOM树上的节点会被遍历并编译，所以得再封装一下：</p>
<pre><code class="js">function textToExp (text) &#123;
    // ...
&#125;
    
function expToFunc (exp, scope) &#123;
    // ...
&#125;

function walkChildren (el, scope) &#123;
    // el.childNodes获取到的是NodeList对象，先把它转化Array
    [].slice.call(el.childNodes).forEach(node =&gt; &#123;
        if (node.nodeType === 3) &#123; // 对文本节点编译并替换文本内容
            compileText(node, scope);
        &#125; else if (node.nodeType === 1) &#123; // 对元素节点则继续遍历
            walkChildren(node, scope);
        &#125;
    &#125;);
&#125;

function compileText (node, scope) &#123; // 结合 textToExp 和 expToFunc 来完成文本编译
    let exp = textToExp(node.textContent);
    node.textContent = expToFunc(exp, scope)();
&#125;
</code></pre>
<p>然后结合DOM测试一下walkChildren：</p>
<pre><code class="html">&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;div&gt;hello&lt;/div&gt;
        &lt;div&gt;&#123;&#123; text &#125;&#125;&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
&lt;script&gt;
    // ...
    let data = &#123; text: &#39;world&#39; &#125;;
    walkChildren(document.querySelector(&#39;#app&#39;), data);
&lt;/script&gt;
</code></pre>
<p>执行完walkChildren后，页面上最终的DOM被渲染成：</p>
<pre><code class="html">&lt;body&gt;
    &lt;div id=&quot;app&quot;&gt;
        &lt;div&gt;hello&lt;/div&gt;
        &lt;div&gt;world&lt;/div&gt;
    &lt;/div&gt;
&lt;/body&gt;
</code></pre>
<p>编译器（Compiler）也基本上完成了，现在还剩下最后一步：我们需要在data中的数据改变的时候，重新触发对应的Compiler来对DOM进行更新。所以我们再引入一个Watcher，来把Observer和Compiler关联起来。</p>
<h2 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h2><p>在前面的Observer一节中，我们为数据源的每个key创建了一个Dep实例，这个Dep能够容纳多个订阅者，并且能够在key改变的时候通知这些订阅者（即触发订阅者的update方法）。这里所说的订阅者就是本节的Watcher，订阅者的update方法就是去调用Compiler。</p>
<p>为满足我们的需求，Watcher应该存放三样东西：原始表达式（exp）、数据源（scope）、DOM更新函数（callback）。当触发它的update方法时，它会根据数据源和原始表达式来编译出最新的文本，然后调用DOM更新函数来更新DOM。下面先把Watcher的大致样子写出来：</p>
<pre><code class="js">class Watcher &#123;
    constructor (exp, scope, callback) &#123;
        this.value = null; // 存放当前编译结果
        this.getValue = expToFunc(exp, scope); // 生成编译结果的函数
        this.callback = callback;
        this.update(); // 绑定时需要编译一次
    &#125;
    get () &#123;
        return this.getValue();
    &#125;
    update () &#123;
        let newVal = this.get();  // 获取最新编译结果
        if (this.value !== newVal) &#123; // 如果最新编译结果和当前的不一样，则调用callback更新DOM
            this.value = newVal;
            this.callback &amp;&amp; this.callback(newVal);
        &#125;
    &#125;
&#125;
</code></pre>
<p>然后修改一下Compiler中的逻辑，编译文本节点时，为这个文本节点创建一个Watcher，把它交给Watcher来更新。其实就是对compileText函数小小的修改一下：</p>
<pre><code class="text">// 原来的compileText
function compileText (node, scope) &#123;
    let exp = textToExp(node.textContent);
    node.textContent = expToFunc(exp, scope)();
&#125;
</code></pre>
<p>改为</p>
<pre><code class="js">// 结合Watcher的原来的compileText
function compileText (node, scope) &#123;
    let exp = textToExp(node.textContent);
    // Watcher绑定时会先编译一次，所以这里不需要再手动修改node.textContent
    new Watcher(exp, scope, newVal =&gt; &#123;
        node.textContent = newVal;
    &#125;);
&#125;
</code></pre>
<p>现在再理一下思路，我们整理出来的流程是：数据源的key改变时，会去调用该key下的Dep中的每个Watcher的update方法来更新DOM。现在Dep有了，Watcher也有了。</p>
<p>接下来就是最关键的一步了，怎么把Watcher添加到对应的Dep中呢？</p>
<p>似乎应该在绑定Watcher的时候，去解析表达式中关联了数据源中的哪些key，然后把这个Watcher添加到这些key下的Dep中。如果这样处理的话还是得引入一个词法解析器才能解析出表达式中关联的key。</p>
<p>Vue中用了一个非常精妙的方法解决了这个问题：利用getter。</p>
<p>Watcher的编译是用到了expToFunc(this.exp, this.scope)()，这个过程会把表达式变成类似with(scope){return prop1 + prop2}的函数，写得更直观一点就是return scope.prop1 + scope.prop2，并且执行它来求表达式的值。所以在这个过程中其实已经调用了表达式中关联的scope的key的getter。所以只要在key的getter中把这个Watcher添加到Dep就可以了。</p>
<p>为实现这个效果，我们需要引入一个全局标记，初始值是null，在Watcher执行编译前把这个标记指向当前Watcher实例。编译过程中会触发各个key的getter，getter中需要判断标记指向的是否指向一个Watcher，是的话把该Watcher添加到Dep中。编译结束后再把这个标记指向null。</p>
<p>这个全局标记可以挂在Dep的静态属性上，我们给Dep添加一条静态属性target：</p>
<pre><code class="js">class Dep &#123;
    static target = null;
    // ...
&#125;
</code></pre>
<p>然后修改一下Watcher，在编译前后改变target的指向：</p>
<pre><code class="js">class Watcher &#123;
    // ...
    get () &#123;
        Dep.target = this; // 编译前把target指向当前Watcher实例
        let value = this.getValue(); // 这个编译过程中会触发关联的key的getter
        Dep.target = null; // 编译后把target重置
        return value;
    &#125;
    // ...
&#125;
</code></pre>
<p>最后修改一下Observer中defineReactive，在getter中把target指向的Watcher添加到Dep：</p>
<pre><code class="js">function defineReactive (obj, key, val) &#123;
    const dep = new Dep();
    Reflect.defineProperty(obj, key, &#123;
        enumerable: true,
        configurable: true,
        get () &#123;
            // 如果target指向了Watcher，就把这个Watcher添加到Dep
            // Dep的addSub是一个Set，所以不会把一个相同的Watcher添加多次
            Dep.target &amp;&amp; dep.addSub(Dep.target);
            return val;
        &#125;,
        set (newVal) &#123;
            if (newVal === val) return;
            val = newVal;
            observe(newVal);
            dep.notify();
        &#125;
    &#125;);
    observe(val);
&#125;
</code></pre>
<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><p>到这里我们已经把所有的部分（Observer，Compiler，Dep，Watcher）都实现了，现在把它们组装到一起：</p>
<pre><code class="js">class Vue &#123;
    constructor (options) &#123;
        this.$data = options.data;
        this.$el = document.querySelector(options.el);
        observe(this.$data);
        walkChildren(this.$el, this.$data);
    &#125;
&#125;
</code></pre>
<p>然后像这样去调用：</p>
<pre><code class="js">let vm = new Vue(&#123;
    el: &#39;#app&#39;,
    data: &#123;
        text: &#39;world&#39;
    &#125;
&#125;);
</code></pre>
<p>这里还可以做一个优化，目前改变数据需要像vm.$data.text = ‘new value’这样写，如果能够像vm.text = ‘new value’这样就要方便多了。我们加个代理函数proxy：</p>
<pre><code class="js">function proxy (vm, options) &#123;
    for (let prop in options.data) &#123;
        Reflect.defineProperty(vm, prop, &#123;
            enumerable: true,
            configurable: true,
            get () &#123;
                return vm.$data[prop]; // 调用vm.$data的getter
            &#125;,
            set (newVal) &#123;
                vm.$data[prop] = newVal; // 调用vm.$data的setter
            &#125;
        &#125;)
    &#125;
&#125;

class Vue &#123;
    constructor (options) &#123;
        this.$data = options.data;
        this.$el = document.querySelector(options.el);
        observe(this.$data);
        proxy(this, options);
        walkChildren(this.$el, this.$data);
    &#125;
&#125;
</code></pre>
<p>这样就可以直接对vm.text直接取值和赋值了。</p>
<p>到这里，我们要做的迷你Vue已经全部完成了，它实现了MVVM核心的数据视图绑定功能。有兴趣的读者可移步到<a href="https://link.zhihu.com/?target=https://github.com/nossika/little-vue">github:little-vue</a>自行查看源码，其中实现了更多Vue的api（支持对数组监听，支持v-if等属性节点编译、更多options选项，nextTick优化等）。</p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码:"></a>完整代码:</h2><pre><code class="js">// Observer

function observe (data) &#123;
    if (Object.prototype.toString.call(data) === &#39;[object Object]&#39;) &#123;
        for (let prop in data) &#123;
            defineReactive(data, prop, data[prop]);
        &#125;
    &#125;
&#125;

function defineReactive (obj, key, val) &#123;
    const dep = new Dep();
    Reflect.defineProperty(obj, key, &#123;
        enumerable: true,
        configurable: true,
        get () &#123;
            Dep.target &amp;&amp; dep.addSub(Dep.target);
            return val;
        &#125;,
        set (newVal) &#123;
            if (newVal === val) return;
            val = newVal;
            observe(newVal);
            dep.notify();
        &#125;
    &#125;);
    observe(val);
&#125;

// Dep

class Dep &#123;
    constructor () &#123;
        this.subs = new Set();
    &#125;
    addSub (sub) &#123;
        this.subs.add(sub);
    &#125;
    removeSub (sub) &#123;
        this.subs.delete(sub);
    &#125;
    notify () &#123;
        for (let sub of this.subs) &#123;
            sub.update();
        &#125;
    &#125;
&#125;
Dep.target = null;

// Compiler

function textToExp (text) &#123;
    let pieces = text.split(/(&#123;&#123;.+?&#125;&#125;)/g);
    pieces = pieces.map(piece =&gt; &#123;
        if (piece.match(/&#123;&#123;.+?&#125;&#125;/g)) &#123;
            piece = &#39;(&#39; + piece.replace(/^&#123;&#123;|&#125;&#125;$/g, &#39;&#39;) + &#39;)&#39;;
        &#125; else &#123;
            piece = &#39;`&#39; + piece.replace(/`/g, &#39;\\`&#39;) + &#39;`&#39;;
        &#125;
        return piece;
    &#125;);
    return pieces.join(&#39;+&#39;);
&#125;

function expToFunc (exp, scope) &#123;
    return new Function(&#39;with(this)&#123;return &#39; + exp + &#39;&#125;&#39;).bind(scope);
&#125;

function walkChildren (el, scope) &#123;
    [].slice.call(el.childNodes).forEach(node =&gt; &#123;
        if (node.nodeType === 3) &#123;
            compileText(node, scope);
        &#125; else if (node.nodeType === 1) &#123;
            walkChildren(node, scope);
        &#125;
    &#125;);
&#125;

function compileText (node, scope) &#123;
    let exp = textToExp(node.textContent);
    new Watcher(exp, scope, newVal =&gt; &#123;
        node.textContent = newVal;
    &#125;);
&#125;

// Watcher

class Watcher &#123;
    constructor (exp, scope, callback) &#123;
        this.value = null;
        this.getValue = expToFunc(exp, scope);
        this.callback = callback;
        this.update();
    &#125;
    get () &#123;
        Dep.target = this;
        let value = this.getValue();
        Dep.target = null;
        return value;
    &#125;
    update () &#123;
        let newVal = this.get();
        if (this.value !== newVal) &#123;
            this.value = newVal;
            this.callback &amp;&amp; this.callback(newVal);
        &#125;
    &#125;
&#125;

// Vue

function proxy (vm, options) &#123;
    for (let prop in options.data) &#123;
        Reflect.defineProperty(vm, prop, &#123;
            enumerable: true,
            configurable: true,
            get () &#123;
                return vm.$data[prop];
            &#125;,
            set (newVal) &#123;
                vm.$data[prop] = newVal;
            &#125;
        &#125;)
    &#125;
&#125;

class Vue &#123;
    constructor (options) &#123;
        this.$data = options.data;
        this.$el = document.querySelector(options.el);
        observe(this.$data);
        proxy(this, options);
        walkChildren(this.$el, this.$data);
    &#125;
&#125;
</code></pre>
<p>转载于:<a href="https://zhuanlan.zhihu.com/p/29629337">100行代码实现一个迷你Vue</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用操作整理</title>
    <url>/2021/08/13/Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<p>Git常用操作整理…</p>
<span id="more"></span>

<h4 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h4><ul>
<li><h5 id="git-clone-克隆仓库代码："><a href="#git-clone-克隆仓库代码：" class="headerlink" title="git clone 克隆仓库代码："></a>git clone 克隆仓库代码：</h5><p>git clone <a href="https://gitee.com/houpai/git-demo.git%EF%BC%88%E4%BB%93%E5%BA%93%E5%9C%B0%E5%9D%80%EF%BC%89">https://gitee.com/houpai/git-demo.git（仓库地址）</a></p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813100147449.png" alt="image-20210813100147449"></p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813100121447.png" alt="image-20210813100121447"></p>
<ul>
<li><h5 id="git-status查看本地工作区状态"><a href="#git-status查看本地工作区状态" class="headerlink" title="git status查看本地工作区状态"></a>git status查看本地工作区状态</h5><p>git status</p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813102546895.png" alt="image-20210813102546895"></p>
<p>如图上所示Untacked files提示该文件为添加到版本追踪里</p>
</li>
<li><h5 id="git-add-把修改-新增等提交暂存区"><a href="#git-add-把修改-新增等提交暂存区" class="headerlink" title="git add 把修改/新增等提交暂存区"></a>git add 把修改/新增等提交暂存区</h5><p> git add . ： 提交新文件(new)和被修改(modified)文件，不包括被删除(deleted)文件;–仅针对git版本为1.X的，目前2.X的含义是提交所有变化；</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813104533648.png" alt="image-20210813104533648"></p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813104738794.png" alt="image-20210813104738794"></p>
<ul>
<li><h5 id="git-add-–u-提交被修改-modified-和被删除-deleted-文件，不包括新文件-new"><a href="#git-add-–u-提交被修改-modified-和被删除-deleted-文件，不包括新文件-new" class="headerlink" title="git add –u :  提交被修改(modified)和被删除(deleted)文件，不包括新文件(new);"></a>git add –u :  提交被修改(modified)和被删除(deleted)文件，不包括新文件(new);</h5><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813105228259.png" alt="image-20210813105228259"></p>
</li>
</ul>
<ul>
<li><h5 id="git-add-–A-提交所有变化"><a href="#git-add-–A-提交所有变化" class="headerlink" title="git add –A : 提交所有变化"></a>git add –A : 提交所有变化</h5></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813105329430.png" alt="image-20210813105329430"></p>
<blockquote>
<p><code>PS：在未commit命令之前，如果想撤销add , 可以用命令：git reset；</code></p>
</blockquote>
<ul>
<li><h5 id="git-commit-将暂存区的改动提交到本地仓库"><a href="#git-commit-将暂存区的改动提交到本地仓库" class="headerlink" title="git commit 将暂存区的改动提交到本地仓库"></a>git commit 将暂存区的改动提交到本地仓库</h5></li>
</ul>
<ol>
<li><p>每次使用git commit 命令我们都会在本地版本库生成一个40位的哈希值，这个哈希值也叫commit-id，commit-id在版本回退的时候是非常有用的，它相当于一个快照,可以在未来的任何时候通过与git reset的组合命令回到这里；</p>
</li>
<li><p>git commit –amend (原来提交基础上提交，不是新的提交) </p>
</li>
</ol>
<ul>
<li><h5 id="git-log-查看提交历史"><a href="#git-log-查看提交历史" class="headerlink" title="git log 查看提交历史"></a>git log 查看提交历史</h5><p> git log : 默认不用任何参数的话，git log 会按提交时间列出所有的更新，最近的更新排在最上面。每次更新都有一个 SHA-1 校验和、作者的名字和电子邮件地址、提交时间，最后缩进一个段落显示提交说明—commit –m 里的message。</p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813115345755.png" alt="image-20210813115345755"></p>
</li>
</ul>
<p>​    </p>
<p>​        git log –p: 选项展开显示每次提交的内容差异        </p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813115526464.png" alt="image-20210813115526464"></p>
<blockquote>
<p><code>PS:退出 :q</code></p>
</blockquote>
<p>​    git log -1 : 后面加数字，显示最近的几次提交</p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813132434260.png" alt="image-20210813132434260"></p>
<p>​    git log –p –word-diff : 单词层面上的对比</p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813132632230.png" alt="image-20210813132632230"></p>
<ul>
<li><h5 id="git-pull-将本地仓更新至远程仓的最新状态，获取代码并自动合并"><a href="#git-pull-将本地仓更新至远程仓的最新状态，获取代码并自动合并" class="headerlink" title="git pull : 将本地仓更新至远程仓的最新状态，获取代码并自动合并"></a>git pull : 将本地仓更新至远程仓的最新状态，获取代码并自动合并</h5><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813132746452.png" alt="image-20210813132746452"></p>
</li>
</ul>
<ul>
<li><h5 id="git-push-将本地分支的更新，推送到远程仓库"><a href="#git-push-将本地分支的更新，推送到远程仓库" class="headerlink" title="git push : 将本地分支的更新，推送到远程仓库"></a>git push : 将本地分支的更新，推送到远程仓库</h5><p> 如果当前分支和远程分支之前存在追踪关系，则git push origin 的含义是：将当前分支推送到origin主机的对应分支上；</p>
</li>
</ul>
<ul>
<li><h5 id="git-branch-–vv-查看本地当前分支与远程分支的追踪关系"><a href="#git-branch-–vv-查看本地当前分支与远程分支的追踪关系" class="headerlink" title="git branch –vv : 查看本地当前分支与远程分支的追踪关系"></a>git branch –vv : 查看本地当前分支与远程分支的追踪关系</h5><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813133729555.png" alt="image-20210813133729555"></p>
<blockquote>
<p><code>更改分支名称：git branch –m 改之前的分支名称  改之后的分支名称</code></p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813134333892.png" alt="image-20210813134333892"></p>
</li>
</ul>
<ul>
<li><h5 id="git-checkout-切换分支"><a href="#git-checkout-切换分支" class="headerlink" title="git checkout : 切换分支"></a>git checkout : 切换分支</h5><p>  git checkout dev : 切换到dev 分支；</p>
<p>  git checkout –b dev :以当前分支为源创建分支dev；</p>
<blockquote>
<p><code>PS: git checkout –b dev是 git branch dev  ; git checkout dev 两条命令的简写</code></p>
</blockquote>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813134601212.png" alt="image-20210813134601212"></p>
<p>​        如果本地已经存在dev分支，则会提示；</p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813134706819.png" alt="image-20210813134706819">    </p>
<blockquote>
<p><code>PS：新创建的分支，是没有与远程关联的，需要先建立关联，把本地分支与远程建立追踪关系；git push --set-upstream origin dev</code></p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813135718369.png" alt="image-20210813135718369"></p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813140211171.png" alt="image-20210813140211171"></p>
<blockquote>
<p>​    <code>PS: git checkout --filename :该命令适用于：已经add后，后来又修改了文件，想要恢复之前add 的内容，则就可以把暂存区的内容替换到工作区了；或者没add 之前，我想把修改的内容恢复，也可以用git checkout filename;</code></p>
</blockquote>
<ul>
<li><h5 id="git-revert-撤销某次操作，并把此次撤销作为新的提交-请谨慎操作！）"><a href="#git-revert-撤销某次操作，并把此次撤销作为新的提交-请谨慎操作！）" class="headerlink" title="git revert :撤销某次操作，并把此次撤销作为新的提交( 请谨慎操作！）"></a>git revert :撤销某次操作，并把此次撤销作为新的提交( 请谨慎操作！）</h5><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813140902822.png" alt="image-20210813140902822"></p>
</li>
</ul>
<p>​    git revert HEAD ：撤销前一次的commit ；</p>
<p>​    git  revert HEAD^ :撤销前前一次的commit;</p>
<p>​    git  revert commit-id :撤销指定版本的提交；</p>
<p>​    可以在命令中加上–no-edit参数。另一个重要的参数是-n或者–no-commit，应用这个参数会让revert 改动只限于程序员的本地仓库，而不自动进行commit</p>
<ul>
<li><h5 id="git-reset-用来将当前branch重置到另外一个commit的-请谨慎操作！）"><a href="#git-reset-用来将当前branch重置到另外一个commit的-请谨慎操作！）" class="headerlink" title="git reset : 用来将当前branch重置到另外一个commit的( 请谨慎操作！）"></a>git reset : 用来将当前branch重置到另外一个commit的( 请谨慎操作！）</h5><p>git reset HEAD : 重置当前分支到最近的一次提交；（HEAD这是当前分支版本顶端的别名，也就是在当前分支你最近的一个提交）</p>
<p>git reset HEAD~1 : 将HEAD从顶端的commit往下移动一个commit；从暂存区取出，替换到工作区；</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813141313715.png" alt="image-20210813141313715"></p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813141558893.png" alt="image-20210813141558893"></p>
<blockquote>
<p><code>参数：--soft : 重置HEAD到另外一个commit，但也到此为止 , 所有变更都集中到暂存区，工作区；</code></p>
<p><code>--hard ：危险操作，所有变更全部丢失，不管本地仓，暂存区，工作区；</code></p>
<p><code>--mixed : 所有变更保存到工作区，本地仓，暂存区都丢失；默认参数；</code></p>
</blockquote>
<ul>
<li><h5 id="git-stash-储藏变更"><a href="#git-stash-储藏变更" class="headerlink" title="git stash : 储藏变更"></a>git stash : 储藏变更</h5><p>使用场景：当前工作区有变更，且作业没完成，但是需要切换到其他分支进行其他作业，需要干净的工作区间；</p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813145829941.png" alt="image-20210813145829941"></p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813150225555.png" alt="image-20210813150225555"></p>
</li>
</ul>
<p>​    查看现有的所有储存：git stash list </p>
<p>​    <img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813150419586.png" alt="image-20210813150419586"></p>
<p>其他分支作业完成后，返回之前分支，继续之前作业：git stash pop</p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813150550178.png" alt="image-20210813150550178"></p>
<blockquote>
<p><code>删除没用的储存：git stash drop stash@&#123;0&#125; / git stash clear</code></p>
</blockquote>
<ul>
<li><h5 id="git-merge-合并分支到当前分支"><a href="#git-merge-合并分支到当前分支" class="headerlink" title="git merge : 合并分支到当前分支"></a>git merge : 合并分支到当前分支</h5><p>首先切换到要合并的目标分支，比如把dev分支合并到master分支上，先切到master分支；</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813151449597.png" alt="image-20210813151449597"></p>
<p>​    git merge dev :把dev 分支合并到当前分支</p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813151548854.png" alt="image-20210813151548854"></p>
<p>​     如果没有冲突的话，merge完成。有冲突的话，git会提示那个文件中有冲突，比如有如下冲突：</p>
<p>​    <img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813151658048.png" alt="image-20210813151658048"></p>
<p>​    可以看到 ======= 隔开的上半部分，是 master 分支冲突的内容，下半部分是在 dev分支冲突的内容。</p>
<p>​    这个时候可以解决完冲突之后再进行相关操作：git add ; git commit 等等.</p>
<ul>
<li><h5 id="git-rebase-对于分支做‘变基’操作，可以理解为‘重新设置基线’"><a href="#git-rebase-对于分支做‘变基’操作，可以理解为‘重新设置基线’" class="headerlink" title="git rebase : 对于分支做‘变基’操作，可以理解为‘重新设置基线’"></a>git rebase : 对于分支做‘变基’操作，可以理解为‘重新设置基线’</h5><p>该命令适应于自己本地私有分支，远程分支慎用；</p>
<p>使用场景1：当你本地试图commit ,push 到一个remote时而因tracking branch过于陈旧而被拒绝的时候（原因是自从之前与orgin同步后，有其他人员提交了很多commit），如果强行push，会覆盖远程仓，把其他人员的commit给丢掉–谨慎，谨慎，谨慎；</p>
<p>回到rebase之前的状态：git rebase –abort </p>
<p>使用场景2：本地开发多次提交合并，便于管理跟踪，比如：dev 分支从master分支上创建，然后dev分支上自己提交了多个commit , </p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813155225050.png" alt="image-20210813155225050"></p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813155241666.png" alt="image-20210813155241666"></p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813155250923.png" alt="image-20210813155250923"></p>
<p>​    我们设置第二个”pick 657a291 add 2.txt” 为” s 657a291 add 2.txt”这里的s就是squash命令的简写。</p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813155306599.png" alt="image-20210813155306599"></p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813155316585.png" alt="image-20210813155316585"></p>
<p>​    删除之前的两条message(ESC dd)，设置一总的message 然后保存退出。(ESC wq)</p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813155333578.png" alt="image-20210813155333578"></p>
<ul>
<li><h5 id="git-fsck-–lost-found-找回git-add-过，但是已经删除的文件内容"><a href="#git-fsck-–lost-found-找回git-add-过，但是已经删除的文件内容" class="headerlink" title="git fsck –lost-found : 找回git add 过，但是已经删除的文件内容"></a>git fsck –lost-found : 找回git add 过，但是已经删除的文件内容</h5></li>
<li><h5 id="git-branch-查看分支情况"><a href="#git-branch-查看分支情况" class="headerlink" title="git branch : 查看分支情况"></a>git branch : 查看分支情况</h5><p>查看项目的目前存在的分支情况，包括本地和远程 : git branch -a</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813155514556.png" alt="image-20210813155514556"></p>
<p>删除本地分支 ：git branch –d dev (-d , 删除分支； -D ,强制删除分支)</p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813155822581.png" alt="image-20210813155822581"></p>
<p>删除远程分支: git push origin :dev</p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813155923526.png" alt="image-20210813155923526"></p>
<h4 id="常用技巧"><a href="#常用技巧" class="headerlink" title="常用技巧"></a>常用技巧</h4><ul>
<li><h5 id="修改当前的追踪关系"><a href="#修改当前的追踪关系" class="headerlink" title="修改当前的追踪关系"></a>修改当前的追踪关系</h5><p>文件修改：本地打开.git à config 文件，别用记事本，修改[branch “master”]这一项是修改本地分支‘master’的远程追踪关系分支，直接修改merge = refs/heads/master为merge = refs/heads/dev；</p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813160042246.png" alt="image-20210813160042246"></p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813160058861.png" alt="image-20210813160058861"></p>
<p>​    命令修改：git branch –set-upstream-to=origin/master</p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813160112683.png" alt="image-20210813160112683"></p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813160130746.png" alt="image-20210813160130746"></p>
<ul>
<li><h5 id="查看远程版本库信息"><a href="#查看远程版本库信息" class="headerlink" title="查看远程版本库信息"></a>查看远程版本库信息</h5><p>git remote –v:</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813160215210.png" alt="image-20210813160215210"></p>
<ul>
<li><h5 id="更改远程仓库连接地址"><a href="#更改远程仓库连接地址" class="headerlink" title="更改远程仓库连接地址"></a>更改远程仓库连接地址</h5><p>ssh执行：git remote set-url origin <a href="mailto:&#103;&#x69;&#116;&#64;&#x67;&#105;&#x74;&#x65;&#101;&#46;&#99;&#111;&#x6d;">&#103;&#x69;&#116;&#64;&#x67;&#105;&#x74;&#x65;&#101;&#46;&#99;&#111;&#x6d;</a>:houpai/git-demo.git</p>
<p>http执行：git remote set-url origin  <a href="https://github.com/NECKLI/git-test.git">https://github.com/NECKLI/git-test.git</a></p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813161758028.png" alt="image-20210813161758028"></p>
<ul>
<li><h5 id="放弃本地修改，强制更新到本地"><a href="#放弃本地修改，强制更新到本地" class="headerlink" title="放弃本地修改，强制更新到本地"></a>放弃本地修改，强制更新到本地</h5><p>git fetch –all  //只下载远程的库的内容，不做任何的合并</p>
<p>git reset –hard origin/master  //把HEAD指向刚下载的最新版本</p>
</li>
</ul>
<ul>
<li><h5 id="查看当前分支是基于哪个分支建立的"><a href="#查看当前分支是基于哪个分支建立的" class="headerlink" title="查看当前分支是基于哪个分支建立的"></a>查看当前分支是基于哪个分支建立的</h5><p>git reflog –-date=local</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813162919105.png" alt="image-20210813162919105"></p>
<ul>
<li><h5 id="将某次提交合并到指定分支上"><a href="#将某次提交合并到指定分支上" class="headerlink" title="将某次提交合并到指定分支上"></a>将某次提交合并到指定分支上</h5><p>在修改分支上查看日志，找到对应的提交id</p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813163337230.png" alt="image-20210813163337230"></p>
<p>切换到指定分支: git checkout master1</p>
<p>再把指定的提交合并到当前分支：git cherry-pick commit-id</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813163622576.png" alt="image-20210813163622576"></p>
<ul>
<li><h5 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h5><p>先查看提交日志，找到要回退的版本，git log</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813163821444.png" alt="image-20210813163821444"></p>
<p>​    复制对应的commit id，<code>假如：e80d1d2e91b39a88908a3a0a31d15966d743c2df ；的提交； 本地版本回退：git reset --hard commit-id (如果确定不要该提交之后的提交，则可以用hard参数，如果要修改保留，则把hard参数去掉，重新提交)</code></p>
<p>本地之前的提交会全部丢失，使用的时候要谨慎；</p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813165148007.png" alt="image-20210813165148007"></p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813165633739.png" alt="image-20210813165633739"></p>
<p> <code>    本地强制覆盖远程，使用的时候要谨慎，谨慎，谨慎 ,会影响其他人员使用，如果某人错误覆盖，则远程的其他提交没有了记录，要找回的话，可以找其他人员没有更新之前的代码，再同步到远程，如果其他人手里也没有了，则可以使用git fsck找回，操作会麻烦，--没具体实现过（http://blog.sina.com.cn/s/blog_66cd08930102x0ln.html）</code></p>
<ul>
<li><h5 id="本地创建远程分支"><a href="#本地创建远程分支" class="headerlink" title="本地创建远程分支"></a>本地创建远程分支</h5><p>例子：如现在有master , dev 分支，现在本地想以dev 分支为基分支创建新分支，并推送远程仓库, git checkout –b newDev</p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813170306723.png" alt="image-20210813170306723"></p>
<p>将本地newDev 分支作为远程newDev分支: git push origin newDev</p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813170314683.png" alt="image-20210813170314683"></p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813170329076.png" alt="image-20210813170329076"></p>
<p>跟远程对应仓建立追踪关系： git branch –set-upstream-to=origin/newDev</p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813170336371.png" alt="image-20210813170336371"></p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210813170345098.png" alt="image-20210813170345098"></p>
<p>这个时候创建远程仓完成；在仓库里创建新分支比较简单，方便</p>
</li>
</ul>
<ul>
<li><h5 id="本地多次提交，push之前优化commits"><a href="#本地多次提交，push之前优化commits" class="headerlink" title="本地多次提交，push之前优化commits"></a>本地多次提交，push之前优化commits</h5></li>
</ul>
<p>​    git log 查看日志，找到要合并的commits</p>
<p>​    git rebase - i HEAD~2  ; //优化最近的两次提交</p>
<p>​    对于 commit 合并可以使用 squash、fixup 指令，区别是 squash 会将该 commit 的注释添加到上一个 commit 注释中，fixup 是放弃当前 commit 的注释。</p>
<p>​    编辑后保存退出，git 会自动压缩提交历史，如果有冲突，记得解决冲突后，使用 git rebase –continue 重新回到当前的 git 压缩过程；</p>
<p>​    git push 推送到远程，再看git log ，提交日志就简洁多了。</p>
<ul>
<li><h5 id="本地全新项目，建本地仓，然后推送到远程"><a href="#本地全新项目，建本地仓，然后推送到远程" class="headerlink" title="本地全新项目，建本地仓，然后推送到远程"></a>本地全新项目，建本地仓，然后推送到远程</h5><p>远程仓库先建立一个仓库；</p>
<p>切换到项目目录下，然后初始化本地git仓，git init ；</p>
<p>将本地仓与远程仓进行关联，git remote add origin https://…..  .git</p>
<p>把项目添加到本地仓，git add *  git commit –m ‘注释’;</p>
<p>推送到远程仓，git push –u origin master ，（远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令）。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Jetbrains系列产品重置试用方法</title>
    <url>/2021/05/04/Jetbrains%E7%B3%BB%E5%88%97%E4%BA%A7%E5%93%81%E9%87%8D%E7%BD%AE%E8%AF%95%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>记录一下如何重置Jetbrains的产品试用时间（30天试用期）…</p>
<span id="more"></span>
<p><strong>本站惯例：本文假定你知道Jetbrains家的产品。不知道可以问问搜索引擎。</strong></p>
<p>没错，<code>jetbrains-agent</code>这个项目停止了。市面上漫天飞的各种最新都是其他大神的魔改版本。[/斜眼]<br>我不是要专门写个博文来说明<code>jetbrains-agent</code>项目已经停止，然后缅怀感叹一番。这篇文章是想和大家聊聊<strong>另一种思路</strong>。</p>
<h2 id="0x0-项目背景"><a href="#0x0-项目背景" class="headerlink" title="0x0. 项目背景"></a>0x0. 项目背景</h2><p>Jetbrains家的产品有一个很良心的地方，他会允许你试用<code>30</code>天（这个数字写死在代码里了）以评估是否你真的需要为它而付费。<br>但很多时候会出现一种情况：<strong>IDE并不能按照我们实际的试用时间来计算。</strong><br>我举个例子：如果我们开始了试用，然后媳妇生孩子要你回去陪产！陪产时我们并无空闲对IDE试用评估，它依旧算试用时间。（只是举个例子，或许你并没有女朋友）<br>发现了吗？你未能真的有<code>30</code>天来对它进行全面的试用评估，你甚至无法作出是否付费的决定。此时你会想要延长试用时间，然而Jetbrains并未提供相关功能，该怎么办？</p>
<p>事实上有一款插件可以实现这个功能，你或许可以用它来重置一下试用时间。<strong>但切记不要无休止的一直试用，这并不是这个插件的本意！</strong></p>
<h2 id="0x1-如何安装"><a href="#0x1-如何安装" class="headerlink" title="0x1. 如何安装"></a>0x1. 如何安装</h2><h3 id="1-插件市场安装："><a href="#1-插件市场安装：" class="headerlink" title="1). 插件市场安装："></a>1). 插件市场安装：</h3><ul>
<li>在<code>Settings/Preferences...</code> -&gt; <code>Plugins</code> 内手动添加第三方插件仓库地址：<code>https://plugins.zhile.io</code></li>
<li>搜索：<code>IDE Eval Reset</code>插件进行安装。如果搜索不到请注意是否做好了上一步？网络是否通畅？</li>
<li>插件会提示安装成功。</li>
</ul>
<h3 id="2-下载安装："><a href="#2-下载安装：" class="headerlink" title="2). 下载安装："></a>2). 下载安装：</h3><ul>
<li>点击这个<a href="https://plugins.zhile.io/files/ide-eval-resetter-2.1.14-d2fedb86.zip">链接(v2.1.14)</a>下载插件的<code>zip</code>包（macOS可能会自动解压，然后把<code>zip</code>包丢进回收站）</li>
<li>通常可以直接把<code>zip</code>包拖进IDE的窗口来进行插件的安装。如果无法拖动安装，你可以在<code>Settings/Preferences...</code> -&gt; <code>Plugins</code> 里手动安装插件（<code>Install Plugin From Disk...</code>）</li>
<li>插件会提示安装成功。</li>
</ul>
<h2 id="0x2-如何使用"><a href="#0x2-如何使用" class="headerlink" title="0x2. 如何使用"></a>0x2. 如何使用</h2><ul>
<li>一般来说，在IDE窗口切出去或切回来时（窗口失去/得到焦点）会触发事件，检测是否长时间（<code>25</code>天）没有重置，给通知让你选择。（初次安装因为无法获取上次重置时间，会直接给予提示）</li>
<li>也可以手动唤出插件的主界面：<ul>
<li>如果IDE没有打开项目，在<code>Welcome</code>界面点击菜单：<code>Get Help</code> -&gt; <code>Eval Reset</code></li>
<li>如果IDE打开了项目，点击菜单：<code>Help</code> -&gt; <code>Eval Reset</code></li>
</ul>
</li>
<li>唤出的插件主界面中包含了一些显示信息，2个按钮，1个勾选项：<ul>
<li>按钮：<code>Reload</code> 用来刷新界面上的显示信息。</li>
<li>按钮：<code>Reset</code> 点击会询问是否重置试用信息并<strong>重启IDE</strong>。选择<code>Yes</code>则执行重置操作并<strong>重启IDE生效</strong>，选择<code>No</code>则什么也不做。（此为手动重置方式）</li>
<li>勾选项：<code>Auto reset before per restart</code> 如果勾选了，则自勾选后<strong>每次重启/退出IDE时会自动重置试用信息</strong>，你无需做额外的事情。（此为自动重置方式）</li>
</ul>
</li>
</ul>
<h2 id="0x3-如何更新"><a href="#0x3-如何更新" class="headerlink" title="0x3. 如何更新"></a>0x3. 如何更新</h2><h3 id="1-插件更新机制（推荐）："><a href="#1-插件更新机制（推荐）：" class="headerlink" title="1). 插件更新机制（推荐）："></a>1). 插件更新机制（推荐）：</h3><ul>
<li>IDE会自行检测其自身和所安装插件的更新并给予提示。如果本插件有更新，你会收到提示看到更新日志，自行选择是否更新。</li>
<li>点击IDE的<code>Check for Updates...</code> 菜单手动检测IDE和所安装插件的更新。如果本插件有更新，你会收到提示看到更新日志，自行选择是否更新。</li>
<li>插件更新可能会需要<strong>重启IDE</strong>。</li>
</ul>
<h3 id="2-手动更新："><a href="#2-手动更新：" class="headerlink" title="2). 手动更新："></a>2). 手动更新：</h3><ul>
<li>从本页面下载最新的插件<code>zip</code>包安装更新。参考本文：<code>下载安装</code>小节。</li>
<li>插件更新需要<strong>重启IDE</strong>。</li>
</ul>
<h2 id="0x4-一些说明"><a href="#0x4-一些说明" class="headerlink" title="0x4. 一些说明"></a>0x4. 一些说明</h2><ul>
<li><p>本插件默认不会显示其主界面，如果你需要，参考本文：<code>如何使用</code>小节。</p>
</li>
<li><p>市场付费插件的试用信息也会<strong>一并重置</strong>。</p>
</li>
<li><p>MyBatisCodeHelperPro</p>
<p>插件有两个版本如下，功能完全相同，安装时须看清楚！</p>
<ul>
<li><a href="https://plugins.jetbrains.com/plugin/14522-mybatiscodehelperpro-marketplace-edition-">MyBatisCodeHelperPro (Marketplace Edition)</a>，可重置！</li>
<li><del><a href="https://plugins.jetbrains.com/plugin/9837-mybatiscodehelperpro">MyBatisCodeHelperPro</a>，不可重置！</del></li>
</ul>
</li>
<li><p>对于某些付费插件（如:Iedis2,MinBatis）来说，你可能需要去取掉javaagent配置（如果有）后重启IDE：</p>
<ul>
<li>如果IDE没有打开项目，在<code>Welcome</code>界面点击菜单：<code>Configure</code> -&gt; <code>Edit Custom VM Options...</code> -&gt; 移除 <code>-javaagent:</code> 开头的行。</li>
<li>如果IDE打开了项目，点击菜单：<code>Help</code> -&gt; <code>Edit Custom VM Options...</code> -&gt; 移除 <code>-javaagent:</code> 开头的行。</li>
</ul>
</li>
<li><p>重置需要<strong>重启IDE生效</strong>！</p>
</li>
<li><p>重置后并不弹出<code>Licenses</code>对话框让你选择输入License或试用，这和之前的重置脚本/插件不同（省去这烦人的一步）。</p>
</li>
<li><p>如果长达<code>25</code>天不曾有任何重置动作，IDE会有<strong>通知询问</strong>你是否进行重置。</p>
</li>
<li><p>如果勾选：<code>Auto reset before per restart</code> ，重置是静默无感知的。</p>
</li>
<li><p>简单来说：勾选了<code>Auto reset before per restart</code>则无需再管，一劳永逸。</p>
</li>
</ul>
<h2 id="0x5-开源信息"><a href="#0x5-开源信息" class="headerlink" title="0x5. 开源信息"></a>0x5. 开源信息</h2><ul>
<li>插件是学习研究项目，源代码是开放的。源码仓库地址：<a href="https://gitee.com/pengzhile/ide-eval-resetter">Gitee</a>。</li>
<li>如果你有更好的想法，欢迎给我提<code>Pull Request</code>来共同研究完善。</li>
<li>插件源码使用：<code>GPL-2.0</code>开源协议发布。</li>
<li>插件使用<code>PHP</code>编写，毕竟<code>PHP</code>是世界上最好的编程语言！</li>
</ul>
<h2 id="0x6-支持的产品"><a href="#0x6-支持的产品" class="headerlink" title="0x6. 支持的产品"></a>0x6. 支持的产品</h2><ul>
<li><strong>IntelliJ IDEA</strong></li>
<li><strong>AppCode</strong></li>
<li><strong>CLion</strong></li>
<li><strong>DataGrip</strong></li>
<li><strong>GoLand</strong></li>
<li><strong>PhpStorm</strong></li>
<li><strong>PyCharm</strong></li>
<li><strong>Rider</strong></li>
<li><strong>RubyMine</strong></li>
<li><strong>WebStorm</strong></li>
</ul>
<p>本文转载自:<a href="https://zhile.io/2020/11/18/jetbrains-eval-reset-da33a93d.html">Jetbrains系列产品重置试用方法</a></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3笔记 --- Teleport</title>
    <url>/2021/08/19/Vue3%E7%AC%94%E8%AE%B0%20---%20Teleport/</url>
    <content><![CDATA[<p>Vue3之新特性Teleport,真香…</p>
<span id="more"></span>



<p>在<code>vue2.0</code>时代，我们经常会有这样的需求，写代码逻辑的时候希望将组件写在某个模板之下，因为这样我们很好的使用组件内部的状态数据，控制组件的展示形态。但是从技术的角度上我们又希望将这段代码移到<code>DOM</code>中<code>Vue app</code>之外的其他位置。</p>
<p>举个简单的例子，我们在使用<code>modal</code>组件的时候，我们将它放在了我们的模板<code>template</code>里面，但是由于<code>modal</code>组件希望位于页面的最上方，这时候我们将<code>modal</code>组件挂载在<code>body</code>上面是最好控制的，我们能够很好的通过<code>zIndex</code>来控制<code>modal</code>的位置，当他嵌套在<code>template</code>里面的时候就不那么容易了。</p>
<h4 id="Vue2中的实现"><a href="#Vue2中的实现" class="headerlink" title="Vue2中的实现"></a>Vue2中的实现</h4><p>​    <code>vue2.0</code>中我在写这个组件的时候是通过手动的形式来进行挂载的，我写了一个vue指令来进行这个操作，帮助我将<code>modal</code>组件挂载到<code>body</code>上面去，专这样也能够很好的通过控制<code>zIndex</code>来控制<code>modal</code>的展示。</p>
<pre><code class="javascript">function insert(el) &#123;
  const parent = el.parentNode;
  if (parent &amp;&amp; parent !== document.body) &#123;
      parent.removeChild(el);
      document.body.appendChild(el);
  &#125;
&#125;

export default (typeof window !== &#39;undefined&#39; ? &#123;
  inserted(el, &#123; value &#125;) &#123;
      if (value) &#123;
          insert(el);
      &#125;
  &#125;,
  componentUpdated(el, &#123; value &#125;) &#123;
      if (value) &#123;
          insert(el);
      &#125;
  &#125;,
&#125; : &#123;&#125;);
</code></pre>
<p>上面的代码其实就是简单的将<code>modal</code>从他原始挂载的父节点移除，然后挂载到<code>body</code>上去，通过手动的形式来重新挂载，能够很好的解决这种问题，当然上面只是简单的逻辑，如果需要考虑卸载等其他逻辑代码还得增加。</p>
<pre><code class="javascript">&lt;template&gt;
  &lt;div class=&quot;modal&quot; v-to-body=&quot;show&quot; v-if=&quot;show&quot;&gt;
    &lt;div class=&quot;modal-mask&quot; @click=&quot;close&quot;&gt;&lt;/div&gt;
    &lt;slot&gt;&lt;/slot&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import &quot;./style.scss&quot;;
import toBody from &quot;../directives/to-body&quot;;
export default &#123;
  props: &#123;
    show: Boolean,
  &#125;,
  directives: &#123;
    toBody,
  &#125;,
  methods: &#123;
    close() &#123;
      this.$emit(&quot;close&quot;);
    &#125;,
  &#125;,
&#125;;
&lt;/script&gt;
</code></pre>
<p>说实话<code>vue2.0</code>中的实现其实是没啥问题的，只是不是很优雅，需要额外的代码控制，所以<code>vue3.0</code>中直接带来了<code>Teleport-任意传送门</code></p>
<p>具体代码参考vue2.0-modal: <a href="https://codesandbox.io/s/vue20-modal-sc1rq">https://codesandbox.io/s/vue20-modal-sc1rq</a></p>
<h4 id="什么是Teleport"><a href="#什么是Teleport" class="headerlink" title="什么是Teleport"></a>什么是Teleport</h4><p><code>Teleport</code>能够直接帮助我们将组件渲染后页面中的任意地方，只要我们指定了渲染的目标对象。<code>Teleport</code>使用起来非常简单。</p>
<pre><code class="javascript">&lt;template&gt;
  &lt;teleport to=&quot;body&quot; class=&quot;modal&quot; v-if=&quot;show&quot;&gt;
    &lt;div class=&quot;modal-mask&quot; @click=&quot;close&quot;&gt;&lt;/div&gt;
    &lt;slot&gt;&lt;/slot&gt;
  &lt;/teleport&gt;
&lt;/template&gt;

&lt;script&gt;
import &quot;./style.scss&quot;;
export default &#123;
  props: &#123;
    show: Boolean,
  &#125;,
  methods: &#123;
    close() &#123;
      this.$emit(&quot;close&quot;);
    &#125;,
  &#125;,
&#125;;
&lt;/script&gt;
</code></pre>
<p>上面的代码我们就能够很简单的实现之前vue2.0所实现的功能。</p>
<p>具体代码参考vue3.0-modal: <a href="https://codesandbox.io/s/vue3-modal-x2lud">https://codesandbox.io/s/vue3-modal-x2lud</a></p>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a><strong>注意点</strong></h4><h5 id="与-Vue-components-一起使用"><a href="#与-Vue-components-一起使用" class="headerlink" title="与 Vue components 一起使用"></a>与 Vue components 一起使用</h5><p>在这种情况下，即使在不同的地方渲染<code>child-component</code>，它仍将是<code>parent-component</code>的子级，并将从中接收<code>name prop</code>。</p>
<p>这也意味着来自父组件的注入按预期工作，并且子组件将嵌套在<code>Vue Devtools</code>中的父组件之下，而不是放在实际内容移动到的位置。</p>
<pre><code class="javascript">const app = Vue.createApp(&#123;
  template: `
    &lt;h1&gt;Root instance&lt;/h1&gt;
    &lt;parent-component /&gt;
  `
&#125;)

app.component(&#39;parent-component&#39;, &#123;
  template: `
    &lt;h2&gt;This is a parent component&lt;/h2&gt;
    &lt;teleport to=&quot;#endofbody&quot;&gt;
      &lt;child-component name=&quot;John&quot; /&gt;
    &lt;/teleport&gt;
  `
&#125;)

app.component(&#39;child-component&#39;, &#123;
  props: [&#39;name&#39;],
  template: `
    &lt;div&gt;Hello, &#123;&#123; name &#125;&#125;&lt;/div&gt;
  `
&#125;)
</code></pre>
<h5 id="在同一目标上使用多个teleport"><a href="#在同一目标上使用多个teleport" class="headerlink" title="在同一目标上使用多个teleport"></a>在同一目标上使用多个teleport</h5><p>当我们将多个<code>teleport</code>送到同一位置时会发生什么？</p>
<pre><code class="javascript">&lt;teleport to=&quot;#modals&quot;&gt;
  &lt;div&gt;A&lt;/div&gt;
&lt;/teleport&gt;
&lt;teleport to=&quot;#modals&quot;&gt;
  &lt;div&gt;B&lt;/div&gt;
&lt;/teleport&gt;

&lt;!-- result--&gt;
&lt;div id=&quot;modals&quot;&gt;
  &lt;div&gt;A&lt;/div&gt;
  &lt;div&gt;B&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>我们可以看到对于这种情况，多个<code>teleport</code>组件可以将其内容挂载到同一个目标元素。顺序将是一个简单的追加——稍后挂载将位于目标元素中较早的挂载之后。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>一句话来描述<code>Teleport</code>就是一种将代码组织逻辑依旧放在组件中，这样我们能够使用组件内部的数据状态，控制组件展示的形式，但是最后渲染的地方可以是任意的，而不是局限于组件内部</p>
<p>- END -</p>
<p>点赞 + 在看 + 分享，一键三连，幸福满满！</p>
<p>本文分享自微信公众号 - 鱼头的Web海洋（krissarea）</p>
<p>原文出处及转载信息见文内详细说明，如有侵权，请联系 <a href="mailto:&#121;&#x75;&#110;&#x6a;&#105;&#97;&#95;&#99;&#x6f;&#109;&#x6d;&#117;&#x6e;&#105;&#116;&#121;&#64;&#x74;&#x65;&#x6e;&#x63;&#x65;&#x6e;&#x74;&#46;&#99;&#111;&#109;">&#121;&#x75;&#110;&#x6a;&#105;&#97;&#95;&#99;&#x6f;&#109;&#x6d;&#117;&#x6e;&#105;&#116;&#121;&#64;&#x74;&#x65;&#x6e;&#x63;&#x65;&#x6e;&#x74;&#46;&#99;&#111;&#109;</a> 删除。</p>
<p>原始发表时间：2021-07-05</p>
<p>本文参与<a href="https://cloud.tencent.com/developer/support-plan">腾讯云自媒体分享计划</a>，欢迎正在阅读的你也加入，一起分享。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3笔记 --- setup</title>
    <url>/2021/05/31/Vue3%E7%AC%94%E8%AE%B0%20---%20setup/</url>
    <content><![CDATA[<p>Composition API、setup…</p>
<span id="more"></span>

<h4 id="什么是Composition-API（组合API）"><a href="#什么是Composition-API（组合API）" class="headerlink" title="什么是Composition API（组合API）"></a>什么是Composition API（组合API）</h4><p>在vue3中提出了这样的一个概念，那到底什么是Composition API呢，让我们来看一下官方文档上是怎么介绍的…</p>
<p>通过创建 Vue 组件，我们可以将接口的可重复部分及其功能提取到可重用的代码段中。仅此一项就可以使我们的应用程序在可维护性和灵活性方面走得更远。然而，我们的经验已经证明，光靠这一点可能是不够的，尤其是当你的应用程序变得非常大的时候——想想几百个组件。在处理如此大的应用程序时，共享和重用代码变得尤为重要。</p>
<p>假设在我们的应用程序中，我们有一个视图来显示某个用户的仓库列表。除此之外，我们还希望应用搜索和筛选功能。处理此视图的组件可能如下所示：</p>
<pre><code class="js">// src/components/UserRepositories.vue

export default &#123;
  components: &#123; RepositoriesFilters, RepositoriesSortBy, RepositoriesList &#125;,
  props: &#123;
    user: &#123; type: String &#125;
  &#125;,
  data () &#123;
    return &#123;
      repositories: [], // 1
      filters: &#123; ... &#125;, // 3
      searchQuery: &#39;&#39; // 2
    &#125;
  &#125;,
  computed: &#123;
    filteredRepositories () &#123; ... &#125;, // 3
    repositoriesMatchingSearchQuery () &#123; ... &#125;, // 2
  &#125;,
  watch: &#123;
    user: &#39;getUserRepositories&#39; // 1
  &#125;,
  methods: &#123;
    getUserRepositories () &#123;
      // 使用 `this.user` 获取用户仓库
    &#125;, // 1
    updateFilters () &#123; ... &#125;, // 3
  &#125;,
  mounted () &#123;
    this.getUserRepositories() // 1
  &#125;
&#125;
</code></pre>
<p>该组件有以下几个职责：</p>
<ol>
<li>从假定的外部 API 获取该用户名的仓库，并在用户更改时刷新它</li>
<li>使用 <code>searchQuery</code> 字符串搜索存储库</li>
<li>使用 <code>filters</code> 对象筛选仓库</li>
</ol>
<p>用组件的选项 (<code>data</code>、<code>computed</code>、<code>methods</code>、<code>watch</code>) 组织逻辑在大多数情况下都有效。然而，当我们的组件变得更大时，<strong>逻辑关注点</strong>的列表也会增长。这可能会导致组件难以阅读和理解，尤其是对于那些一开始就没有编写这些组件的人来说。</p>
<p><img src="https://user-images.githubusercontent.com/499550/62783021-7ce24400-ba89-11e9-9dd3-36f4f6b1fae2.png" alt="Vue 选项式 API: 按选项类型分组的代码"></p>
<p>一个大型组件的示例，其中<strong>逻辑关注点</strong>是按颜色分组。</p>
<p>这种碎片化使得理解和维护复杂组件变得困难。选项的分离掩盖了潜在的逻辑问题。此外，在处理单个逻辑关注点时，我们必须不断地“跳转”相关代码的选项块。</p>
<p>如果我们能够将与同一个逻辑关注点相关的代码配置在一起会更好。而这正是组合式 API 使我们能够做到的。</p>
<h4 id="组合式-API-基础-–-setup"><a href="#组合式-API-基础-–-setup" class="headerlink" title="组合式 API 基础 – setup"></a>组合式 API 基础 – setup</h4><p>新的 <code>setup</code> 组件选项在<strong>创建组件之前</strong>执行，一旦 <code>props</code> 被解析，并充当合成 API 的入口点。</p>
<p><code>setup</code> 选项应该是一个接受 <code>props</code> 和 <code>context</code> 的函数，我们将在<a href="https://vue3js.cn/docs/zh/guide/composition-api-setup.html#%E5%8F%82%E6%95%B0">稍后</a>讨论。此外，我们从 <code>setup</code> 返回的所有内容都将暴露给组件的其余部分 (计算属性、方法、生命周期钩子等等) 以及组件的模板。</p>
<p>让我们添加 <code>setup</code> 到我们的组件中：</p>
<p>让我们添加 <code>setup</code> 到我们的组件中：</p>
<pre><code class="js">// src/components/UserRepositories.vue

export default &#123;
  components: &#123; RepositoriesFilters, RepositoriesSortBy, RepositoriesList &#125;,
  props: &#123;
    user: &#123; type: String &#125;
  &#125;,
  setup(props) &#123;
    console.log(props) // &#123; user: &#39;&#39; &#125;

    return &#123;&#125; // 这里返回的任何内容都可以用于组件的其余部分
  &#125;
  // 组件的“其余部分”
&#125;
</code></pre>
<p>现在让我们从提取第一个逻辑关注点开始 (在原始代码段中标记为“1”)。</p>
<blockquote>
<ol>
<li>从假定的外部 API 获取该用户名的仓库，并在用户更改时刷新它</li>
</ol>
</blockquote>
<p>我们将从最明显的部分开始：</p>
<ul>
<li>仓库列表</li>
<li>更新仓库列表的函数</li>
<li>返回列表和函数，以便其他组件选项可以访问它们</li>
</ul>
<pre><code class="js">// src/components/UserRepositories.vue `setup` function
import &#123; fetchUserRepositories &#125; from &#39;@/api/repositories&#39;

// 在我们的组件内
setup (props) &#123;
  let repositories = []
  const getUserRepositories = async () =&gt; &#123;
    repositories = await fetchUserRepositories(props.user)
  &#125;

  return &#123;
    repositories,
    getUserRepositories // 返回的函数与方法的行为相同
  &#125;
&#125;
</code></pre>
<p>这是我们的出发点，但它还不能工作，因为我们的 <code>repositories</code> 变量是非响应式的。这意味着从用户的角度来看，仓库列表将保持为空。我们来解决这个问题！</p>
<h3 id="带-ref-的响应式变量"><a href="#带-ref-的响应式变量" class="headerlink" title="#带 ref 的响应式变量"></a><a href="https://vue3js.cn/docs/zh/guide/composition-api-introduction.html#%E5%B8%A6-ref-%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8F%98%E9%87%8F">#</a>带 <code>ref</code> 的响应式变量</h3><p>在 Vue 3.0 中，我们可以通过一个新的 <code>ref</code> 函数使任何响应式变量在任何地方起作用，如下所示：</p>
<pre><code class="js">import &#123; ref &#125; from &#39;vue&#39;

const counter = ref(0)
</code></pre>
<p><code>ref</code> 接受参数并返回它包装在具有 <code>value</code> property 的对象中，然后可以使用该 property 访问或更改响应式变量的值：</p>
<pre><code class="js">import &#123; ref &#125; from &#39;vue&#39;

const counter = ref(0)

console.log(counter) // &#123; value: 0 &#125;
console.log(counter.value) // 0

counter.value++
console.log(counter.value) // 1
</code></pre>
<p>中包装值似乎不必要，但在 JavaScript 中保持不同数据类型的行为统一是必需的。这是因为在 JavaScript 中，<code>Number</code> 或 <code>String</code> 等基本类型是通过值传递的，而不是通过引用传递的：</p>
<p><img src="https://blog.penjee.com/wp-content/uploads/2015/02/pass-by-reference-vs-pass-by-value-animation.gif" alt="按引用传递与按值传递"></p>
<p>在任何值周围都有一个包装器对象，这样我们就可以在整个应用程序中安全地传递它，而不必担心在某个地方失去它的响应性。</p>
<p>提示</p>
<p>换句话说，<code>ref</code> 对我们的值创建了一个<strong>响应式引用</strong>。使用<strong>引用</strong>的概念将在整个组合式 API 中经常使用。</p>
<p>回到我们的例子，让我们创建一个响应式的 <code>repositories</code> 变量：</p>
<pre><code class="js">// src/components/UserRepositories.vue `setup` function
import &#123; fetchUserRepositories &#125; from &#39;@/api/repositories&#39;
import &#123; ref &#125; from &#39;vue&#39;

// in our component
setup (props) &#123;
  const repositories = ref([])
  const getUserRepositories = async () =&gt; &#123;
    repositories.value = await fetchUserRepositories(props.user)
  &#125;

  return &#123;
    repositories,
    getUserRepositories
  &#125;
&#125;
</code></pre>
<p>完成！现在，每当我们调用 <code>getUserRepositories</code> 时，<code>repositories</code> 都将发生变化，视图将更新以反映更改。我们的组件现在应该如下所示：</p>
<pre><code class="js">// src/components/UserRepositories.vue
import &#123; fetchUserRepositories &#125; from &#39;@/api/repositories&#39;
import &#123; ref &#125; from &#39;vue&#39;

export default &#123;
  components: &#123; RepositoriesFilters, RepositoriesSortBy, RepositoriesList &#125;,
  props: &#123;
    user: &#123; type: String &#125;
  &#125;,
  setup (props) &#123;
    const repositories = ref([])
    const getUserRepositories = async () =&gt; &#123;
      repositories.value = await fetchUserRepositories(props.user)
    &#125;

    return &#123;
      repositories,
      getUserRepositories
    &#125;
  &#125;,
  data () &#123;
    return &#123;
      filters: &#123; ... &#125;, // 3
      searchQuery: &#39;&#39; // 2
    &#125;
  &#125;,
  computed: &#123;
    filteredRepositories () &#123; ... &#125;, // 3
    repositoriesMatchingSearchQuery () &#123; ... &#125;, // 2
  &#125;,
  watch: &#123;
    user: &#39;getUserRepositories&#39; // 1
  &#125;,
  methods: &#123;
    updateFilters () &#123; ... &#125;, // 3
  &#125;,
  mounted () &#123;
    this.getUserRepositories() // 1
  &#125;
&#125;
</code></pre>
<p>我们已经将第一个逻辑关注点中的几个部分移到了 <code>setup</code> 方法中，它们彼此非常接近。剩下的就是在 <code>mounted</code> 钩子中调用 <code>getUserRepositories</code>，并设置一个监听器，以便在 <code>user</code> prop 发生变化时执行此操作。</p>
<p>我们将从生命周期钩子开始。</p>
<h4 id="生命周期钩子注册内部-setup"><a href="#生命周期钩子注册内部-setup" class="headerlink" title="生命周期钩子注册内部 setup"></a>生命周期钩子注册内部 <code>setup</code></h4><p>为了让composition-api更加完善（相比于options-api），还可以在setup里注册生命周期函数，需要从Vue中导出几个函数，代码如下</p>
<pre><code class="js">// src/components/UserRepositories.vue `setup` function
import &#123; fetchUserRepositories &#125; from &#39;@/api/repositories&#39;
import &#123; ref, onMounted &#125; from &#39;vue&#39;

// in our component
setup (props) &#123;
  const repositories = ref([])
  const getUserRepositories = async () =&gt; &#123;
    repositories.value = await fetchUserRepositories(props.user)
  &#125;

  onMounted(getUserRepositories) // on `mounted` call `getUserRepositories`

  return &#123;
    repositories,
    getUserRepositories
  &#125;
&#125;
</code></pre>
<p>还可以在setup里引入watch</p>
<h4 id="watch-响应式更改（新的composition-api，区别于原来的options-api的使用方法）"><a href="#watch-响应式更改（新的composition-api，区别于原来的options-api的使用方法）" class="headerlink" title="watch 响应式更改（新的composition-api，区别于原来的options-api的使用方法）"></a><code>watch</code> 响应式更改（新的composition-api，区别于原来的options-api的使用方法）</h4><p>它接受 3 个参数：</p>
<ul>
<li>一个<strong>响应式引用</strong>或我们想要侦听的 getter 函数</li>
<li>一个回调</li>
<li>可选的配置选项</li>
</ul>
<p>代码如下</p>
<pre><code class="js">import &#123; ref, watch &#125; from &#39;vue&#39;

const counter = ref(0)
watch(counter, (newValue, oldValue) =&gt; &#123;
  console.log(&#39;The new counter value is: &#39; + counter.value)
&#125;)
</code></pre>
<p><strong>现在我们将其放在我们上面的demo代码中使用</strong></p>
<pre><code class="js">// src/components/UserRepositories.vue `setup` function
import &#123; fetchUserRepositories &#125; from &#39;@/api/repositories&#39;
import &#123; ref, onMounted, watch, toRefs &#125; from &#39;vue&#39;

// 在我们组件中
setup (props) &#123;
  // 使用 `toRefs` 创建对prop的 `user` property 的响应式引用
  const &#123; user &#125; = toRefs(props)

  const repositories = ref([])
  const getUserRepositories = async () =&gt; &#123;
    // 更新 `prop.user` 到 `user.value` 访问引用值
    repositories.value = await fetchUserRepositories(user.value)
  &#125;

  onMounted(getUserRepositories)

  // 在用户 prop 的响应式引用上设置一个侦听器
  watch(user, getUserRepositories)

  return &#123;
    repositories,
    getUserRepositories
  &#125;
&#125;
</code></pre>
<p><strong><code>你可能已经注意到在我们的 setup 的顶部使用了 toRefs。这是为了确保我们的侦听器能够对 user prop 所做的更改做出反应。</code></strong></p>
<p>有了这些变化，我们就把第一个逻辑关注点移到了一个地方。我们现在可以对第二个关注点执行相同的操作——基于 <code>searchQuery</code> 进行过滤，这次是使用计算属性。</p>
<h4 id="独立的-computed-属性"><a href="#独立的-computed-属性" class="headerlink" title="#独立的 computed 属性"></a><a href="https://vue3js.cn/docs/zh/guide/composition-api-introduction.html#%E7%8B%AC%E7%AB%8B%E7%9A%84-computed-%E5%B1%9E%E6%80%A7">#</a>独立的 <code>computed</code> 属性</h4><p>与 <code>ref</code> 和 <code>watch</code> 类似，也可以使用从 Vue 导入的 <code>computed</code> 函数在 Vue 组件外部创建计算属性。让我们回到我们的 counter 例子：</p>
<pre><code class="js">import &#123; ref, computed &#125; from &#39;vue&#39;

const counter = ref(0)
const twiceTheCounter = computed(() =&gt; counter.value * 2)

counter.value++
console.log(counter.value) // 1
console.log(twiceTheCounter.value) // 2
</code></pre>
<p>放到上面的完整demo中</p>
<pre><code class="js">// src/components/UserRepositories.vue `setup` function
import &#123; fetchUserRepositories &#125; from &#39;@/api/repositories&#39;
import &#123; ref, onMounted, watch, toRefs, computed &#125; from &#39;vue&#39;

// in our component
setup (props) &#123;
  // 使用 `toRefs` 创建对 props 的 `user` property 的响应式引用
  const &#123; user &#125; = toRefs(props)

  const repositories = ref([])
  const getUserRepositories = async () =&gt; &#123;
    // 更新 `props.user ` 到 `user.value` 访问引用值
    repositories.value = await fetchUserRepositories(user.value)
  &#125;

  onMounted(getUserRepositories)

  // 在用户 prop 的响应式引用上设置一个侦听器
  watch(user, getUserRepositories)

  const searchQuery = ref(&#39;&#39;)
  const repositoriesMatchingSearchQuery = computed(() =&gt; &#123;
    return repositories.value.filter(
      repository =&gt; repository.name.includes(searchQuery.value)
    )
  &#125;)

  return &#123;
    repositories,
    getUserRepositories,
    searchQuery,
    repositoriesMatchingSearchQuery
  &#125;
&#125;
</code></pre>
<p>对于其他的<strong>逻辑关注点</strong>我们也可以这样做，但是你可能已经在问这个问题了——<em>这不就是把代码移到 <code>setup</code> 选项并使它变得非常大吗</em>？嗯，那是真的。这就是为什么在继续其他任务之前，我们将首先将上述代码提取到一个独立的<strong>组合式函数</strong>。让我们从创建 <code>useUserRepositories</code> 开始：</p>
<pre><code class="js">// src/composables/useUserRepositories.js

import &#123; fetchUserRepositories &#125; from &#39;@/api/repositories&#39;
import &#123; ref, onMounted, watch &#125; from &#39;vue&#39;

export default function useUserRepositories(user) &#123;
  const repositories = ref([])
  const getUserRepositories = async () =&gt; &#123;
    repositories.value = await fetchUserRepositories(user.value)
  &#125;

  onMounted(getUserRepositories)
  watch(user, getUserRepositories)

  return &#123;
    repositories,
    getUserRepositories
  &#125;
&#125;
</code></pre>
<p>然后是搜索功能：</p>
<pre><code class="js">// src/composables/useRepositoryNameSearch.js

import &#123; ref, computed &#125; from &#39;vue&#39;

export default function useRepositoryNameSearch(repositories) &#123;
  const searchQuery = ref(&#39;&#39;)
  const repositoriesMatchingSearchQuery = computed(() =&gt; &#123;
    return repositories.value.filter(repository =&gt; &#123;
      return repository.name.includes(searchQuery.value)
    &#125;)
  &#125;)

  return &#123;
    searchQuery,
    repositoriesMatchingSearchQuery
  &#125;
&#125;
</code></pre>
<p><strong>现在在单独的文件中有了这两个功能，我们就可以开始在组件中使用它们了。以下是如何做到这一点：</strong></p>
<pre><code class="js">// src/components/UserRepositories.vue
import useUserRepositories from &#39;@/composables/useUserRepositories&#39;
import useRepositoryNameSearch from &#39;@/composables/useRepositoryNameSearch&#39;
import &#123; toRefs &#125; from &#39;vue&#39;

export default &#123;
  components: &#123; RepositoriesFilters, RepositoriesSortBy, RepositoriesList &#125;,
  props: &#123;
    user: &#123; type: String &#125;
  &#125;,
  setup (props) &#123;
    const &#123; user &#125; = toRefs(props)

    const &#123; repositories, getUserRepositories &#125; = useUserRepositories(user)

    const &#123;
      searchQuery,
      repositoriesMatchingSearchQuery
    &#125; = useRepositoryNameSearch(repositories)

    return &#123;
      // 因为我们并不关心未经过滤的仓库
      // 我们可以在 `repositories` 名称下暴露过滤后的结果
      repositories: repositoriesMatchingSearchQuery,
      getUserRepositories,
      searchQuery,
    &#125;
  &#125;,
  data () &#123;
    return &#123;
      filters: &#123; ... &#125;, // 3
    &#125;
  &#125;,
  computed: &#123;
    filteredRepositories () &#123; ... &#125;, // 3
  &#125;,
  methods: &#123;
    updateFilters () &#123; ... &#125;, // 3
  &#125;
&#125;
</code></pre>
<p>此时，你可能已经知道了这个练习，所以让我们跳到最后，迁移剩余的过滤功能。</p>
<pre><code class="js">// src/components/UserRepositories.vue
import &#123; toRefs &#125; from &#39;vue&#39;
import useUserRepositories from &#39;@/composables/useUserRepositories&#39;
import useRepositoryNameSearch from &#39;@/composables/useRepositoryNameSearch&#39;
import useRepositoryFilters from &#39;@/composables/useRepositoryFilters&#39;

export default &#123;
  components: &#123; RepositoriesFilters, RepositoriesSortBy, RepositoriesList &#125;,
  props: &#123;
    user: &#123; type: String &#125;
  &#125;,
  setup(props) &#123;
    const &#123; user &#125; = toRefs(props)

    const &#123; repositories, getUserRepositories &#125; = useUserRepositories(user)

    const &#123;
      searchQuery,
      repositoriesMatchingSearchQuery
    &#125; = useRepositoryNameSearch(repositories)

    const &#123;
      filters,
      updateFilters,
      filteredRepositories
    &#125; = useRepositoryFilters(repositoriesMatchingSearchQuery)

    return &#123;
      // 因为我们并不关心未经过滤的仓库
      // 我们可以在 `repositories` 名称下暴露过滤后的结果
      repositories: filteredRepositories,
      getUserRepositories,
      searchQuery,
      filters,
      updateFilters
    &#125;
  &#125;
&#125;
</code></pre>
<h1 id="Setup"><a href="#Setup" class="headerlink" title="Setup"></a>Setup</h1><blockquote>
<p>本节使用<a href="https://vue3js.cn/docs/zh/guide/single-file-component.html">单文件组件</a>代码示例的语法</p>
</blockquote>
<blockquote>
<p>本指南假定你已经阅读了<a href="https://vue3js.cn/docs/zh/guide/composition-api-introduction.html">组合式 API 简介</a>和<a href="https://vue3js.cn/docs/zh/guide/reactivity-fundamentals.html">响应性原理</a>。如果你不熟悉组合式 API，请先阅读这篇文章。</p>
</blockquote>
<h2 id="参数"><a href="#参数" class="headerlink" title="#参数"></a><a href="https://vue3js.cn/docs/zh/guide/composition-api-setup.html#%E5%8F%82%E6%95%B0">#</a>参数</h2><p>使用 <code>setup</code> 函数时，它将接受两个参数：</p>
<ol>
<li><code>props</code></li>
<li><code>context</code></li>
</ol>
<p>让我们更深入地研究如何使用每个参数。</p>
<h3 id="Props"><a href="#Props" class="headerlink" title="#Props"></a><a href="https://vue3js.cn/docs/zh/guide/composition-api-setup.html#props">#</a>Props</h3><p><code>setup</code> 函数中的第一个参数是 <code>props</code>。正如在一个标准组件中所期望的那样，<code>setup</code> 函数中的 <code>props</code> 是响应式的，当传入新的 prop 时，它将被更新。</p>
<pre><code class="js">// MyBook.vue

export default &#123;
  props: &#123;
    title: String
  &#125;,
  setup(props) &#123;
    console.log(props.title)
  &#125;
&#125;
</code></pre>
<p>WARNING</p>
<p>但是，因为 <code>props</code> 是响应式的，你<strong>不能使用 ES6 解构</strong>，因为它会消除 prop 的响应性。</p>
<p>如果需要解构 prop，可以通过使用 <code>setup</code> 函数中的 <a href="https://vue3js.cn/docs/zh/guide/reactivity-fundamentals.html#%E5%93%8D%E5%BA%94%E5%BC%8F%E7%8A%B6%E6%80%81%E8%A7%A3%E6%9E%84"><code>toRefs</code></a> 来安全地完成此操作。</p>
<pre><code class="js">// MyBook.vue

import &#123; toRefs &#125; from &#39;vue&#39;

setup(props) &#123;
    const &#123; title &#125; = toRefs(props)

    console.log(title.value)
&#125;
</code></pre>
<h3 id="上下文"><a href="#上下文" class="headerlink" title="#上下文"></a><a href="https://vue3js.cn/docs/zh/guide/composition-api-setup.html#%E4%B8%8A%E4%B8%8B%E6%96%87">#</a>上下文</h3><p>传递给 <code>setup</code> 函数的第二个参数是 <code>context</code>。<code>context</code> 是一个普通的 JavaScript 对象，它暴露三个组件的 property：</p>
<pre><code class="js">// MyBook.vue

export default &#123;
  setup(props, context) &#123;
    // Attribute (非响应式对象)
    console.log(context.attrs)

    // 插槽 (非响应式对象)
    console.log(context.slots)

    // 触发事件 (方法)
    console.log(context.emit)
  &#125;
&#125;
</code></pre>
<p><code>context</code> 是一个普通的 JavaScript 对象，也就是说，它不是响应式的，这意味着你可以安全地对 <code>context</code> 使用 ES6 解构。</p>
<pre><code class="js">// MyBook.vue
export default &#123;
  setup(props, &#123; attrs, slots, emit &#125;) &#123;
    ...
  &#125;
&#125;
</code></pre>
<p><code>attrs</code> 和 <code>slots</code> 是有状态的对象，它们总是会随组件本身的更新而更新。这意味着你应该避免对它们进行解构，并始终以 <code>attrs.x</code> 或 <code>slots.x</code> 的方式引用 property。请注意，与 <code>props</code> 不同，<code>attrs</code> 和 <code>slots</code> 是<strong>非</strong>响应式的。如果你打算根据 <code>attrs</code> 或 <code>slots</code> 更改应用副作用，那么应该在 <code>onUpdated</code> 生命周期钩子中执行此操作。</p>
<h2 id="访问组件的-property"><a href="#访问组件的-property" class="headerlink" title="#访问组件的 property"></a><a href="https://vue3js.cn/docs/zh/guide/composition-api-setup.html#%E8%AE%BF%E9%97%AE%E7%BB%84%E4%BB%B6%E7%9A%84-property">#</a>访问组件的 property</h2><p>执行 <code>setup</code> 时，组件实例尚未被创建。因此，你只能访问以下 property：</p>
<ul>
<li><code>props</code></li>
<li><code>attrs</code></li>
<li><code>slots</code></li>
<li><code>emit</code></li>
</ul>
<p>换句话说，你<strong>将无法访问</strong>以下组件选项：</p>
<ul>
<li><code>data</code></li>
<li><code>computed</code></li>
<li><code>methods</code></li>
</ul>
<h2 id="结合模板使用"><a href="#结合模板使用" class="headerlink" title="#结合模板使用"></a><a href="https://vue3js.cn/docs/zh/guide/composition-api-setup.html#%E7%BB%93%E5%90%88%E6%A8%A1%E6%9D%BF%E4%BD%BF%E7%94%A8">#</a>结合模板使用</h2><p>如果 <code>setup</code> 返回一个对象，则可以在组件的模板中像传递给 <code>setup</code> 的 <code>props</code> property 一样访问该对象的 property：</p>
<pre><code class="javascript">&lt;!-- MyBook.vue --&gt;
&lt;template&gt;
  &lt;div&gt;&#123;&#123; readersNumber &#125;&#125; &#123;&#123; book.title &#125;&#125;&lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
  import &#123; ref, reactive &#125; from &#39;vue&#39;

  export default &#123;
    setup() &#123;
      const readersNumber = ref(0)
      const book = reactive(&#123; title: &#39;Vue 3 Guide&#39; &#125;)

      // expose to template
      return &#123;
        readersNumber,
        book
      &#125;
    &#125;
  &#125;
&lt;/script&gt;
</code></pre>
<p>注意，从 <code>setup</code> 返回的 <a href="https://vue3js.cn/docs/zh/api/refs-api.html#ref">refs</a> 在模板中访问时是<a href="https://vue3js.cn/docs/zh/guide/reactivity-fundamentals.html#ref-%E8%A7%A3%E5%BC%80">被自动解开</a>的，因此不应在模板中使用 <code>.value</code>。</p>
<h2 id="使用渲染函数"><a href="#使用渲染函数" class="headerlink" title="#使用渲染函数"></a><a href="https://vue3js.cn/docs/zh/guide/composition-api-setup.html#%E4%BD%BF%E7%94%A8%E6%B8%B2%E6%9F%93%E5%87%BD%E6%95%B0">#</a>使用渲染函数</h2><p><code>setup</code> 还可以返回一个渲染函数，该函数可以直接使用在同一作用域中声明的响应式状态：</p>
<pre><code class="js">// MyBook.vue

import &#123; h, ref, reactive &#125; from &#39;vue&#39;

export default &#123;
  setup() &#123;
    const readersNumber = ref(0)
    const book = reactive(&#123; title: &#39;Vue 3 Guide&#39; &#125;)
    // Please note that we need to explicitly expose ref value here
    return () =&gt; h(&#39;div&#39;, [readersNumber.value, book.title])
  &#125;
&#125;
</code></pre>
<h2 id="使用-this"><a href="#使用-this" class="headerlink" title="#使用 this"></a><a href="https://vue3js.cn/docs/zh/guide/composition-api-setup.html#%E4%BD%BF%E7%94%A8-this">#</a>使用 <code>this</code></h2><p><strong>在 <code>setup()</code> 内部，<code>this</code> 不会是该活跃实例的引用</strong>，因为 <code>setup()</code> 是在解析其它组件选项之前被调用的，所以 <code>setup()</code> 内部的 <code>this</code> 的行为与其它选项中的 <code>this</code> 完全不同。这在和其它选项式 API 一起使用 <code>setup()</code> 时可能会导致混淆。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3笔记 --- 代码复用示例</title>
    <url>/2021/06/15/Vue3%E7%AC%94%E8%AE%B0%20---%20%E4%BB%A3%E7%A0%81%E5%A4%8D%E7%94%A8%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<p>记录整理Vue3代码的复用示例…</p>
<span id="more"></span>
<pre><code class="vue">&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;组合式api架构&lt;/h1&gt;
    &lt;h2&gt;usemouse&lt;/h2&gt;
    &lt;p&gt;position x: &#123;&#123;x&#125;&#125;&lt;/p&gt;
    &lt;p&gt;position y: &#123;&#123;y&#125;&#125;&lt;/p&gt;
    &lt;h2&gt;useCount&lt;/h2&gt;
    &lt;p&gt;&#123;&#123;count&#125;&#125;&lt;/p&gt;
    &lt;button @click=&quot;add&quot;&gt;Add&lt;/button&gt;
    &lt;button @click=&quot;minus&quot;&gt;Minus&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import &#123; onMounted, onUnmounted, ref &#125; from &quot;vue&quot;;
export default &#123;
  name: &quot;CompositionApiArchitecture&quot;,
  setup() &#123;
    const &#123; x, y &#125; = useMouse();
    const &#123; count, add, minus &#125; = useCount();
    return &#123; x, y, count, add, minus &#125;;
  &#125;,
&#125;;
  
function useMouse() &#123;
  const x = ref(0);
  const y = ref(0);
  const updateXY = (e) =&gt; &#123;
    x.value = e.x;
    y.value = e.y;
  &#125;;
  onMounted(() =&gt; &#123;
    document.addEventListener(&quot;mousemove&quot;, updateXY);
  &#125;);
  onUnmounted(() =&gt; &#123;
    document.removeEventListener(&quot;mousemove&quot;, updateXY);
  &#125;);
  return &#123; x, y &#125;;
&#125;
  
function useCount() &#123;
  const count = ref(0);
  const add = () =&gt; count.value++;
  const minus = () =&gt; count.value--;
  return &#123; count, add, minus &#125;;
&#125;
&lt;/script&gt;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210615133627881.png" alt="image-20210615133627881"></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3笔记 --- 响应性基础API</title>
    <url>/2021/06/03/Vue3%E7%AC%94%E8%AE%B0%20---%20%E5%93%8D%E5%BA%94%E6%80%A7%E5%9F%BA%E7%A1%80%20API/</url>
    <content><![CDATA[<p>记录整理Vue3的响应性API…</p>
<span id="more"></span>
<h4 id="响应性基础-API"><a href="#响应性基础-API" class="headerlink" title="响应性基础 API"></a>响应性基础 API</h4><p>Vue3 提供了两种方式构建响应式数据：ref 和 reactive<br>ref 用于构建简单值的响应式数据，基于 Object.defineProperty 监听 value 值<br>reactive 用于构建复杂的响应式数据，基于 Proxy 对数据进行深度监听</p>
<h5 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h5><p>接受一个内部值并返回一个响应式且可变的 ref 对象。ref 对象具有指向内部值的单个 property <code>.value</code>。</p>
<p>有时我们可能需要为 ref 的内部值指定复杂类型。我们可以通过在调用 <code>ref</code> 来覆盖默认推断时传递一个泛型参数来简洁地做到这一点：</p>
<pre><code class="ts">const foo = ref&lt;string | number&gt;(&#39;foo&#39;) // foo&#39;s type: Ref&lt;string | number&gt;

foo.value = 123 // ok!
</code></pre>
<p>如果泛型的类型未知，建议将 <code>ref</code> 转换为 <code>Ref&lt;T&gt;</code>：</p>
<pre><code class="js">function useState&lt;State extends string&gt;(initial: State) &#123;
  const state = ref(initial) as Ref&lt;State&gt; // state.value -&gt; State extends string
  return state
&#125;
</code></pre>
<h5 id="toRef"><a href="#toRef" class="headerlink" title="toRef"></a>toRef</h5><p>可以用来为源响应式对象上的 property 性创建一个 <a href="https://vue3js.cn/docs/zh/api/refs-api.html#ref"><code>ref</code></a>。然后可以将 ref 传递出去，从而保持对其源 property 的响应式连接。接收两个参数：源响应式对象和属性名，返回一个ref数据。例如使用父组件传递的props数据时，要引用props的某个属性且要保持响应式连接时就很有用。<code>详细示例在文章结尾的代码块</code></p>
<ul>
<li>获取数据值的时候需要加.value</li>
<li><code>toRef后的ref数据不是原始数据的拷贝，而是引用，改变结果数据的值也会同时改变原始数据</code></li>
</ul>
<pre><code class="js">import &#123; defineComponent, toRef &#125; from &#39;vue&#39;

export default defineComponent(&#123;
  props: [title],
  
  setup (props) &#123;
    // 创建变量myTitle
    const myTitle = toRef(props, &#39;title&#39;)
    console.log(myTitle.value)
  &#125;
&#125;)
</code></pre>
<h5 id="toRefs"><a href="#toRefs" class="headerlink" title="toRefs"></a>toRefs</h5><p>将响应式对象转换为普通对象，其中结果对象的每个 property 都是指向原始对象相应 property 的<a href="https://vue3js.cn/docs/zh/api/refs-api.html#ref"><code>ref</code></a>。</p>
<pre><code class="vuejs">&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;解构响应式对象数据&lt;/h1&gt;
    &lt;p&gt;Username: &#123;&#123;username&#125;&#125;&lt;/p&gt;
    &lt;p&gt;Age: &#123;&#123;age&#125;&#125;&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import &#123; reactive, toRefs &#125; from &quot;vue&quot;;

export default &#123;
  name: &quot;DestructReactiveObject&quot;,
  setup() &#123;
    const user = reactive(&#123;
      username: &quot;haihong&quot;,
      age: 10000,
    &#125;);

    return &#123; ...toRefs(user) &#125;;
  &#125;,
&#125;;
&lt;/script&gt;
</code></pre>
<p>当想要从一个组合逻辑函数中返回响应式对象时，用 toRefs 是很有效的，该 API 让消费组件可以 解构 / 扩展（使用 … 操作符）返回的对象，并不会丢失响应性：</p>
<pre><code class="js">function useFeatureX() &#123;
  const state = reactive(&#123;
    foo: 1,
    bar: 2,
  &#125;)

  // 对 state 的逻辑操作
  // ....

  // 返回时将属性都转为 ref
  return toRefs(state)
&#125;

export default &#123;
  setup() &#123;
    // 可以解构，不会丢失响应性
    const &#123; foo, bar &#125; = useFeatureX()

    return &#123;
      foo,
      bar,
    &#125;
  &#125;,
&#125;
</code></pre>
<h5 id="readonly-–-深层”的只读-代理"><a href="#readonly-–-深层”的只读-代理" class="headerlink" title="readonly – 深层”的只读**代理"></a>readonly – 深层”的只读**代理</h5><p>传入一个对象（响应式或普通）或 ref，返回一个原始对象的只读代理。一个只读的代理是“深层的”，对象内部任何嵌套的属性也都是只读的。</p>
<pre><code class="vuejs">&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;readonly - “深层”的只读代理&lt;/h1&gt;
    &lt;p&gt;original.count: &#123;&#123;original.count&#125;&#125;&lt;/p&gt;
    &lt;p&gt;copy.count: &#123;&#123;copy.count&#125;&#125;&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import &#123; reactive, readonly &#125; from &quot;vue&quot;;

export default &#123;
  name: &quot;Readonly&quot;,
  setup() &#123;
    const original = reactive(&#123; count: 0 &#125;);
    const copy = readonly(original);

    setInterval(() =&gt; &#123;
      original.count++;
      copy.count++; // 报警告，Set operation on key &quot;count&quot; failed: target is readonly. Proxy &#123;count: 1&#125;
    &#125;, 1000);


    return &#123; original, copy &#125;;
  &#125;,
&#125;;
&lt;/script&gt;
</code></pre>
<h5 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h5><p>返回对象的响应式副本,完整示例如下</p>
<pre><code class="vuejs">&lt;template&gt;
  &lt;div class=&quot;about&quot;&gt;
    &lt;button @click.stop=&quot;obj.increase&quot;&gt;increase&lt;/button&gt;

    &lt;button @click.stop=&quot;reverse&quot;&gt;reverse&lt;/button&gt;

    &lt;h1&gt;&#123;&#123; obj.count &#125;&#125;&lt;/h1&gt;

    &lt;h1&gt;&#123;&#123; obj.double &#125;&#125;&lt;/h1&gt;

    &lt;h1&gt;&#123;&#123; obj.title &#125;&#125;&lt;/h1&gt;

    --------------------

    &lt;h1&gt;&#123;&#123; count &#125;&#125;&lt;/h1&gt;

    &lt;h1&gt;&#123;&#123; double &#125;&#125;&lt;/h1&gt;

    &lt;h1&gt;&#123;&#123; title &#125;&#125;&lt;/h1&gt;

    &lt;componentA :count=&quot;obj.count&quot;/&gt;
  &lt;/div&gt;
&lt;/template&gt;


&lt;script lang=&quot;ts&quot;&gt;

  import &#123;reactive, ref, computed, toRefs &#125; from &quot;vue&quot;;

  import componentA from &quot;./components/componentA.vue&quot;;

  interface ObjProps &#123;
    title: string;
    count: number;
    double: number;
    reverse: () =&gt; void;
    increase: () =&gt; void;
  &#125;

  export default &#123;
    components: &#123;componentA&#125;,
    setup(props: any) &#123;
      // ref返回普通数据类型的响应式副本
      const count = ref(0);
      // reactive返回对象的响应式副本
      const obj: ObjProps = reactive(&#123;
        title: &quot;hello world&quot;,
        count: 0,
        double: computed(() =&gt; obj.count * 2),
        reverse: () =&gt; &#123;
          obj.title = obj.title.split(&quot;&quot;).reverse().join(&quot;&quot;);
        &#125;,
        increase: () =&gt; &#123;
          obj.count++;
        &#125;,
      &#125;);
      const count = toRef(obj, &#39;count&#39;)
      const objToRefs = toRefs(obj)
      return &#123;
        obj,
        title: objToRefs.title,
        count: objToRefs.count,
        double: objToRefs.double,
        reverse: objToRefs.reverse,
        increase: objToRefs.increase
      &#125;;
    &#125;,
  &#125;;
&lt;/script&gt;
</code></pre>
<h5 id="watchEffect"><a href="#watchEffect" class="headerlink" title="watchEffect"></a>watchEffect</h5><p>立即执行传入的一个函数，并响应式追踪其依赖，并在其依赖变更时重新运行该函数。</p>
<pre><code class="vuejs">&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;watchEffect - 侦听器&lt;/h1&gt;
    &lt;p&gt;&#123;&#123;data.count&#125;&#125;&lt;/p&gt;
    &lt;button @click=&quot;stop&quot;&gt;手动关闭侦听器&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import &#123; reactive, watchEffect &#125; from &quot;vue&quot;;
export default &#123;
  name: &quot;WatchEffect&quot;,
  setup() &#123;
    const data = reactive(&#123; count: 1 &#125;);
    const stop = watchEffect(() =&gt; console.log(`侦听器：$&#123;data.count&#125;`));
    setInterval(() =&gt; &#123;
      data.count++;
    &#125;, 1000);
    return &#123; data, stop &#125;;
  &#125;,
&#125;;
&lt;/script&gt;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210603154819179.png" alt="image-20210603154819179"></p>
<h5 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h5><p>对比<code>watchEffect</code>，<code>watch</code>允许我们：</p>
<ul>
<li>懒执行副作用，也就是说仅在侦听的源变更时才执行回调；</li>
<li><code>更明确哪些状态的改变会触发侦听器重新运行副作用；</code></li>
<li>访问侦听状态变化前后的值。</li>
</ul>
<pre><code class="vuejs">&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;watch - 侦听器&lt;/h1&gt;
    &lt;p&gt;count1: &#123;&#123;data.count1&#125;&#125;&lt;/p&gt;
    &lt;p&gt;count2: &#123;&#123;data.count2&#125;&#125;&lt;/p&gt;
    &lt;button @click=&quot;stopAll&quot;&gt;Stop All&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import &#123; reactive, watch &#125; from &quot;vue&quot;;
export default &#123;
  name: &quot;Watch&quot;,
  setup() &#123;
    const data = reactive(&#123; count1: 0, count2: 0 &#125;);
    // 侦听单个数据源
    const stop1 = watch(data, () =&gt;
      console.log(&quot;watch1&quot;, data.count1, data.count2)
    );
    // 侦听多个数据源
    const stop2 = watch([data], () =&gt; &#123;
      console.log(&quot;watch2&quot;, data.count1, data.count2);
    &#125;);
    setInterval(() =&gt; &#123;
      data.count1++;
    &#125;, 1000);
    return &#123;
      data,
      stopAll: () =&gt; &#123;
        stop1();
        stop2();
      &#125;,
    &#125;;
  &#125;,
&#125;;
&lt;/script&gt;
</code></pre>
<h5 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h5><p>返回一个默认不可手动修改的 ref 对象。</p>
<ul>
<li><h6 id="只传-getter"><a href="#只传-getter" class="headerlink" title="只传 getter"></a>只传 getter</h6></li>
</ul>
<pre><code class="vuejs">&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;computed - 计算属性&lt;/h1&gt;
    &lt;p&gt;&#123;&#123;username&#125;&#125;&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import &#123; reactive, computed &#125; from &quot;vue&quot;;
export default &#123;
  name: &quot;Computed&quot;,
  setup() &#123;
    const user = reactive(&#123; firstname: &quot;chen&quot;, lastname: &quot;haihong&quot; &#125;);
    const username = computed(() =&gt; user.firstname + &quot; &quot; + user.lastname);
    username.value = &quot;hello world&quot;; // 报警告，computed value is readonly
    return &#123; username &#125;;
  &#125;,
&#125;;
&lt;/script&gt;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210603141847906.png" alt="image-20210603141847906"></p>
<p>如果是这种使用方式，则会报错 ❌，而不是警告 ⚠️，</p>
<pre><code class="javascript"> setup() &#123;
    const user = reactive(&#123; firstname: &quot;chen&quot;, lastname: &quot;haihong&quot; &#125;);
    const username = computed(&#123;
      get: () =&gt; user.firstname + &quot; &quot; + user.lastname,
    &#125;);
    username.value = &quot;hello world&quot;; // ❌ computed value is readonly
    return &#123; username &#125;;
  &#125;,
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210603142037622.png" alt="image-20210603142037622"></p>
<ul>
<li><h6 id="同时传-getter、setter"><a href="#同时传-getter、setter" class="headerlink" title="同时传 getter、setter"></a>同时传 getter、setter</h6><p>创建一个可手动修改的计算状态。</p>
</li>
</ul>
<pre><code class="vuejs">&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;computed - 计算属性&lt;/h1&gt;
    &lt;p&gt;firstname: &lt;input v-model=&quot;user.firstname&quot; /&gt;&lt;/p&gt;
    &lt;p&gt;lastname: &lt;input v-model=&quot;user.lastname&quot; /&gt;&lt;/p&gt;
    &lt;p&gt;username: &lt;input v-model=&quot;username&quot; /&gt;&lt;/p&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import &#123; reactive, computed &#125; from &quot;vue&quot;;
export default &#123;
  name: &quot;Computed2&quot;,
  setup() &#123;
    const user = reactive(&#123; firstname: &quot;Chen&quot;, lastname: &quot;Haihong&quot; &#125;);
    const username = computed(&#123;
      get: () =&gt; user.firstname + &quot; &quot; + user.lastname,
      set: (value) =&gt; &#123;
        const [firstname, lastname] = value.trim().split(&quot; &quot;);
        user.firstname = firstname;
        user.lastname = lastname;
      &#125;,
    &#125;);
    return &#123; user, username &#125;;
  &#125;,
&#125;;
&lt;/script&gt;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210603142503777.png" alt="image-20210603142503777"></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3笔记 --- 生命周期</title>
    <url>/2021/06/09/Vue3%E7%AC%94%E8%AE%B0%20---%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<p>老壶新酒,Vue3 — 生命周期…</p>
<span id="more"></span>

<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>这属于老壶新酒了，详情见文档<a href="https://v3.cn.vuejs.org/api/options-lifecycle-hooks.html">生命周期钩子函数</a></p>
<p>vue3的生命周期钩子注册函数只能在 setup() 期间同步使用。</p>
<p>因为它们依赖于内部的全局状态来定位当前组件实例（正在调用 setup() 的组件实例）, 不在当前组件下调用这些函数会抛出一个错误。</p>
<h4 id="与-2-x-版本生命周期等效的组合式-API"><a href="#与-2-x-版本生命周期等效的组合式-API" class="headerlink" title="与 2.x 版本生命周期等效的组合式 API"></a>与 2.x 版本生命周期等效的组合式 API</h4><table>
<thead>
<tr>
<th><strong>v2.x</strong></th>
<th><strong>v3</strong></th>
</tr>
</thead>
<tbody><tr>
<td>beforeCreate</td>
<td><strong>setup</strong></td>
</tr>
<tr>
<td>created</td>
<td><strong>setup</strong></td>
</tr>
<tr>
<td>beforeMount</td>
<td>onBeforeMount</td>
</tr>
<tr>
<td>mounted</td>
<td>onMounted</td>
</tr>
<tr>
<td>beforeUpdate</td>
<td>onBeforeUpdate</td>
</tr>
<tr>
<td>updated</td>
<td>onUpdated</td>
</tr>
<tr>
<td>beforeDestroy</td>
<td>onBeforeUnmount</td>
</tr>
<tr>
<td>destroyed</td>
<td>onUnmounted</td>
</tr>
<tr>
<td>errorCaptured</td>
<td>onErrorCaptured</td>
</tr>
</tbody></table>
<h4 id="新增的钩子函数"><a href="#新增的钩子函数" class="headerlink" title="新增的钩子函数"></a>新增的钩子函数</h4><table>
<thead>
<tr>
<th><strong>onRenderTracked</strong></th>
<th>检查哪个 reactive 对象属性或一个 ref 作为依赖被追踪。当render函数被调用时，会检查哪个响应式数据被收集依赖。</th>
</tr>
</thead>
<tbody><tr>
<td><strong>onRenderTriggered</strong></td>
<td>当执行update操作时，会检查哪个响应式数据导致组件重新渲染。</td>
</tr>
</tbody></table>
<p>使用方式与watchEffect的onTrack 和 onTrigger一样：</p>
<p><a href="https://vue-composition-api-rfc.netlify.app/zh/api.html#watcheffect">https://vue-composition-api-rfc.netlify.app/zh/api.html#watcheffect</a></p>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><h4 id="App-vue"><a href="#App-vue" class="headerlink" title="App.vue"></a>App.vue</h4><pre><code class="vuejs">&lt;template&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;button @click=&quot;show=!show&quot;&gt;Toggle Demo&lt;/button&gt;
    &lt;Demo v-if=&quot;show&quot; /&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import Demo from &quot;./components/07Lifecycle.vue&quot;;
export default &#123;
  name: &quot;App&quot;,
  data() &#123;
    return &#123; show: false &#125;;
  &#125;,
  components: &#123;
    // HelloWorld,
    Demo,
  &#125;,
  errorCaptured(err, vm, info) &#123;
    console.error(err, vm.data, info);
    return true;
  &#125;,
&#125;;
&lt;/script&gt;
</code></pre>
<h4 id="Lifecycle-vue"><a href="#Lifecycle-vue" class="headerlink" title="Lifecycle.vue"></a>Lifecycle.vue</h4><pre><code class="vuejs">&lt;template&gt;
  &lt;div&gt;
    &lt;h1&gt;lifecycle - 生命周期&lt;/h1&gt;
    &lt;p&gt;&#123;&#123;data.name&#125;&#125;&lt;/p&gt;
    &lt;button @click=&quot;updateData&quot;&gt;Update data&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import &#123;
  reactive,
  // mount
  onBeforeMount,
  onMounted,
  // update
  onBeforeUpdate,
  onUpdated,
  // unmount
  onBeforeUnmount,
  onUnmounted,
  // 新增的钩子函数
  onRenderTracked,
  onRenderTriggered,
&#125; from &quot;vue&quot;;

export default &#123;
  name: &quot;Lifecycle&quot;,
  setup() &#123;
    onBeforeMount(() =&gt; &#123;
      debugger; // eslint-disable-line
    &#125;);
    onMounted(() =&gt; &#123;
      debugger; // eslint-disable-line
    &#125;);
    onBeforeUpdate(() =&gt; &#123;
      debugger; // eslint-disable-line
    &#125;);
    onUpdated(() =&gt; &#123;
      debugger; // eslint-disable-line
    &#125;);
    onBeforeUnmount(() =&gt; &#123;
      debugger; // eslint-disable-line
    &#125;);
    onUnmounted(() =&gt; &#123;
      debugger; // eslint-disable-line
    &#125;);
    onRenderTracked((e) =&gt; &#123; // eslint-disable-line
      debugger; // eslint-disable-line
    &#125;);
    onRenderTriggered((e) =&gt; &#123; // eslint-disable-line
      debugger; // eslint-disable-line
    &#125;);

    const data = reactive(&#123; name: &quot;haihong&quot; &#125;);
    const updateData = () =&gt; &#123;
      data.name = &quot;chen haiong&quot; + new Date().toLocaleTimeString();
    &#125;;
    return &#123; data, updateData &#125;;
  &#125;,
&#125;;
&lt;/script&gt;
</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue3笔记 --- Suspense</title>
    <url>/2021/08/23/Vue%E7%AC%94%E8%AE%B0%20---%20Suspense/</url>
    <content><![CDATA[<p>Suspense 组件是 Vue3 中众所周知的特征之一。它可以使我们的 vue 程序在等待异步组件时渲染一些后备内容，从而使用户产生平滑流畅的体验。…</p>
<span id="more"></span>

<p>Suspense 组件很容易理解，也不需要额外导入其他的包。</p>
<p>本文讲告诉你：</p>
<ul>
<li>什么是 Suspense 组件</li>
<li>什么时候使用</li>
<li>怎样使用</li>
</ul>
<h2 id="什么是-Suspense-组件"><a href="#什么是-Suspense-组件" class="headerlink" title="什么是 Suspense 组件"></a>什么是 Suspense 组件</h2><p>Suspense 组件用于在等待某些异步组件来解析时显示后备内容。</p>
<p>使用异步组件的场合非常多，尤其是以下情况：</p>
<ul>
<li>在页面加载之前显示加载动画</li>
<li>显示占位符内容</li>
<li>处理延迟加载的图像</li>
</ul>
<p>以前在 vue2 中，我们必须使用条件（<code>v-if</code> 或  <code>v-else</code>）来检查数据是否已加载和显示后备内容。</p>
<p>但现在 Vue3 有了内置的 Suspense，使我们不必在加载和渲染相应内容时再去额外处理了。</p>
<h2 id="怎样使用-Suspense"><a href="#怎样使用-Suspense" class="headerlink" title="怎样使用 Suspense"></a>怎样使用 Suspense</h2><p>由于本文的重点是 Suspense 而不是组件 API，所以不会涉及过多关于 API 的细节。</p>
<p>在下面的例子中，ArticleInfo 会在返回之前用异步 <code>setup</code> 方法加载用户数据。</p>
<pre><code class="vue">// ArticleInfo.vue
async function getArticleInfo() &#123;
  // 一些异步API调用
  return &#123; article &#125;
&#125;

export default &#123;
  async setup () &#123;
    var &#123; article &#125; = await getArticleInfo()

    return &#123;
      article
    &#125;
  &#125;
&#125;
</code></pre>
<p>假设 ArticleInfo 被实现在 <code>partrypost.vue</code> 中，如果我们想在等待组件获取数据并解析时显示 “Loading Profile…” ，只需三个步骤即可实现 Suspense。</p>
<ol>
<li>将异步组件包装在 <code>&lt;template #default&gt;</code> 标记中</li>
<li>在我们的异步组件旁边添加一个兄弟组件，标签为 <code>&lt;template #fallback&gt;</code></li>
<li>将上述两个组件包装在 <code>&lt;subsense&gt;</code> 组件中</li>
</ol>
<p>通过使用插槽， suspense 将会渲染后备内容，直到默认设置为准备就绪。然后它将自动切换来显示我们的异步组件。</p>
<p>代码如下：</p>
<p>ArticlePost.vue</p>
<pre><code class="vue">&lt;Suspense&gt;
    &lt;template #default&gt;
    &lt;article-info/&gt;
    &lt;/template&gt;
    &lt;template #fallback&gt;
    &lt;div&gt;Loading Profile...&lt;/div&gt;
    &lt;/template&gt;
&lt;/Suspense&gt;
</code></pre>
<h2 id="还可以捕获组件错误"><a href="#还可以捕获组件错误" class="headerlink" title="还可以捕获组件错误"></a>还可以捕获组件错误</h2><p>vue 有一个不错的功能，是当我们开始使用异步组件时，可以捕获错误并显示给用户一些错误消息。</p>
<p>在 vue2 中，也可以使用 errorCaptured hook实现，但是在 Vue3 中，它被重命名为 <code>OnErroloIched</code>。</p>
<p>不管它叫什么名字，这个 hook 都会在捕获到任何子组件的错误时被执行。如果出现问题可以使用 Suspense 渲染错误信息。</p>
<p>下面是代码实现：</p>
<p>ArticlePost.vue</p>
<pre><code class="vue">&lt;template&gt;
  &lt;div v-if=&quot;errMsg&quot;&gt; &#123;&#123; errMsg &#125;&#125; &lt;/div&gt;
  &lt;Suspense v-else&gt;
      &lt;template #default&gt;
        &lt;article-info/&gt;
      &lt;/template&gt;
      &lt;template #fallback&gt;
        &lt;div&gt;Loading Profile...&lt;/div&gt;
      &lt;/template&gt;
  &lt;/Suspense&gt;
&lt;/template&gt;

&lt;script&gt;
import &#123; onErrorCaptured &#125; from &#39;vue&#39;

setup () &#123;
  const errMsg = ref(null)
  onErrorCaptured(e =&gt; &#123;
    errMsg.value = &#39;Uh oh. Something went wrong!&#39;
    return true
  &#125;)&#125;
  return &#123; error &#125;
&lt;/script&gt;
</code></pre>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Suspense 只是 Vue 使开我们更容易解决常见问题另一种方式，而不是用来有条件地去渲染组件。</p>
<p>在我看来，它是 Vue3 最巧妙的补充之一</p>
<p>本文章转载自公众号:frontendJS</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>element-ui时间选择组件-时间选择范围限制</title>
    <url>/2021/09/01/element-ui%E6%97%B6%E9%97%B4%E9%80%89%E6%8B%A9%E7%BB%84%E4%BB%B6-%E6%97%B6%E9%97%B4%E9%80%89%E6%8B%A9%E8%8C%83%E5%9B%B4%E9%99%90%E5%88%B6/</url>
    <content><![CDATA[<p>element-ui时间选择组件-时间选择范围限制…</p>
<span id="more"></span>



<h5 id="限制当天前后45天可选"><a href="#限制当天前后45天可选" class="headerlink" title="限制当天前后45天可选"></a>限制当天前后45天可选</h5><pre><code>    pickerOptions: &#123;
      disabledDate: (time) =&gt; &#123;
        const month = 45 * 24 * 60 * 60 * 1000 // 设定日期范围
        const startDate = new Date(new Date(new Date().toLocaleDateString()).getTime()).getTime();
        const minTime = startDate - month
        const maxTime = startDate + month
        if (startDate) &#123;
          // 选中第一个时，前后45天[-45,45]共90天可选选择，超出的不可选，
          return time.getTime() &lt; minTime || time.getTime() &gt; maxTime
        &#125;
        // 不选任何日期执行下面的代码
        // return time.getTime() &gt; Date.now()
      &#125;
    &#125;
</code></pre>
<h5 id="限制选择30天时间范围，且不大于当前时间"><a href="#限制选择30天时间范围，且不大于当前时间" class="headerlink" title="限制选择30天时间范围，且不大于当前时间"></a>限制选择30天时间范围，且不大于当前时间</h5><pre><code class="vue">    mounted () &#123;
       // 保存this指向
        thisVue = this;
    &#125;,
    data: &#123;
        // 日期
        valueDate: &#39;&#39;,
        timeOptionRange: null,
        pickerOptions: &#123;
            disabledDate(time) &#123;
                // 获取选中时间
                let timeOptionRange = thisVue.timeOptionRange;
                // 获取时间范围(30天的毫秒数)
                let secondNum = 30 * 24 * 60 * 60 * 1000;
                if (timeOptionRange) &#123;
                    //如果有选中时间 设置超过选中时间后的30天||超过选中前的30天||大于当前时间 不可选
                    return time.getTime() &gt; timeOptionRange.getTime() + secondNum || time.getTime() &lt; timeOptionRange.getTime() - secondNum || time.getTime() &gt; (Date.now() - 8.64e6);
                &#125; else &#123;
                    //如果没有选中时间（初始化状态） 设置当前时间后的时间不可选
                    return time.getTime() &gt; (Date.now() - 8.64e6);
                &#125;
            &#125;,
            onPick(maxDate, minDate) &#123;
                // 当选中了第一个日期还没选第二个
                // 只选中一个的时候自动赋值给minDate，当选中第二个后组件自动匹配，将大小日期分别赋值给maxDate、minDate
                if (maxDate.minDate &amp;&amp; !maxDate.maxDate) &#123;
                    thisVue.timeOptionRange = maxDate.minDate;
                &#125;
                // 如果有maxDate属性，表示2个日期都选择了，则重置timeOptionRange
                if (maxDate.maxDate) &#123;
                    thisVue.timeOptionRange = null;
                &#125;
            &#125;
        &#125;
    &#125;,
</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>ElementUI</tag>
        <tag>原创</tag>
      </tags>
  </entry>
  <entry>
    <title>es6-Promise相关</title>
    <url>/2021/03/11/es6-Promise%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>Promise 对象代表了未来将要发生的事件，用来传递异步操作的消息。</p>
<span id="more"></span>
<h2 id="一、Promise-基本特性"><a href="#一、Promise-基本特性" class="headerlink" title="一、Promise 基本特性"></a>一、Promise 基本特性</h2><ol>
<li><p> Promise 有三种状态：<strong>pending</strong> (进行中)，fulfilled(<strong>resolve</strong>) (已成功)，<strong>rejected</strong> (已失败)</p>
</li>
<li><p> Promise 对象接受一个回调函数作为参数，该回调函数接受两个参数，分别是成功时的回调 resolve 和 失败时的回调 reject；另外 resolve 的参数除了正常值以外，还可能是一个 Promise 对象的实例；reject 的参数通常是一个 Error 对象的实例</p>
</li>
<li><p> then 方法返回一个新的 Promise 实例，并接受两个参数 onResolved ( fulfilled 状态的回调)，onRejected ( rejected 状态的回调，该参数可选)</p>
</li>
<li><p> catch 方法返回一个新的 Promise 实例</p>
</li>
<li><p> finally 方法不管 Promise 状态如何都会执行，该方法的回调函数不接受任何参数</p>
</li>
<li><p> <strong>Promise.all()</strong> 方法将多个 Promise 实例包装成一个新的 Promise 实例，该方法接受一个由 Promise 对象组成的数组作为参数 （Promise.all() 方法的参数可以不是数组，但必须具有 Iterator 接口，且返回的每个成员都是 Promise 实例），注意参数中只要有一个实例触发 catch 方法，都会触发 Promise.all() 方法返回的新实例的 catch 方法，如果参数中的某个实例本身调用了 catch 方法，将不会触发 Promise.all() 方法返回的新实例的 catch 方法</p>
</li>
<li><p> Promise.race() 方法的参数与 Promise.all() 方法一样，参数中的实例只要有一个率先改变状态就会将该实例的状态传给 Promise.race() 方法，并将返回值作为 Promise.race() 方法产生的 Promise 实例的返回值</p>
</li>
<li><p> Promise.resolve() 将现有对象转为 Promise 对象，如果该方法的参数为一个 Promise 对象，Promise.resolve() 将不做任何处理；如果参数是 thenable 对象（即具有 then 方法），Promise.resolve() 方法将该对象转为 Promise 对象并立即执行 then 方法；如果参数是一个原始值，或者是一个不具有 then 方法的对象，则 Promise.resolve() 返回一个新的 Promise 对象，状态为 fulfilled，其参数将作为 then 方法中 onResolved 回调函数的参数。如果 Promise.resolve() 方法不传入参数，会直接返回一个 fulfilled 状态的 Promise 对象。需要注意的是，立即 resolve() 的 Promise 对象，是在本轮“事件循环（event loop）”结束时执行，而不是在下一轮“事件循环”的开始时执行</p>
</li>
<li><p> Promise.reject() 同样返回一个新的 Promise 对象，状态为 rejected，无论传入任何参数都将作为 reject() 的参数</p>
</li>
</ol>
<h2 id="二、Promise-的优点"><a href="#二、Promise-的优点" class="headerlink" title="二、Promise 的优点"></a>二、Promise 的优点</h2><ol>
<li><p>统一的异步 API</p>
<p>Promise 的一个重要优点是它将逐渐被用作浏览器的异步 API ，统一现在各种各样的 API ，以及不兼容的模式和写法。</p>
</li>
<li><p>Promise 与事件对比</p>
<p>和事件相比较，Promise 更适合处理一次性的结果，在结果计算出来之前或之后注册回调函数都是可以的，都可以拿到正确的值。Promise 的这个优点很自然。但是，不能使用 Promise 处理多次触发的事件。链式处理是 Promise 的又一优点，但是事件却不能这样链式处理。</p>
</li>
<li><p>Promise 和回调对比</p>
<p>解决了回调地狱的问题，将异步操作以同步操作的流程表达出来。</p>
</li>
<li><p>Promise 带来的额外的好处是包含了更好的错误处理方式（包含了异常处理），并且写起来很轻松（因为可以重用一些同步工具，比如 Array.prototype.map()）。</p>
</li>
</ol>
<h2 id="三、Promise-的缺点"><a href="#三、Promise-的缺点" class="headerlink" title="三、Promise 的缺点"></a>三、Promise 的缺点</h2><ol>
<li><p>无法取消 Promise，一旦新建它就会立即执行，无法中途取消。</p>
</li>
<li><p>如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。</p>
</li>
<li><p>当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>
</li>
<li><p>Promise 真正执行回调的时候，定义 Promise 那部分实际上已经执行完了，所以 Promise 的报错堆栈上下文不太友好</p>
</li>
</ol>
<h2 id="四、简单代码实现"><a href="#四、简单代码实现" class="headerlink" title="四、简单代码实现."></a>四、简单代码实现.</h2><p>最简单的 Promise 实现有 7 个主要属性，state(状态），value(成功返回值），reason(错误信息)，resolve 方法，reject 方法，then 方法。</p>
<h3 id="class版"><a href="#class版" class="headerlink" title="class版"></a>class版</h3><pre><code class="js">class Promise&#123;
    constructor(executor)&#123;
        this.state = &#39;pending&#39;;
        this.value = undefined;
        this.reason = undefined;
        let resolve = value=&gt;&#123;
            if(this.state === &#39;pending&#39;)&#123;
                this.state = &#39;fulfilled&#39;;
                this.value = value;
            &#125;
        &#125;;
        let reject = value=&gt;&#123;
            if(this.state === &#39;pending&#39;)&#123;
                this.state = &#39;rejected&#39;;
                this.reason = value;
            &#125;
        &#125;;
        try&#123;
            //立即执行函数
            executor(resolve,reject);
        &#125;catch(err)&#123;
            reject(err);
        &#125;
    &#125;
    then(onFulfilled,onRejected)&#123;
        if(this.state === &#39;fulfilled&#39;)&#123;
            typeof onFulfilled === &#39;function&#39; &amp;&amp; onFulfilled(this.value);
        &#125;;
        if(this.state === &#39;rejected&#39;)&#123;
            typeof onRejected === &#39;function&#39; &amp;&amp; onRejected(this.reason);
        &#125;;
    &#125;
    
&#125;
</code></pre>
<h3 id="function版"><a href="#function版" class="headerlink" title="function版"></a>function版</h3><pre><code class="js">function myPromise(constructor)&#123; let self=this;
  self.status=&quot;pending&quot; //定义状态改变前的初始状态 
  self.value=undefined;//定义状态为resolved的时候的状态 
  self.reason=undefined;//定义状态为rejected的时候的状态 
  function resolve(value)&#123;
    //两个===&quot;pending&quot;，保证了了状态的改变是不不可逆的 
    if(self.status===&quot;pending&quot;)&#123;
      self.value=value;
      self.status=&quot;resolved&quot;; 
    &#125;
  &#125;
  function reject(reason)&#123;
     //两个===&quot;pending&quot;，保证了了状态的改变是不不可逆的
     if(self.status===&quot;pending&quot;)&#123;
        self.reason=reason;
        self.status=&quot;rejected&quot;; 
      &#125;
  &#125;
  //捕获构造异常 
  try&#123;
      constructor(resolve,reject);
  &#125;catch(e)&#123;
    reject(e);
    &#125; 
&#125;
myPromise.prototype.then=function(onFullfilled,onRejected)&#123; 
  let self=this;
  switch(self.status)&#123;
    case &quot;resolved&quot;: onFullfilled(self.value); break;
    case &quot;rejected&quot;: onRejected(self.reason); break;
    default: 
  &#125;
&#125;

// 测试
var p=new myPromise(function(resolve,reject)&#123;resolve(1)&#125;); 
p.then(function(x)&#123;console.log(x)&#125;)
//输出1
</code></pre>
<p>测试：</p>
<pre><code class="js">m = new Promise(resolve=&gt;&#123;
    console.log(&#39;aaa&#39;)
    setTimeout(function()&#123;
        resolve(9000)
    &#125;, 2000)

&#125;)
m.then(res=&gt;console.log(res));//执行
</code></pre>
<p>运行起来我们发现只打印了构造函数中的 aaa 而 异步 then  方法并没有执行。</p>
<p><img src="https://img-blog.csdnimg.cn/20201216161028331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L01GV1NDUQ==,size_16,color_FFFFFF,t_70"></p>
<p>当then里面函数运行时，resolve由于是异步执行的，还没有来得及修改state，此时还是PENDING状态；因此我们需要对异步的情况做一下处理。</p>
<h3 id="class进阶版"><a href="#class进阶版" class="headerlink" title="class进阶版"></a>class进阶版</h3><pre><code class="js">class Promise&#123;
    constructor(executor)&#123;
        this.state = &#39;pending&#39;;
        this.value = undefined;
        this.reason = undefined;
        this.onFulfilled = [];
        this.onRejected = [];
 
        try&#123;
            executor(this.resolve,this.reject);
        &#125;catch(e)&#123;
            this.reject(e);
        &#125;
        
    &#125;
    resolve = (res)=&gt;&#123;
        if(this.state === &#39;pending&#39;)&#123;
            this.state = &#39;fulfilled&#39;;
            this.value = res;
            this.onFulfilled.forEach(fn=&gt;fn(res));
        &#125;
    &#125;
 
    reject = (res)=&gt;&#123;
        if(this.state === &#39;pending&#39;)&#123;
            this.state = &#39;rejected&#39;;
            this.reason = res;
            this.onRejected.forEach(fn=&gt;fn(res));
        &#125;
    &#125;
 
    then = (onFulfilled,onRejected)=&gt;&#123;
        if(this.state === &#39;fulfilled&#39;)&#123;
            typeof onFulfilled === &#39;function&#39; &amp;&amp; onFulfilled(this.value);
        &#125;
        if(this.state === &#39;rejected&#39;)&#123;
            typeof onRejected === &#39;function&#39; &amp;&amp; onRejected(this.value);
        &#125;
        if(this.state === &#39;pending&#39;)&#123;
            typeof onFulfilled === &#39;function&#39; &amp;&amp; this.onFulfilled.push(onFulfilled);
            typeof onRejected === &#39;function&#39; &amp;&amp; this.onRejected.push(onRejected);
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="function进阶版"><a href="#function进阶版" class="headerlink" title="function进阶版"></a>function进阶版</h3><pre><code class="js">const PENDING = &quot;pending&quot;; 
const FULFILLED = &quot;fulfilled&quot;; 
const REJECTED = &quot;rejected&quot;;
function Promise(excutor) &#123;
  let that = this; // 缓存当前promise实例例对象
  that.status = PENDING; // 初始状态
  that.value = undefined; // fulfilled状态时 返回的信息
  that.reason = undefined; // rejected状态时 拒绝的原因 
  that.onFulfilledCallbacks = []; // 存储fulfilled状态对应的onFulfilled函数
  that.onRejectedCallbacks = []; // 存储rejected状态对应的onRejected函数
  function resolve(value) &#123; // value成功态时接收的终值
    if(value instanceof Promise) &#123;
      return value.then(resolve, reject);
    &#125;
    // 实践中要确保 onFulfilled 和 onRejected ⽅方法异步执⾏行行，且应该在 then ⽅方法被调⽤用的那⼀一轮事件循环之后的新执⾏行行栈中执⾏行行。
    setTimeout(() =&gt; &#123;
      // 调⽤用resolve 回调对应onFulfilled函数
      if (that.status === PENDING) &#123;
        // 只能由pending状态 =&gt; fulfilled状态 (避免调⽤用多次resolve reject)
        that.status = FULFILLED;
        that.value = value;
        that.onFulfilledCallbacks.forEach(cb =&gt; cb(that.value));
      &#125;
    &#125;);
  &#125;
  function reject(reason) &#123; // reason失败态时接收的拒因
    setTimeout(() =&gt; &#123;
      // 调⽤用reject 回调对应onRejected函数
      if (that.status === PENDING) &#123;
        // 只能由pending状态 =&gt; rejected状态 (避免调⽤用多次resolve reject)
        that.status = REJECTED;
        that.reason = reason;
        that.onRejectedCallbacks.forEach(cb =&gt; cb(that.reason));
      &#125;
    &#125;);
  &#125;

  // 捕获在excutor执⾏行行器器中抛出的异常
  // new Promise((resolve, reject) =&gt; &#123;
  //     throw new Error(&#39;error in excutor&#39;)
  // &#125;)
  try &#123;
    excutor(resolve, reject);
  &#125; catch (e) &#123;
    reject(e);
  &#125;
&#125;
Promise.prototype.then = function(onFulfilled, onRejected) &#123;
  const that = this;
  let newPromise;
  // 处理理参数默认值 保证参数后续能够继续执⾏行行
  onFulfilled = typeof onFulfilled === &quot;function&quot; ? onFulfilled : value =&gt; value;
  onRejected = typeof onRejected === &quot;function&quot; ? onRejected : reason =&gt; &#123;
    throw reason;
  &#125;;
  if (that.status === FULFILLED) &#123; // 成功态
    return newPromise = new Promise((resolve, reject) =&gt; &#123;
      setTimeout(() =&gt; &#123;
        try&#123;
          let x = onFulfilled(that.value);
          resolvePromise(newPromise, x, resolve, reject); //新的promise resolve 上⼀一个onFulfilled的返回值
        &#125; catch(e) &#123;
          reject(e); // 捕获前⾯面onFulfilled中抛出的异常then(onFulfilled, onRejected);
        &#125;
      &#125;);
    &#125;)
  &#125;
  if (that.status === REJECTED) &#123; // 失败态
    return newPromise = new Promise((resolve, reject) =&gt; &#123;
      setTimeout(() =&gt; &#123;
        try &#123;
          let x = onRejected(that.reason);
          resolvePromise(newPromise, x, resolve, reject);
        &#125; catch(e) &#123;
          reject(e);
        &#125;
      &#125;);
    &#125;);
  &#125;
  if (that.status === PENDING) &#123; // 等待态
// 当异步调⽤用resolve/rejected时 将onFulfilled/onRejected收集暂存到集合中
    return newPromise = new Promise((resolve, reject) =&gt; &#123;
      that.onFulfilledCallbacks.push((value) =&gt; &#123;
        try &#123;
          let x = onFulfilled(value);
          resolvePromise(newPromise, x, resolve, reject);
        &#125; catch(e) &#123;
          reject(e);
        &#125;
      &#125;);
      that.onRejectedCallbacks.push((reason) =&gt; &#123;
        try &#123;
          let x = onRejected(reason);
          resolvePromise(newPromise, x, resolve, reject);
        &#125; catch(e) &#123;
          reject(e);
        &#125;
      &#125;);
    &#125;);
  &#125;
&#125;;
</code></pre>
<hr>
<p>参考文档:<a href="https://blog.csdn.net/MFWSCQ/article/details/108382519">CSDN文章: Promise 的特性、优缺点，内部是如何实现的，动手实现 Promise</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>gitee使用webhook</title>
    <url>/2021/08/06/gitee%E7%A0%81%E4%BA%91%E4%BD%BF%E7%94%A8webhook/</url>
    <content><![CDATA[<p>gitee配置webhook…</p>
<span id="more"></span>


<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>我们经常使用GitHub、GitLab、Gitee 之类的仓库，有时候需要频繁的发布代码打包，人工发布，工作量有时候会很大，有时候还容易出错，所以会使用Jenkins一类的工具进行辅助，但是如果是一个简单的项目或者是个人项目使用Jenkins就显得太重了，可以直接使用webhook，比较方便。</p>
<h3 id="什么是webhook"><a href="#什么是webhook" class="headerlink" title="什么是webhook"></a>什么是webhook</h3><blockquote>
<p>准确的说webhoo是一种web回调或者http的push API，是向APP或者其他应用提供实时信息的一种方式。Webhook在数据产生时立即发送数据，也就是你能实时收到数据。这一种不同于典型的API，需要用了实时性需要足够快的轮询。这无论是对生产还是对消费者都是高效的，唯一的缺点是初始建立困难。</p>
</blockquote>
<blockquote>
<p>Webhook有时也被称为反向API，因为他提供了API规则，你需要设计要使用的API。Webhook将向你的应用发起http请求，典型的是post请求，应用程序由请求驱动。</p>
</blockquote>
<h3 id="配置webhook"><a href="#配置webhook" class="headerlink" title="配置webhook"></a>配置webhook</h3><p>知道什么是webhook 后我们就要开始配置我们自己的项目了。<br> 环境：<br> CentOS7<br> Gitee（网上GitHub的教程比较多，这个基于码云）</p>
<ul>
<li>配置项目公私钥</li>
</ul>
<ol>
<li>生产公钥</li>
</ol>
<pre><code class="bash">ssh-keygen -t rsa -C &quot;xxxxx@xxxxx.com&quot;  

# Generating public/private rsa key pair...
# 三次回车即可生成 ssh key
</code></pre>
<ol>
<li>查看公钥</li>
</ol>
<pre><code class="bash">cat ~/.ssh/id_rsa.pub
# ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC6eNtGpNGwstc....
</code></pre>
<ol>
<li><p>添加公钥</p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210806130257753.png" alt="image-20210806130257753"></p>
</li>
<li><p>测试</p>
</li>
</ol>
<pre><code class="bash">ssh -T git@gitee.com
Welcome to Gitee.com, yourname! # 返回，说明正常
</code></pre>
<ul>
<li>配置服务器node环境</li>
</ul>
<ol>
<li>安装nvm，服务器上使用nvm 方便多版本node切换</li>
</ol>
<pre><code class="bash">curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh | bash
vim /etc/profile
#加入下面的内容
export NVM_DIR=&quot;$HOME/.nvm&quot;
[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot;
source /etc/profile
nvm install stable # 安装稳定版
nvm current # 查看当前的版本
</code></pre>
<ol>
<li>配置相关的脚本<br> 安装gitee-webhook-handler(GitHub,GitLab,gitee 的包是不同的，不能混用)</li>
</ol>
<pre><code class="bash">mkdir /opt/webhook #创建目录
cd /opt/webhook
npm init # 初始化项目，方便以后迁移
npm install  gitee-webhook-handler --save # 当前的版本为v0.1.2
</code></pre>
<ol>
<li>创建对应的webhook服务</li>
</ol>
<pre><code class="bash">vim webhook.js

var http = require(&#39;http&#39;)
var createHandler = require(&#39;gitee-webhook-handler&#39;)
var handler = createHandler(&#123; path: &#39;/webhooks_push&#39;, secret: &#39;123456&#39; &#125;)# post 所需要用到的秘钥

function run_cmd(cmd, args, callback) &#123;
  var spawn = require(&#39;child_process&#39;).spawn;
  var child = spawn(cmd, args);
  var resp = &quot;&quot;;
  child.stdout.on(&#39;data&#39;, function(buffer) &#123; resp += buffer.toString(); &#125;);
  child.stdout.on(&#39;end&#39;, function() &#123; callback (resp) &#125;);
&#125;
handler.on(&#39;error&#39;, function (err) &#123;
  console.error(&#39;Error:&#39;, err.message)
&#125;)
handler.on(&#39;Push Hook&#39;, function (event) &#123;  # 这个地方就是GitHub 和 Gitee 不一样的地方，需要注意
  console.log(&#39;Received a push event for %s to %s&#39;,
    event.payload.repository.name,
    event.payload.ref);
    run_cmd(&#39;sh&#39;, [&#39;./deploy.sh&#39;], function(text)&#123; console.log(text) &#125;);# 需要执行的脚本位置
&#125;)
try &#123;
  http.createServer(function (req, res) &#123;
    handler(req, res, function (err) &#123;
      res.statusCode = 404
      res.end(&#39;no such location&#39;)
    &#125;)
  &#125;).listen(6666) # 服务监听的端口，可以自行修改
&#125;catch(err)&#123;
  console.error(&#39;Error:&#39;, err.message)
&#125;
</code></pre>
<ol>
<li>创建需要执行的脚本</li>
</ol>
<pre><code class="bash">vim deploy.sh
git pull xxxxx  # 根据自己的需要自行编写
</code></pre>
<ol>
<li><p>测试服务</p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210806130418973.png" alt="image-20210806130418973"></p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210806130444529.png" alt="image-20210806130444529"></p>
<p>显示ok，说明成功</p>
<h3 id="使用pm2应用进程管理器"><a href="#使用pm2应用进程管理器" class="headerlink" title="使用pm2应用进程管理器"></a>使用pm2应用进程管理器</h3><p>使用node 启动服务不是很方便，推荐使用pm2</p>
<pre><code class="bash">npm install -g pm2
pm2 start webhook.js
pm2 monit # 可以通过此命令查看服务的状态
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210806130519710.png" alt="image-20210806130519710"></p>
<p>上图显示了一些应用的基本信息，可以更好的观察到服务的状态</p>
<h3 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h3><p>配置完成后，只要pull代码到仓库，就会触发webhook执行脚本，十分的方便，同时减少了工作量，相对采用轮询的方式消耗的资源更小。</p>
<p>参考：<a href="https://www.npmjs.com/package/gitee-webhook-handler">https://www.npmjs.com/package/gitee-webhook-handler</a></p>
<p>转载于:<a href="https://www.jianshu.com/p/caa541590d48">gitee码云使用webhook</a></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>github配置ssh</title>
    <url>/2021/04/08/github%E9%85%8D%E7%BD%AEssh/</url>
    <content><![CDATA[<p>为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。</p>
<span id="more"></span>

<h4 id="1-从程序目录打开Git-Bash"><a href="#1-从程序目录打开Git-Bash" class="headerlink" title="1.从程序目录打开Git Bash"></a>1.从程序目录打开Git Bash</h4><h4 id="2-ssh-keygen-t-rsa-C-“-x65-109-97-105-108-x40-101-x6d-x61-x69-108-46-x63-x6f-109-“-x65-x6d-x61-105-x6c-x40-x65-109-x61-x69-x6c-x2e-99-x6f-x6d-是自己github账号"><a href="#2-ssh-keygen-t-rsa-C-“-x65-109-97-105-108-x40-101-x6d-x61-x69-108-46-x63-x6f-109-“-x65-x6d-x61-105-x6c-x40-x65-109-x61-x69-x6c-x2e-99-x6f-x6d-是自己github账号" class="headerlink" title="2.ssh-keygen -t rsa -C “&#x65;&#109;&#97;&#105;&#108;&#x40;&#101;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;“ ,&#x65;&#x6d;&#x61;&#105;&#x6c;&#x40;&#x65;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;是自己github账号"></a>2.ssh-keygen -t rsa -C “<a href="mailto:&#x65;&#109;&#97;&#105;&#108;&#x40;&#101;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;">&#x65;&#109;&#97;&#105;&#108;&#x40;&#101;&#x6d;&#x61;&#x69;&#108;&#46;&#x63;&#x6f;&#109;</a>“ ,<a href="mailto:&#x65;&#x6d;&#x61;&#105;&#x6c;&#x40;&#x65;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;">&#x65;&#x6d;&#x61;&#105;&#x6c;&#x40;&#x65;&#109;&#x61;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;</a>是自己github账号</h4><h4 id="3-提醒你输入key的名称，你可以不用输入，一路回车，就OK了"><a href="#3-提醒你输入key的名称，你可以不用输入，一路回车，就OK了" class="headerlink" title="3.提醒你输入key的名称，你可以不用输入，一路回车，就OK了"></a>3.提醒你输入key的名称，你可以不用输入，一路回车，就OK了</h4><h4 id="4-一般会在用户目录下生成三个文件，例如我生成的文件在C-Users-xxx-ssh目录下"><a href="#4-一般会在用户目录下生成三个文件，例如我生成的文件在C-Users-xxx-ssh目录下" class="headerlink" title="4.一般会在用户目录下生成三个文件，例如我生成的文件在C:\Users\xxx\.ssh目录下"></a>4.一般会在用户目录下生成三个文件，例如我生成的文件在C:\Users\xxx\.ssh目录下</h4><h4 id="5-进入该用户的目录下用命令cat-id-rsa-pub打开文件并复制里面的全部内容"><a href="#5-进入该用户的目录下用命令cat-id-rsa-pub打开文件并复制里面的全部内容" class="headerlink" title="5.进入该用户的目录下用命令cat id_rsa.pub打开文件并复制里面的全部内容"></a>5.进入该用户的目录下用命令cat id_rsa.pub打开文件并复制里面的全部内容</h4><h4 id="6-打开github账号–-gt-Settings–-gt-SSH-and-GPG-keys–-gt-New-SSH-key-并把复制好的内容全部粘贴进去"><a href="#6-打开github账号–-gt-Settings–-gt-SSH-and-GPG-keys–-gt-New-SSH-key-并把复制好的内容全部粘贴进去" class="headerlink" title="6.打开github账号–&gt;Settings–&gt;SSH and GPG keys–&gt;New SSH key,并把复制好的内容全部粘贴进去"></a>6.打开github账号–&gt;Settings–&gt;SSH and GPG keys–&gt;New SSH key,并把复制好的内容全部粘贴进去</h4><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/ssh1.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/ssh2.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/git_ssh.png"></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>js工具函数</title>
    <url>/2021/07/19/js%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>整理一下前端开发中常用的工具方法，有了这些工具函数就可以高效的处理任务和信息了。</p>
<span id="more"></span>
<h4 id="1-邮箱"><a href="#1-邮箱" class="headerlink" title="1.邮箱"></a>1.邮箱</h4><pre><code class="javascript">export const isEmail = (s) =&gt; &#123;
    return /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]&#123;2,3&#125;)&#123;1,2&#125;)$/.test(s)
&#125;
</code></pre>
<h4 id="2-手机号码"><a href="#2-手机号码" class="headerlink" title="2.手机号码"></a>2.手机号码</h4><pre><code class="javascript">export const isMobile = (s) =&gt; &#123;
    return /^1[0-9]&#123;10&#125;$/.test(s)
&#125;
</code></pre>
<h4 id="3-电话号码"><a href="#3-电话号码" class="headerlink" title="3.电话号码"></a>3.电话号码</h4><pre><code class="javascript">export const isPhone = (s) =&gt; &#123;
    return /^([0-9]&#123;3,4&#125;-)?[0-9]&#123;7,8&#125;$/.test(s)
&#125;
</code></pre>
<h4 id="4-是否为url地址"><a href="#4-是否为url地址" class="headerlink" title="4.是否为url地址"></a>4.是否为url地址</h4><pre><code class="javascript">export const isURL = (s) =&gt; &#123;
    return /^http[s]?:\/\/.*/.test(s)
&#125;
</code></pre>
<h4 id="5-是否字符串"><a href="#5-是否字符串" class="headerlink" title="5.是否字符串"></a>5.是否字符串</h4><pre><code class="javascript">export const isString = (o) =&gt; &#123;
    return Object.prototype.toString.call(o).slice(8, -1) === &#39;String&#39;
&#125;
</code></pre>
<h4 id="6-是否数字"><a href="#6-是否数字" class="headerlink" title="6.是否数字"></a>6.是否数字</h4><pre><code class="javascript">export const isNumber = (o) =&gt; &#123;
    return Object.prototype.toString.call(o).slice(8, -1) === &#39;Number&#39;
&#125;
</code></pre>
<h4 id="7-是否为boolean"><a href="#7-是否为boolean" class="headerlink" title="7.是否为boolean"></a>7.是否为boolean</h4><pre><code class="javascript">export const isBoolean = (o) =&gt; &#123;
    return Object.prototype.toString.call(o).slice(8, -1) === &#39;Boolean&#39;
&#125;
</code></pre>
<h4 id="8-是否为函数"><a href="#8-是否为函数" class="headerlink" title="8.是否为函数"></a>8.是否为函数</h4><pre><code class="javascript">export const isFunction = (o) =&gt; &#123;
    return Object.prototype.toString.call(o).slice(8, -1) === &#39;Function&#39;
&#125;
</code></pre>
<h4 id="9-是否为null"><a href="#9-是否为null" class="headerlink" title="9.是否为null"></a>9.是否为null</h4><pre><code class="javascript">export const isNull = (o) =&gt; &#123;
    return Object.prototype.toString.call(o).slice(8, -1) === &#39;Null&#39;
&#125;
</code></pre>
<h4 id="10-是否为undefined"><a href="#10-是否为undefined" class="headerlink" title="10.是否为undefined"></a>10.是否为undefined</h4><pre><code class="javascript">export const isUndefined = (o) =&gt; &#123;
    return Object.prototype.toString.call(o).slice(8, -1) === &#39;Undefined&#39;
&#125;
</code></pre>
<h4 id="11-是否为对象"><a href="#11-是否为对象" class="headerlink" title="11.是否为对象"></a>11.是否为对象</h4><pre><code class="javascript">export const isObj = (o) =&gt; &#123;
    return Object.prototype.toString.call(o).slice(8, -1) === &#39;Object&#39;
&#125;
</code></pre>
<h4 id="12-是否为数组"><a href="#12-是否为数组" class="headerlink" title="12.是否为数组"></a>12.是否为数组</h4><pre><code class="javascript">export const isArray = (o) =&gt; &#123;
    return Object.prototype.toString.call(o).slice(8, -1) === &#39;Array&#39;
&#125;
</code></pre>
<h4 id="13-是否为时间"><a href="#13-是否为时间" class="headerlink" title="13.是否为时间"></a>13.是否为时间</h4><pre><code class="javascript">export const isDate = (o) =&gt; &#123;
    return Object.prototype.toString.call(o).slice(8, -1) === &#39;Date&#39;
&#125;
</code></pre>
<h4 id="14-是否为正则"><a href="#14-是否为正则" class="headerlink" title="14.是否为正则"></a>14.是否为正则</h4><pre><code class="javascript">export const isRegExp = (o) =&gt; &#123;
    return Object.prototype.toString.call(o).slice(8, -1) === &#39;RegExp&#39;
&#125;
</code></pre>
<h4 id="15-是否为错误对象"><a href="#15-是否为错误对象" class="headerlink" title="15.是否为错误对象"></a>15.是否为错误对象</h4><pre><code class="javascript">export const isError = (o) =&gt; &#123;
    return Object.prototype.toString.call(o).slice(8, -1) === &#39;Error&#39;
&#125;
</code></pre>
<h4 id="16-是否为Symbol函数"><a href="#16-是否为Symbol函数" class="headerlink" title="16.是否为Symbol函数"></a>16.是否为Symbol函数</h4><pre><code class="javascript">export const isSymbol = (o) =&gt; &#123;
    return Object.prototype.toString.call(o).slice(8, -1) === &#39;Symbol&#39;
&#125;
</code></pre>
<h4 id="17-是否为Promise对象"><a href="#17-是否为Promise对象" class="headerlink" title="17.是否为Promise对象"></a>17.是否为Promise对象</h4><pre><code class="javascript">export const isPromise = (o) =&gt; &#123;
    return Object.prototype.toString.call(o).slice(8, -1) === &#39;Promise&#39;
&#125;
</code></pre>
<h4 id="18-是否为Set对象"><a href="#18-是否为Set对象" class="headerlink" title="18.是否为Set对象"></a>18.是否为Set对象</h4><pre><code class="javascript">export const isSet = (o) =&gt; &#123;    
    return Object.prototype.toString.call(o).slice(8, -1) === &#39;Set&#39; 
&#125; 
</code></pre>
<h4 id="19-是否是微信浏览器"><a href="#19-是否是微信浏览器" class="headerlink" title="19.是否是微信浏览器"></a>19.是否是微信浏览器</h4><pre><code class="javascript">export const isWeiXin = () =&gt; &#123;
    return (navigator.userAgent.toLowerCase()).match(/microMessenger/i) == &#39;micromessenger&#39;
&#125;
</code></pre>
<h4 id="20-是否为移动端"><a href="#20-是否为移动端" class="headerlink" title="20.是否为移动端"></a>20.是否为移动端</h4><pre><code class="javascript">export const isDeviceMobile = () =&gt; &#123;
    return /android|webos|iphone|ipod|balckberry/i.test(ua)
&#125;
</code></pre>
<h4 id="21-是否是QQ浏览器"><a href="#21-是否是QQ浏览器" class="headerlink" title="21.是否是QQ浏览器"></a>21.是否是QQ浏览器</h4><pre><code class="javascript">export const isQQBrowser = () =&gt; &#123;
    return !!ua.match(/mqqbrowser|qzone|qqbrowser|qbwebviewtype/i)
&#125;
</code></pre>
<h4 id="22-是否为ios"><a href="#22-是否为ios" class="headerlink" title="22.是否为ios"></a>22.是否为ios</h4><pre><code class="javascript">export const isIos = () =&gt; &#123;
  var u = navigator.userAgent;
  if (u.indexOf(&#39;Android&#39;) &gt; -1 || u.indexOf(&#39;Linux&#39;) &gt; -1) &#123;  
    // 安卓手机
    return false
  &#125; else if (u.indexOf(&#39;iPhone&#39;) &gt; -1) &#123;
    // 苹果手机
    return true
  &#125; else if (u.indexOf(&#39;iPad&#39;) &gt; -1) &#123; 
    // iPad
    return false
  &#125; else if (u.indexOf(&#39;Windows Phone&#39;) &gt; -1) &#123;
    //winphone手机
    return false
  &#125; else &#123;
    return false
  &#125;
&#125;
</code></pre>
<h4 id="23-是否为PC端"><a href="#23-是否为PC端" class="headerlink" title="23.是否为PC端"></a>23.是否为PC端</h4><pre><code class="javascript">export const isPC = () =&gt; &#123;
  var userAgentInfo = navigator.userAgent;
  var Agents = [&quot;Android&quot;, &quot;iPhone&quot;,
    &quot;SymbianOS&quot;, &quot;Windows Phone&quot;,
    &quot;iPad&quot;, &quot;iPod&quot;];
  var flag = true;
  for (var v = 0; v &lt; Agents.length; v++) &#123;
    if (userAgentInfo.indexOf(Agents[v]) &gt; 0) &#123;
      flag = false;
      break;
    &#125;
  &#125;
  return flag;
&#125;
</code></pre>
<h4 id="24-去除html标签"><a href="#24-去除html标签" class="headerlink" title="24.去除html标签"></a>24.去除html标签</h4><pre><code class="javascript">export const removeHtmltag = (str) =&gt; &#123;
    return str.replace(/&lt;[^&gt;]+&gt;/g, &#39;&#39;)
&#125;
</code></pre>
<h4 id="25-获取url参数"><a href="#25-获取url参数" class="headerlink" title="25.获取url参数"></a>25.获取url参数</h4><pre><code class="javascript">export const getQueryString = (name) =&gt; &#123;
  const reg = new RegExp(&#39;(^|&amp;)&#39; + name + &#39;=([^&amp;]*)(&amp;|$)&#39;, &#39;i&#39;);
  const search = window.location.search.split(&#39;?&#39;)[1] || &#39;&#39;;
  const r = search.match(reg) || [];
  return r[2];
&#125;
</code></pre>
<h4 id="26-动态引入js"><a href="#26-动态引入js" class="headerlink" title="26.动态引入js"></a>26.动态引入js</h4><pre><code class="javascript">export const injectScript = (src) =&gt; &#123;
  const s = document.createElement(&#39;script&#39;);
  s.type = &#39;text/javascript&#39;;
  s.async = true;
  s.src = src;
  const t = document.getElementsByTagName(&#39;script&#39;)[0];
  t.parentNode.insertBefore(s, t);
&#125;
</code></pre>
<h4 id="27-根据url地址下载"><a href="#27-根据url地址下载" class="headerlink" title="27.根据url地址下载"></a>27.根据url地址下载</h4><pre><code class="javascript">export const download = (url) =&gt; &#123;
  var isChrome = navigator.userAgent.toLowerCase().indexOf(&#39;chrome&#39;) &gt; -1;
  var isSafari = navigator.userAgent.toLowerCase().indexOf(&#39;safari&#39;) &gt; -1;
  if (isChrome || isSafari) &#123;
    var link = document.createElement(&#39;a&#39;);
    link.href = url;
    if (link.download !== undefined) &#123;
      var fileName = url.substring(url.lastIndexOf(&#39;/&#39;) + 1, url.length);
      link.download = fileName;
    &#125;
    if (document.createEvent) &#123;
      var e = document.createEvent(&#39;MouseEvents&#39;);
      e.initEvent(&#39;click&#39;, true, true);
      link.dispatchEvent(e);
      return true;
    &#125;
  &#125;
  if (url.indexOf(&#39;?&#39;) === -1) &#123;
    url += &#39;?download&#39;;
  &#125;
  window.open(url, &#39;_self&#39;);
  return true;
&#125;
</code></pre>
<h4 id="28-el是否包含某个class"><a href="#28-el是否包含某个class" class="headerlink" title="28.el是否包含某个class"></a>28.el是否包含某个class</h4><pre><code class="javascript">export const hasClass = (el, className) =&gt; &#123;
  let reg = new RegExp(&#39;(^|\\s)&#39; + className + &#39;(\\s|$)&#39;)
  return reg.test(el.className)
&#125;
</code></pre>
<h4 id="29-el添加某个class"><a href="#29-el添加某个class" class="headerlink" title="29.el添加某个class"></a>29.el添加某个class</h4><pre><code class="javascript">export const addClass = (el, className) =&gt; &#123;
  if (hasClass(el, className)) &#123;
    return
  &#125;
  let newClass = el.className.split(&#39; &#39;)
  newClass.push(className)
  el.className = newClass.join(&#39; &#39;)
&#125;
</code></pre>
<h4 id="30-el去除某个class"><a href="#30-el去除某个class" class="headerlink" title="30.el去除某个class"></a>30.el去除某个class</h4><pre><code class="javascript">export const removeClass = (el, className) =&gt; &#123;
  if (!hasClass(el, className)) &#123;
    return
  &#125;
  let reg = new RegExp(&#39;(^|\\s)&#39; + className + &#39;(\\s|$)&#39;, &#39;g&#39;)
  el.className = el.className.replace(reg, &#39; &#39;)
&#125;
</code></pre>
<h4 id="31-获取滚动的坐标"><a href="#31-获取滚动的坐标" class="headerlink" title="31.获取滚动的坐标"></a>31.获取滚动的坐标</h4><pre><code class="javascript">export const getScrollPosition = (el = window) =&gt; (&#123;
  x: el.pageXOffset !== undefined ? el.pageXOffset : el.scrollLeft,
  y: el.pageYOffset !== undefined ? el.pageYOffset : el.scrollTop
&#125;);
</code></pre>
<h4 id="32-滚动到顶部"><a href="#32-滚动到顶部" class="headerlink" title="32.滚动到顶部"></a>32.滚动到顶部</h4><pre><code class="javascript">export const scrollToTop = () =&gt; &#123;
  const c = document.documentElement.scrollTop || document.body.scrollTop;
  if (c &gt; 0) &#123;
    window.requestAnimationFrame(scrollToTop);
    window.scrollTo(0, c - c / 8);
  &#125;
&#125;
</code></pre>
<h4 id="33-el是否在视口范围内"><a href="#33-el是否在视口范围内" class="headerlink" title="33.el是否在视口范围内"></a>33.el是否在视口范围内</h4><pre><code class="javascript">export const elementIsVisibleInViewport = (el, partiallyVisible = false) =&gt; &#123;
  const &#123; top, left, bottom, right &#125; = el.getBoundingClientRect();
  const &#123; innerHeight, innerWidth &#125; = window;
  return partiallyVisible
    ? ((top &gt; 0 &amp;&amp; top &lt; innerHeight) || (bottom &gt; 0 &amp;&amp; bottom &lt; innerHeight)) &amp;&amp;
    ((left &gt; 0 &amp;&amp; left &lt; innerWidth) || (right &gt; 0 &amp;&amp; right &lt; innerWidth))
    : top &gt;= 0 &amp;&amp; left &gt;= 0 &amp;&amp; bottom &lt;= innerHeight &amp;&amp; right &lt;= innerWidth;
&#125;
</code></pre>
<h4 id="34-洗牌算法随机"><a href="#34-洗牌算法随机" class="headerlink" title="34.洗牌算法随机"></a>34.洗牌算法随机</h4><pre><code class="javascript">export const shuffle = (arr) =&gt; &#123;
  var result = [],
    random;
  while (arr.length &gt; 0) &#123;
    random = Math.floor(Math.random() * arr.length);
    result.push(arr[random])
    arr.splice(random, 1)
  &#125;
  return result;
&#125;
</code></pre>
<h4 id="35-劫持粘贴板"><a href="#35-劫持粘贴板" class="headerlink" title="35.劫持粘贴板"></a>35.劫持粘贴板</h4><pre><code class="javascript">export const copyTextToClipboard = (value) =&gt; &#123;
  var textArea = document.createElement(&quot;textarea&quot;);
  textArea.style.background = &#39;transparent&#39;;
  textArea.value = value;
  document.body.appendChild(textArea);
  textArea.select();
  try &#123;
    var successful = document.execCommand(&#39;copy&#39;);
  &#125; catch (err) &#123;
    console.log(&#39;Oops, unable to copy&#39;);
  &#125;
  document.body.removeChild(textArea);
&#125;
</code></pre>
<h4 id="36-判断类型集合"><a href="#36-判断类型集合" class="headerlink" title="36.判断类型集合"></a>36.判断类型集合</h4><pre><code class="javascript">export const checkStr = (str, type) =&gt; &#123;
  switch (type) &#123;
    case &#39;phone&#39;:   //手机号码
      return /^1[3|4|5|6|7|8|9][0-9]&#123;9&#125;$/.test(str);
    case &#39;tel&#39;:     //座机
      return /^(0\d&#123;2,3&#125;-\d&#123;7,8&#125;)(-\d&#123;1,4&#125;)?$/.test(str);
    case &#39;card&#39;:    //身份证
      return /(^\d&#123;15&#125;$)|(^\d&#123;18&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)/.test(str);
    case &#39;pwd&#39;:     //密码以字母开头，长度在6~18之间，只能包含字母、数字和下划线
      return /^[a-zA-Z]\w&#123;5,17&#125;$/.test(str)
    case &#39;postal&#39;:  //邮政编码
      return /[1-9]\d&#123;5&#125;(?!\d)/.test(str);
    case &#39;QQ&#39;:      //QQ号
      return /^[1-9][0-9]&#123;4,9&#125;$/.test(str);
    case &#39;email&#39;:   //邮箱
      return /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/.test(str);
    case &#39;money&#39;:   //金额(小数点2位)
      return /^\d*(?:\.\d&#123;0,2&#125;)?$/.test(str);
    case &#39;URL&#39;:     //网址
      return /(http|ftp|https):\/\/[\w\-_]+(\.[\w\-_]+)+([\w\-\.,@?^=%&amp;:/~\+#]*[\w\-\@?^=%&amp;/~\+#])?/.test(str)
    case &#39;IP&#39;:      //IP
      return /((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))/.test(str);
    case &#39;date&#39;:    //日期时间
      return /^(\d&#123;4&#125;)\-(\d&#123;2&#125;)\-(\d&#123;2&#125;) (\d&#123;2&#125;)(?:\:\d&#123;2&#125;|:(\d&#123;2&#125;):(\d&#123;2&#125;))$/.test(str) || /^(\d&#123;4&#125;)\-(\d&#123;2&#125;)\-(\d&#123;2&#125;)$/.test(str)
    case &#39;number&#39;:  //数字
      return /^[0-9]$/.test(str);
    case &#39;english&#39;: //英文
      return /^[a-zA-Z]+$/.test(str);
    case &#39;chinese&#39;: //中文
      return /^[\\u4E00-\\u9FA5]+$/.test(str);
    case &#39;lower&#39;:   //小写
      return /^[a-z]+$/.test(str);
    case &#39;upper&#39;:   //大写
      return /^[A-Z]+$/.test(str);
    case &#39;HTML&#39;:    //HTML标记
      return /&lt;(&quot;[^&quot;]*&quot;|&#39;[^&#39;]*&#39;|[^&#39;&quot;&gt;])*&gt;/.test(str);
    default:
      return true;
  &#125;
&#125;
</code></pre>
<h4 id="37-严格的身份证校验"><a href="#37-严格的身份证校验" class="headerlink" title="37.严格的身份证校验"></a>37.严格的身份证校验</h4><pre><code class="javascript">export const isCardID = (sId) =&gt; &#123;
  if (!/(^\d&#123;15&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)/.test(sId)) &#123;
    console.log(&#39;你输入的身份证长度或格式错误&#39;)
    return false
  &#125;
  //身份证城市
  var aCity = &#123; 11: &quot;北京&quot;, 12: &quot;天津&quot;, 13: &quot;河北&quot;, 14: &quot;山西&quot;, 15: &quot;内蒙古&quot;, 21: &quot;辽宁&quot;, 22: &quot;吉林&quot;, 23: &quot;黑龙江&quot;, 31: &quot;上海&quot;, 32: &quot;江苏&quot;, 33: &quot;浙江&quot;, 34: &quot;安徽&quot;, 35: &quot;福建&quot;, 36: &quot;江西&quot;, 37: &quot;山东&quot;, 41: &quot;河南&quot;, 42: &quot;湖北&quot;, 43: &quot;湖南&quot;, 44: &quot;广东&quot;, 45: &quot;广西&quot;, 46: &quot;海南&quot;, 50: &quot;重庆&quot;, 51: &quot;四川&quot;, 52: &quot;贵州&quot;, 53: &quot;云南&quot;, 54: &quot;西藏&quot;, 61: &quot;陕西&quot;, 62: &quot;甘肃&quot;, 63: &quot;青海&quot;, 64: &quot;宁夏&quot;, 65: &quot;新疆&quot;, 71: &quot;台湾&quot;, 81: &quot;香港&quot;, 82: &quot;澳门&quot;, 91: &quot;国外&quot; &#125;;
  if (!aCity[parseInt(sId.substr(0, 2))]) &#123;
    console.log(&#39;你的身份证地区非法&#39;)
    return false
  &#125;

  // 出生日期验证
  var sBirthday = (sId.substr(6, 4) + &quot;-&quot; + Number(sId.substr(10, 2)) + &quot;-&quot; + Number(sId.substr(12, 2))).replace(/-/g, &quot;/&quot;),
    d = new Date(sBirthday)
  if (sBirthday != (d.getFullYear() + &quot;/&quot; + (d.getMonth() + 1) + &quot;/&quot; + d.getDate())) &#123;
    console.log(&#39;身份证上的出生日期非法&#39;)
    return false
  &#125;

  // 身份证号码校验
  var sum = 0,
    weights = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2],
    codes = &quot;10X98765432&quot;
  for (var i = 0; i &lt; sId.length - 1; i++) &#123;
    sum += sId[i] * weights[i];
  &#125;
  var last = codes[sum % 11]; //计算出来的最后一位身份证号码
  if (sId[sId.length - 1] != last) &#123;
    console.log(&#39;你输入的身份证号非法&#39;)
    return false
  &#125;

  return true
&#125;
</code></pre>
<h4 id="38-随机数范围"><a href="#38-随机数范围" class="headerlink" title="38.随机数范围"></a>38.随机数范围</h4><pre><code class="javascript">export const random = (min, max) =&gt; &#123;
  if (arguments.length === 2) &#123;
    return Math.floor(min + Math.random() * ((max + 1) - min))
  &#125; else &#123;
    return null;
  &#125;
&#125;
</code></pre>
<h4 id="39-将阿拉伯数字翻译成中文的大写数字"><a href="#39-将阿拉伯数字翻译成中文的大写数字" class="headerlink" title="39.将阿拉伯数字翻译成中文的大写数字"></a>39.将阿拉伯数字翻译成中文的大写数字</h4><pre><code class="javascript">export const numberToChinese = (num) =&gt; &#123;
  var AA = new Array(&quot;零&quot;, &quot;一&quot;, &quot;二&quot;, &quot;三&quot;, &quot;四&quot;, &quot;五&quot;, &quot;六&quot;, &quot;七&quot;, &quot;八&quot;, &quot;九&quot;, &quot;十&quot;);
  var BB = new Array(&quot;&quot;, &quot;十&quot;, &quot;百&quot;, &quot;仟&quot;, &quot;萬&quot;, &quot;億&quot;, &quot;点&quot;, &quot;&quot;);
  var a = (&quot;&quot; + num).replace(/(^0*)/g, &quot;&quot;).split(&quot;.&quot;),
    k = 0,
    re = &quot;&quot;;
  for (var i = a[0].length - 1; i &gt;= 0; i--) &#123;
    switch (k) &#123;
      case 0:
        re = BB[7] + re;
        break;
      case 4:
        if (!new RegExp(&quot;0&#123;4&#125;//d&#123;&quot; + (a[0].length - i - 1) + &quot;&#125;$&quot;)
          .test(a[0]))
          re = BB[4] + re;
        break;
      case 8:
        re = BB[5] + re;
        BB[7] = BB[5];
        k = 0;
        break;
    &#125;
    if (k % 4 == 2 &amp;&amp; a[0].charAt(i + 2) != 0 &amp;&amp; a[0].charAt(i + 1) == 0)
      re = AA[0] + re;
    if (a[0].charAt(i) != 0)
      re = AA[a[0].charAt(i)] + BB[k % 4] + re;
    k++;
  &#125;

  if (a.length &gt; 1) // 加上小数部分(如果有小数部分)
  &#123;
    re += BB[6];
    for (var i = 0; i &lt; a[1].length; i++)
      re += AA[a[1].charAt(i)];
  &#125;
  if (re == &#39;一十&#39;)
    re = &quot;十&quot;;
  if (re.match(/^一/) &amp;&amp; re.length == 3)
    re = re.replace(&quot;一&quot;, &quot;&quot;);
  return re;
&#125;
</code></pre>
<h4 id="40-将数字转换为大写金额"><a href="#40-将数字转换为大写金额" class="headerlink" title="40.将数字转换为大写金额"></a>40.将数字转换为大写金额</h4><pre><code class="javascript">export const changeToChinese = (Num) =&gt; &#123;
  //判断如果传递进来的不是字符的话转换为字符
  if (typeof Num == &quot;number&quot;) &#123;
    Num = new String(Num);
  &#125;;
  Num = Num.replace(/,/g, &quot;&quot;) //替换tomoney()中的“,”
  Num = Num.replace(/ /g, &quot;&quot;) //替换tomoney()中的空格
  Num = Num.replace(/￥/g, &quot;&quot;) //替换掉可能出现的￥字符
  if (isNaN(Num)) &#123; //验证输入的字符是否为数字
    //alert(&quot;请检查小写金额是否正确&quot;);
    return &quot;&quot;;
  &#125;;
  //字符处理完毕后开始转换，采用前后两部分分别转换
  var part = String(Num).split(&quot;.&quot;);
  var newchar = &quot;&quot;;
  //小数点前进行转化
  for (var i = part[0].length - 1; i &gt;= 0; i--) &#123;
    if (part[0].length &gt; 10) &#123;
      return &quot;&quot;;
      //若数量超过拾亿单位，提示
    &#125;
    var tmpnewchar = &quot;&quot;
    var perchar = part[0].charAt(i);
    switch (perchar) &#123;
      case &quot;0&quot;:
        tmpnewchar = &quot;零&quot; + tmpnewchar;
        break;
      case &quot;1&quot;:
        tmpnewchar = &quot;壹&quot; + tmpnewchar;
        break;
      case &quot;2&quot;:
        tmpnewchar = &quot;贰&quot; + tmpnewchar;
        break;
      case &quot;3&quot;:
        tmpnewchar = &quot;叁&quot; + tmpnewchar;
        break;
      case &quot;4&quot;:
        tmpnewchar = &quot;肆&quot; + tmpnewchar;
        break;
      case &quot;5&quot;:
        tmpnewchar = &quot;伍&quot; + tmpnewchar;
        break;
      case &quot;6&quot;:
        tmpnewchar = &quot;陆&quot; + tmpnewchar;
        break;
      case &quot;7&quot;:
        tmpnewchar = &quot;柒&quot; + tmpnewchar;
        break;
      case &quot;8&quot;:
        tmpnewchar = &quot;捌&quot; + tmpnewchar;
        break;
      case &quot;9&quot;:
        tmpnewchar = &quot;玖&quot; + tmpnewchar;
        break;
    &#125;
    switch (part[0].length - i - 1) &#123;
      case 0:
        tmpnewchar = tmpnewchar + &quot;元&quot;;
        break;
      case 1:
        if (perchar != 0) tmpnewchar = tmpnewchar + &quot;拾&quot;;
        break;
      case 2:
        if (perchar != 0) tmpnewchar = tmpnewchar + &quot;佰&quot;;
        break;
      case 3:
        if (perchar != 0) tmpnewchar = tmpnewchar + &quot;仟&quot;;
        break;
      case 4:
        tmpnewchar = tmpnewchar + &quot;万&quot;;
        break;
      case 5:
        if (perchar != 0) tmpnewchar = tmpnewchar + &quot;拾&quot;;
        break;
      case 6:
        if (perchar != 0) tmpnewchar = tmpnewchar + &quot;佰&quot;;
        break;
      case 7:
        if (perchar != 0) tmpnewchar = tmpnewchar + &quot;仟&quot;;
        break;
      case 8:
        tmpnewchar = tmpnewchar + &quot;亿&quot;;
        break;
      case 9:
        tmpnewchar = tmpnewchar + &quot;拾&quot;;
        break;
    &#125;
    var newchar = tmpnewchar + newchar;
  &#125;
  //小数点之后进行转化
  if (Num.indexOf(&quot;.&quot;) != -1) &#123;
    if (part[1].length &gt; 2) &#123;
      // alert(&quot;小数点之后只能保留两位,系统将自动截断&quot;);
      part[1] = part[1].substr(0, 2)
    &#125;
    for (i = 0; i &lt; part[1].length; i++) &#123;
      tmpnewchar = &quot;&quot;
      perchar = part[1].charAt(i)
      switch (perchar) &#123;
        case &quot;0&quot;:
          tmpnewchar = &quot;零&quot; + tmpnewchar;
          break;
        case &quot;1&quot;:
          tmpnewchar = &quot;壹&quot; + tmpnewchar;
          break;
        case &quot;2&quot;:
          tmpnewchar = &quot;贰&quot; + tmpnewchar;
          break;
        case &quot;3&quot;:
          tmpnewchar = &quot;叁&quot; + tmpnewchar;
          break;
        case &quot;4&quot;:
          tmpnewchar = &quot;肆&quot; + tmpnewchar;
          break;
        case &quot;5&quot;:
          tmpnewchar = &quot;伍&quot; + tmpnewchar;
          break;
        case &quot;6&quot;:
          tmpnewchar = &quot;陆&quot; + tmpnewchar;
          break;
        case &quot;7&quot;:
          tmpnewchar = &quot;柒&quot; + tmpnewchar;
          break;
        case &quot;8&quot;:
          tmpnewchar = &quot;捌&quot; + tmpnewchar;
          break;
        case &quot;9&quot;:
          tmpnewchar = &quot;玖&quot; + tmpnewchar;
          break;
      &#125;
      if (i == 0) tmpnewchar = tmpnewchar + &quot;角&quot;;
      if (i == 1) tmpnewchar = tmpnewchar + &quot;分&quot;;
      newchar = newchar + tmpnewchar;
    &#125;
  &#125;
  //替换所有无用汉字
  while (newchar.search(&quot;零零&quot;) != -1)
    newchar = newchar.replace(&quot;零零&quot;, &quot;零&quot;);
  newchar = newchar.replace(&quot;零亿&quot;, &quot;亿&quot;);
  newchar = newchar.replace(&quot;亿万&quot;, &quot;亿&quot;);
  newchar = newchar.replace(&quot;零万&quot;, &quot;万&quot;);
  newchar = newchar.replace(&quot;零元&quot;, &quot;元&quot;);
  newchar = newchar.replace(&quot;零角&quot;, &quot;&quot;);
  newchar = newchar.replace(&quot;零分&quot;, &quot;&quot;);
  if (newchar.charAt(newchar.length - 1) == &quot;元&quot;) &#123;
    newchar = newchar + &quot;整&quot;
  &#125;
  return newchar;
&#125;
</code></pre>
<h4 id="41-判断一个元素是否在数组中"><a href="#41-判断一个元素是否在数组中" class="headerlink" title="41.判断一个元素是否在数组中"></a>41.判断一个元素是否在数组中</h4><pre><code class="javascript">export const contains = (arr, val) =&gt; &#123;
    return arr.indexOf(val) != -1 ? true : false;
&#125;
</code></pre>
<h4 id="42-数组排序-type-1：从小到大-2：从大到小-3：随机"><a href="#42-数组排序-type-1：从小到大-2：从大到小-3：随机" class="headerlink" title="42.数组排序, {type} 1：从小到大 2：从大到小 3：随机"></a>42.数组排序, {type} 1：从小到大 2：从大到小 3：随机</h4><pre><code class="javascript">export const sort = (arr, type = 1) =&gt; &#123;
  return arr.sort((a, b) =&gt; &#123;
    switch (type) &#123;
    case 1:
      return a - b;
    case 2:
      return b - a;
    case 3:
      return Math.random() - 0.5;
    default:
      return arr;
    &#125;
  &#125;)
&#125;
</code></pre>
<h4 id="43-数组去重"><a href="#43-数组去重" class="headerlink" title="43.数组去重"></a>43.数组去重</h4><pre><code class="javascript">export const unique = (arr) =&gt; &#123;
  if (Array.hasOwnProperty(&#39;from&#39;)) &#123;
    return Array.from(new Set(arr));
  &#125; else &#123;
    var n = &#123;&#125;, r = [];
    for (var i = 0; i &lt; arr.length; i++) &#123;
      if (!n[arr[i]]) &#123;
        n[arr[i]] = true;
        r.push(arr[i]);
      &#125;
    &#125;
    return r;
  &#125;
&#125;
</code></pre>
<h4 id="44-求两个集合的并集"><a href="#44-求两个集合的并集" class="headerlink" title="44.求两个集合的并集"></a>44.求两个集合的并集</h4><pre><code class="javascript">export const union = (a, b) =&gt; &#123;
  var newArr = a.concat(b);
  return this.unique(newArr); // 见43
&#125;
</code></pre>
<h4 id="45-求两个集合的交集"><a href="#45-求两个集合的交集" class="headerlink" title="45.求两个集合的交集"></a>45.求两个集合的交集</h4><pre><code class="javascript">export const intersect = (a, b) =&gt; &#123;
  var _this = this;
  a = this.unique(a);
  return this.map(a, function (o) &#123;
    return _this.contains(b, o) ? o : null; // contains方法见41
  &#125;);
&#125;
</code></pre>
<h4 id="46-删除数组指定元素"><a href="#46-删除数组指定元素" class="headerlink" title="46.删除数组指定元素"></a>46.删除数组指定元素</h4><pre><code class="javascript">export const remove = (arr, ele) =&gt; &#123;
  var index = arr.indexOf(ele);
  if (index &gt; -1) &#123;
    arr.splice(index, 1);
  &#125;
  return arr;
&#125;
</code></pre>
<h4 id="47-将类数组转换为数组"><a href="#47-将类数组转换为数组" class="headerlink" title="47.将类数组转换为数组"></a>47.将类数组转换为数组</h4><pre><code class="javascript">export const formArray = (ary) =&gt; &#123;
  var arr = [];
  if (Array.isArray(ary)) &#123;
    arr = ary;
  &#125; else &#123;
    arr = Array.prototype.slice.call(ary);
  &#125;;
  return arr;
&#125;
</code></pre>
<h4 id="48-找出数组最大值"><a href="#48-找出数组最大值" class="headerlink" title="48.找出数组最大值"></a>48.找出数组最大值</h4><pre><code class="javascript">export const max = (arr) =&gt; &#123;
  return Math.max.apply(null, arr);
&#125;
</code></pre>
<h4 id="49-找出数组最小值"><a href="#49-找出数组最小值" class="headerlink" title="49.找出数组最小值"></a>49.找出数组最小值</h4><pre><code class="javascript">export const min = (arr) =&gt; &#123;
    return Math.min.apply(null, arr);
&#125;
</code></pre>
<h4 id="50-数组求和"><a href="#50-数组求和" class="headerlink" title="50.数组求和"></a>50.数组求和</h4><pre><code class="javascript">export const sum = (arr) =&gt; &#123;
    return arr.reduce((pre, cur) =&gt; &#123;
        return pre + cur
    &#125;)
&#125;
</code></pre>
<h4 id="51-数组平均数"><a href="#51-数组平均数" class="headerlink" title="51.数组平均数"></a>51.数组平均数</h4><pre><code class="javascript">export const average = (arr) =&gt; &#123;
    return this.sum(arr) / arr.length
&#125;
</code></pre>
<h4 id="52-去除空格-type-1-所有空格-2-前后空格-3-前空格-4-后空格"><a href="#52-去除空格-type-1-所有空格-2-前后空格-3-前空格-4-后空格" class="headerlink" title="52.去除空格,type: 1-所有空格 2-前后空格 3-前空格 4-后空格"></a>52.去除空格,<code>type: 1-所有空格 2-前后空格 3-前空格 4-后空格</code></h4><pre><code class="javascript">export const trim = (str, type) =&gt; &#123;
  type = type || 1
  switch (type) &#123;
    case 1:
      return str.replace(/\s+/g, &quot;&quot;);
    case 2:
      return str.replace(/(^\s*)|(\s*$)/g, &quot;&quot;);
    case 3:
      return str.replace(/(^\s*)/g, &quot;&quot;);
    case 4:
      return str.replace(/(\s*$)/g, &quot;&quot;);
    default:
      return str;
  &#125;
&#125;
</code></pre>
<h4 id="53-字符转换-type-1-首字母大写-2：首字母小写-3：大小写转换-4：全部大写-5：全部小写"><a href="#53-字符转换-type-1-首字母大写-2：首字母小写-3：大小写转换-4：全部大写-5：全部小写" class="headerlink" title="53.字符转换,type: 1:首字母大写 2：首字母小写 3：大小写转换 4：全部大写 5：全部小写"></a>53.字符转换,type: 1:首字母大写 2：首字母小写 3：大小写转换 4：全部大写 5：全部小写</h4><pre><code class="javascript">export const changeCase = (str, type) =&gt; &#123;
  type = type || 4
  switch (type) &#123;
    case 1:
      return str.replace(/\b\w+\b/g, function (word) &#123;
        return word.substring(0, 1).toUpperCase() + word.substring(1).toLowerCase();

      &#125;);
    case 2:
      return str.replace(/\b\w+\b/g, function (word) &#123;
        return word.substring(0, 1).toLowerCase() + word.substring(1).toUpperCase();
      &#125;);
    case 3:
      return str.split(&#39;&#39;).map(function (word) &#123;
        if (/[a-z]/.test(word)) &#123;
          return word.toUpperCase();
        &#125; else &#123;
          return word.toLowerCase()
        &#125;
      &#125;).join(&#39;&#39;)
    case 4:
      return str.toUpperCase();
    case 5:
      return str.toLowerCase();
    default:
      return str;
  &#125;
&#125;
</code></pre>
<h4 id="54-检测密码强度"><a href="#54-检测密码强度" class="headerlink" title="54.检测密码强度"></a>54.检测密码强度</h4><pre><code class="javascript">export const checkPwd = (str) =&gt; &#123;
  var Lv = 0;
  if (str.length &lt; 6) &#123;
    return Lv
  &#125;
  if (/[0-9]/.test(str)) &#123;
    Lv++
  &#125;
  if (/[a-z]/.test(str)) &#123;
    Lv++
  &#125;
  if (/[A-Z]/.test(str)) &#123;
    Lv++
  &#125;
  if (/[\.|-|_]/.test(str)) &#123;
    Lv++
  &#125;
  return Lv;
&#125;
</code></pre>
<h4 id="55-函数节流器"><a href="#55-函数节流器" class="headerlink" title="55.函数节流器"></a>55.函数节流器</h4><pre><code class="javascript">export const debouncer = (fn, time, interval = 200) =&gt; &#123;
  if (time - (window.debounceTimestamp || 0) &gt; interval) &#123;
    fn &amp;&amp; fn();
    window.debounceTimestamp = time;
  &#125;
&#125;
</code></pre>
<h4 id="56-在字符串中插入新字符串"><a href="#56-在字符串中插入新字符串" class="headerlink" title="56.在字符串中插入新字符串"></a>56.在字符串中插入新字符串</h4><pre><code class="javascript">export const insertStr = (soure, index, newStr) =&gt; &#123;
  var str = soure.slice(0, index) + newStr + soure.slice(index);
  return str;
&#125;
</code></pre>
<h4 id="57-判断两个对象是否键值相同"><a href="#57-判断两个对象是否键值相同" class="headerlink" title="57.判断两个对象是否键值相同"></a>57.判断两个对象是否键值相同</h4><pre><code class="javascript">export const isObjectEqual = (a, b) =&gt; &#123;
  var aProps = Object.getOwnPropertyNames(a);
  var bProps = Object.getOwnPropertyNames(b);

  if (aProps.length !== bProps.length) &#123;
    return false;
  &#125;

  for (var i = 0; i &lt; aProps.length; i++) &#123;
    var propName = aProps[i];

    if (a[propName] !== b[propName]) &#123;
      return false;
    &#125;
  &#125;
  return true;
&#125;
</code></pre>
<h4 id="58-16进制颜色转RGBRGBA字符串"><a href="#58-16进制颜色转RGBRGBA字符串" class="headerlink" title="58.16进制颜色转RGBRGBA字符串"></a>58.16进制颜色转RGBRGBA字符串</h4><pre><code class="javascript">export const colorToRGB = (val, opa) =&gt; &#123;

  var pattern = /^(#?)[a-fA-F0-9]&#123;6&#125;$/; //16进制颜色值校验规则
  var isOpa = typeof opa == &#39;number&#39;; //判断是否有设置不透明度

  if (!pattern.test(val)) &#123; //如果值不符合规则返回空字符
    return &#39;&#39;;
  &#125;

  var v = val.replace(/#/, &#39;&#39;); //如果有#号先去除#号
  var rgbArr = [];
  var rgbStr = &#39;&#39;;

  for (var i = 0; i &lt; 3; i++) &#123;
    var item = v.substring(i * 2, i * 2 + 2);
    var num = parseInt(item, 16);
    rgbArr.push(num);
  &#125;

  rgbStr = rgbArr.join();
  rgbStr = &#39;rgb&#39; + (isOpa ? &#39;a&#39; : &#39;&#39;) + &#39;(&#39; + rgbStr + (isOpa ? &#39;,&#39; + opa : &#39;&#39;) + &#39;)&#39;;
  return rgbStr;
&#125;
</code></pre>
<h4 id="59-追加url参数"><a href="#59-追加url参数" class="headerlink" title="59.追加url参数"></a>59.追加url参数</h4><pre><code class="javascript">export const appendQuery = (url, key, value) =&gt; &#123;
  var options = key;
  if (typeof options == &#39;string&#39;) &#123;
    options = &#123;&#125;;
    options[key] = value;
  &#125;
  options = $.param(options);
  if (url.includes(&#39;?&#39;)) &#123;
    url += &#39;&amp;&#39; + options
  &#125; else &#123;
    url += &#39;?&#39; + options
  &#125;
  return url;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>js获取公网和内网ip</title>
    <url>/2021/05/27/js%E8%8E%B7%E5%8F%96%E5%85%AC%E7%BD%91%E5%92%8C%E5%86%85%E7%BD%91ip/</url>
    <content><![CDATA[<p>记录一下js获取公网和内网ip的方法</p>
<span id="more"></span>


<p>貌似至少一年前就被提出来过的了，就算用 SS 和 VPN 也无法避免 —— 只要你用的是 Chrome 或者 Firefox 浏览器。</p>
<p>之前看到过有关讨论，但是因为不会 javascript 就没关注，这个寒假补了下 javascript 和 jQuery ，倒是可以看懂一些了。</p>
<p>Demo: <a href="https://diafygi.github.io/webrtc-ips/">https://diafygi.github.io/webrtc-ips/</a></p>
<blockquote>
<p>What this does</p>
<p>Firefox and Chrome have implemented WebRTC that allow requests to STUN<br>servers be made that will return the local and public IP addresses for<br>the user. These request results are available to javascript, so you<br>can now obtain a users local and public IP addresses in javascript.<br>This demo is an example implementation of that.</p>
<p>Additionally, these STUN requests are made outside of the normal<br>XMLHttpRequest procedure, so they are not visible in the developer<br>console or able to be blocked by plugins such as AdBlockPlus or<br>Ghostery. This makes these types of requests available for online<br>tracking if an advertiser sets up a STUN server with a wildcard<br>domain.</p>
</blockquote>
<p>就是说 Firefox 和 Chrome 内建的 WebRTC 允许向 STUN 服务器查询用户的本地和公共 IP 地址。查询结果对 javascript 可用，所以可以使用 javascript 得到用户的本地和公网地址。</p>
<p><font color=red>但是需要特别注意的是需要打开浏览器的响应配置才可以获取到，操作见下图</font></p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210527174417119.png" alt="image-20210527174417119"></p>
<p>复制粘贴一下代码：</p>
<pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h4&gt;
  Demo for:
  &lt;a href=&quot;https://github.com/diafygi/webrtc-ips&quot;&gt;
    https://github.com/diafygi/webrtc-ips
  &lt;/a&gt;
&lt;/h4&gt;
&lt;p&gt;
  This demo secretly makes requests to STUN servers that can log your
  request. These requests do not show up in developer consoles and
  cannot be blocked by browser plugins (AdBlock, Ghostery, etc.).
&lt;/p&gt;
&lt;h4&gt;Your local IP addresses:&lt;/h4&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;h4&gt;Your public IP addresses:&lt;/h4&gt;
&lt;ul&gt;&lt;/ul&gt;
&lt;script&gt;
  //get the IP addresses associated with an account
  function getIPs(callback)&#123;
    var ip_dups = &#123;&#125;;
    //compatibility for firefox and chrome
    var RTCPeerConnection = window.RTCPeerConnection
      || window.mozRTCPeerConnection
      || window.webkitRTCPeerConnection;
    var useWebKit = !!window.webkitRTCPeerConnection;
    //bypass naive webrtc blocking
    if(!RTCPeerConnection)&#123;
      //create an iframe node
      var iframe = document.createElement(&#39;iframe&#39;);
      iframe.style.display = &#39;none&#39;;
      //invalidate content script
      iframe.sandbox = &#39;allow-same-origin&#39;;
      //insert a listener to cutoff any attempts to
      //disable webrtc when inserting to the DOM
      iframe.addEventListener(&quot;DOMNodeInserted&quot;, function(e)&#123;
        e.stopPropagation();
      &#125;, false);
      iframe.addEventListener(&quot;DOMNodeInsertedIntoDocument&quot;, function(e)&#123;
        e.stopPropagation();
      &#125;, false);
      //insert into the DOM and get that iframe&#39;s webrtc
      document.body.appendChild(iframe);
      var win = iframe.contentWindow;
      RTCPeerConnection = win.RTCPeerConnection
        || win.mozRTCPeerConnection
        || win.webkitRTCPeerConnection;
      useWebKit = !!win.webkitRTCPeerConnection;
    &#125;
    //minimal requirements for data connection
    var mediaConstraints = &#123;
      optional: [&#123;RtpDataChannels: true&#125;]
    &#125;;
    //firefox already has a default stun server in about:config
    //    media.peerconnection.default_iceservers =
    //    [&#123;&quot;url&quot;: &quot;stun:stun.services.mozilla.com&quot;&#125;]
    var servers = undefined;
    //add same stun server for chrome
    if(useWebKit)
      servers = &#123;iceServers: [&#123;urls: &quot;stun:stun.services.mozilla.com&quot;&#125;]&#125;;
    //construct a new RTCPeerConnection
    var pc = new RTCPeerConnection(servers, mediaConstraints);
    function handleCandidate(candidate)&#123;
      //match just the IP address
      var ip_regex = /([0-9]&#123;1,3&#125;(\.[0-9]&#123;1,3&#125;)&#123;3&#125;)/
      var ip_addr = ip_regex.exec(candidate)[1];
      //remove duplicates
      if(ip_dups[ip_addr] === undefined)
        callback(ip_addr);
      ip_dups[ip_addr] = true;
    &#125;
    //listen for candidate events
    pc.onicecandidate = function(ice)&#123;
      //skip non-candidate events
      if(ice.candidate)
        handleCandidate(ice.candidate.candidate);
    &#125;;
    //create a bogus data channel
    pc.createDataChannel(&quot;&quot;);
    //create an offer sdp
    pc.createOffer(function(result)&#123;
      //trigger the stun server request
      pc.setLocalDescription(result, function()&#123;&#125;, function()&#123;&#125;);
    &#125;, function()&#123;&#125;);
    //wait for a while to let everything done
    setTimeout(function()&#123;
      //read candidate info from local description
      var lines = pc.localDescription.sdp.split(&#39;\n&#39;);
      lines.forEach(function(line)&#123;
        if(line.indexOf(&#39;a=candidate:&#39;) === 0)
          handleCandidate(line);
      &#125;);
    &#125;, 1000);
  &#125;
  //insert IP addresses into the page
  getIPs(function(ip)&#123;
    var li = document.createElement(&quot;li&quot;);
    li.textContent = ip;
    //local IPs
    if (ip.match(/^(192\.168\.|169\.254\.|10\.|172\.(1[6-9]|2\d|3[01]))/))
      document.getElementsByTagName(&quot;ul&quot;)[0].appendChild(li);
    //assume the rest are public IPs
    else
      document.getElementsByTagName(&quot;ul&quot;)[1].appendChild(li);
  &#125;);
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p><strong>Wooyun 上一些 js 的其他用法：</strong></p>
<blockquote>
<p>获得flash版本 <a href="http://jsbin.com/rukirayuca">http://jsbin.com/rukirayuca</a><br>获得java版本 <a href="http://jsbin.com/cabirudale">http://jsbin.com/cabirudale</a><br>获得插件列表 <a href="http://jsbin.com/vejujatuxa">http://jsbin.com/vejujatuxa</a><br>获得内网IP <a href="http://jsbin.com/riyisavura">http://jsbin.com/riyisavura</a><br>扫描HTTP端口 <a href="http://jsbin.com/ziwununivo">http://jsbin.com/ziwununivo</a><br>扫描WEB容器 <a href="http://jsbin.com/piwemaquwa">http://jsbin.com/piwemaquwa</a><br>扫描FTP端口 <a href="http://jsbin.com/kulahicide">http://jsbin.com/kulahicide</a></p>
</blockquote>
<p>转载于:<a href="http://0x0d.im/archives/get-local-and-real-public-IP-via-WebRTC.html">通过WebRTC获取内网和公网真实IP地址</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>markerdown-Typora编辑器</title>
    <url>/2021/04/12/markerdown-Typora%E7%BC%96%E8%BE%91%E5%99%A8/</url>
    <content><![CDATA[<p>Typora 是一款支持实时预览的 Markdown 文本编辑器</p>
<span id="more"></span>

<h2 id="一-了解Markdown"><a href="#一-了解Markdown" class="headerlink" title="一 了解Markdown"></a>一 了解Markdown</h2><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/iconfinder_markdown_298823.png" alt="img"></p>
<p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p>
<p>Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。</p>
<p>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</p>
<p>Markdown 编写的文档后缀为 <strong>.md</strong>, <strong>.markdown</strong>。</p>
<p>更多详细内容可参照<a href="https://www.runoob.com/markdown/md-tutorial.html">菜鸟教程:Markdown</a></p>
<h2 id="二-书写工具"><a href="#二-书写工具" class="headerlink" title="二 书写工具"></a>二 书写工具</h2><p>Typora官方网站:<a href="https://www.typora.io/">https://www.typora.io/</a></p>
<p>Typora中文网站:<a href="https://www.typora.net/">https://www.typora.net/</a></p>
<p>国内码云上的发行版本:<a href="https://gitee.com/typora-mirror/Typora-Mirror/releases">https://gitee.com/typora-mirror/Typora-Mirror/releases</a></p>
<h2 id="三-语法"><a href="#三-语法" class="headerlink" title="三 语法"></a>三 语法</h2><h4 id="1-字体编辑"><a href="#1-字体编辑" class="headerlink" title="1. 字体编辑"></a>1. 字体编辑</h4><h5 id="1-1-标题"><a href="#1-1-标题" class="headerlink" title="1.1 标题"></a>1.1 标题</h5><pre><code class="text"># 一级标题        快捷键Ctrl+1

## 二级标题       快捷键Ctrl+2

### 三级标题      快捷键Ctrl+3

#### 四级标题     快捷键Ctrl+4

##### 五级标题    快捷键Ctrl+5

###### 六级标题   快捷键Ctrl+6
</code></pre>
<p><code>三级标题 快捷键Ctrl+3</code></p>
<h5 id="1-2-字体大小"><a href="#1-2-字体大小" class="headerlink" title="1.2 字体大小"></a>1.2 字体大小</h5><pre><code class="text">快捷键：Ctrl+数字  或 Ctrl+加减号  或  ### （几个#表示几级标题，同上）
</code></pre>
<h5 id="1-3-字体加粗"><a href="#1-3-字体加粗" class="headerlink" title="1.3 字体加粗"></a>1.3 字体加粗</h5><pre><code class="text">快捷键：Ctrl+b
示 例：**加粗内容**
</code></pre>
<h5 id="1-4-斜体"><a href="#1-4-斜体" class="headerlink" title="1.4 斜体"></a>1.4 斜体</h5><pre><code class="text">快捷键：ctrl+i
示 例：*斜体*
</code></pre>
<h5 id="1-5-删除线"><a href="#1-5-删除线" class="headerlink" title="1.5 删除线"></a>1.5 删除线</h5><pre><code class="text">快捷键：alt+shift+5
示 例：~~删除的内容~~
</code></pre>
<h5 id="1-6-下划线"><a href="#1-6-下划线" class="headerlink" title="1.6 下划线"></a>1.6 下划线</h5><pre><code class="text">快捷键：Ctrl+u
示 例：&lt;u&gt;下划线内容&lt;/u&gt;
</code></pre>
<h5 id="1-7-文本居中"><a href="#1-7-文本居中" class="headerlink" title="1.7 文本居中"></a>1.7 文本居中</h5><pre><code class="text">操作：&lt;center&gt;居中内容&lt;/center&gt;
</code></pre>
<h5 id="1-8-脚注"><a href="#1-8-脚注" class="headerlink" title="1.8 脚注"></a>1.8 脚注</h5><pre><code class="text">操作：这块有个脚注[^脚注]
     [^脚注]:填写脚注的内容
示例：有一个github网址[^1]
     [^1]:https://github.com/
</code></pre>
<p>注意：使用1.9~1.11功能前，请先在 文件 - &gt; 偏好设置 中的Markdwn中勾选对应的功能，然后重启软件，就可以用了，操作如下图所示</p>
<p><img src="https://pic1.zhimg.com/80/v2-ef6d571b0f47c9e4fc20b7f2dee47a68_720w.jpg" alt="img"></p>
<h5 id="1-9-上标"><a href="#1-9-上标" class="headerlink" title="1.9 上标"></a>1.9 上标</h5><pre><code class="text">使用这个特性，请先在文件 -&gt; 偏好设置 中的Markdwn选择开启。
操作：^ + 字体 + ^
示例：X^2^
</code></pre>
<h5 id="1-10-下标"><a href="#1-10-下标" class="headerlink" title="1.10 下标"></a>1.10 下标</h5><pre><code class="text">操作：~ + 字体 + ~
示例：H~2~O
     X~long\ text~
</code></pre>
<h5 id="1-11-文字高亮"><a href="#1-11-文字高亮" class="headerlink" title="1.11 文字高亮"></a>1.11 文字高亮</h5><pre><code class="text">操作：==高亮文字==
</code></pre>
<h4 id="2-列表"><a href="#2-列表" class="headerlink" title="2. 列表"></a>2. 列表</h4><h5 id="2-1-有序列表"><a href="#2-1-有序列表" class="headerlink" title="2.1 有序列表"></a>2.1 有序列表</h5><pre><code class="text">操作：数字+英文小数点(.)+空格
示例：1. list1
     2. list2
</code></pre>
<h5 id="2-2-无序列表"><a href="#2-2-无序列表" class="headerlink" title="2.2 无序列表"></a>2.2 无序列表</h5><pre><code class="text">操作：- +空格 或 * + 空格
示例： - list1
      - list2
</code></pre>
<h4 id="3-插入"><a href="#3-插入" class="headerlink" title="3. 插入"></a>3. 插入</h4><h5 id="3-1-插入代码块"><a href="#3-1-插入代码块" class="headerlink" title="3.1 插入代码块"></a>3.1 插入代码块</h5><pre><code class="text">快捷键：shift+~~~
</code></pre>
<h5 id="3-2-插入数学公式"><a href="#3-2-插入数学公式" class="headerlink" title="3.2 插入数学公式"></a>3.2 插入数学公式</h5><pre><code class="text">操作：$$ + enter
示例：$$ + enter后输入11+12，结果如下所示
</code></pre>
<h5 id="3-3-插入引用"><a href="#3-3-插入引用" class="headerlink" title="3.3 插入引用"></a>3.3 插入引用</h5><pre><code class="text">操作：&gt; + 空格
示例：&gt; + 空格后，输入 引用的内容，结果如下所示
 
</code></pre>
<h5 id="3-4-插入链接"><a href="#3-4-插入链接" class="headerlink" title="3.4 插入链接"></a>3.4 插入链接</h5><pre><code class="text">操 作:Ctrl+k弹出后，输入 [输入标题名](输入链接地址) 即可
示 例1：[百度一下，你就知道](https://www.baidu.com/)
示 例2：这是 [百度一下，你就知道](https://www.baidu.com/ &quot;百度&quot;) 的链接.  
示 例3：这是 [github][1] 的链接.  
       [1]: https://github.com/ &quot;github&quot;
ps：按住ctrl点击链接可直接打开
</code></pre>
<h5 id="3-5-插入注释"><a href="#3-5-插入注释" class="headerlink" title="3.5 插入注释"></a>3.5 插入注释</h5><pre><code class="text">操作：[^文字]：文字
示例：[^1]：文献1
</code></pre>
<h5 id="3-6-插入表格"><a href="#3-6-插入表格" class="headerlink" title="3.6 插入表格"></a>3.6 插入表格</h5><pre><code class="text">快捷键：ctrl+t
示 例：按完快捷键后，弹出下图，选择对应的行和列，点击确定即可。
</code></pre>
<p><img src="https://pic2.zhimg.com/80/v2-f44eb3bc4a5a55951c7efcb2eb11f72d_720w.jpg" alt="img"></p>
<h5 id="3-7-插入图片"><a href="#3-7-插入图片" class="headerlink" title="3.7 插入图片"></a>3.7 插入图片</h5><pre><code class="text">操作：直接拖动  或 ctrl+shift+i(相对路径地址)
示例：![](C:\1.jpg)
</code></pre>
<h5 id="3-8-插入分隔符"><a href="#3-8-插入分隔符" class="headerlink" title="3.8 插入分隔符"></a>3.8 插入分隔符</h5><pre><code class="text">操作：--- + enter  或者 *** + enter
</code></pre>
<h5 id="3-9-插入表情"><a href="#3-9-插入表情" class="headerlink" title="3.9 插入表情"></a>3.9 插入表情</h5><pre><code class="text">操作： ：+ 单词 +:
示例： :smile:
      :cry:
</code></pre>
<h5 id="3-10-插入目录"><a href="#3-10-插入目录" class="headerlink" title="3.10 插入目录"></a>3.10 插入目录</h5><p>操作：[toc]+enter</p>
<h5 id="3-11-公式内换行"><a href="#3-11-公式内换行" class="headerlink" title="3.11 公式内换行"></a>3.11 公式内换行</h5><p>操作：\</p>
<h5 id="3-12-公式内左对齐"><a href="#3-12-公式内左对齐" class="headerlink" title="3.12 公式内左对齐"></a>3.12 公式内左对齐</h5><p>操作：在公式最开始加\begin{aligned}，然后每个等号前加&amp;，即&amp;=，每一行用\换行，然后最后一句输完后\end{aligned}</p>
<p>实例：\begin{aligned}d(x,y)&amp;=\sqrt{(x_1-y_1)^2+(x_2-y_2)^2+\dots+(x_n-y_n)^2}\&amp;=\sqrt{\sum_{i=1}^{n}{(x_i-y_i)^2}} \end{aligned}</p>
<p>公式如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210324155609.png"></p>
<h5 id="3-13-矩阵表示"><a href="#3-13-矩阵表示" class="headerlink" title="3.13 矩阵表示"></a>3.13 矩阵表示</h5><p>操作：<code>\begin&#123;matrix&#125;</code>和<code>\end&#123;matrix&#125;</code>说明在它们之间的是矩阵<br><code>1 &amp; 2 &amp; 3\\</code>表示第一行的元素，其中用<code>&amp;</code>来分割每一个元素，用<code>\\</code>来换行<br>实例: \left[\begin{matrix} 1 &amp; 2 &amp; 3\ 4 &amp; 5 &amp; 6 \end{matrix}\right]</p>
<p><img src="https://raw.githubusercontent.com/tangyuxian/blog_image/master/PicGo/20210324155643.png"></p>
<h5 id="3-14-希腊字母表示"><a href="#3-14-希腊字母表示" class="headerlink" title="3.14 希腊字母表示"></a>3.14 希腊字母表示</h5><p><img src="https://pic3.zhimg.com/80/v2-68922903c83e504e3e3e4efd5b7327fa_720w.jpg" alt="img"></p>
<h5 id="3-15-箭头表示"><a href="#3-15-箭头表示" class="headerlink" title="3.15 箭头表示"></a>3.15 箭头表示</h5><p><img src="https://pic3.zhimg.com/80/v2-42ff8eb3a827056b16b2133f58009abe_720w.jpg" alt="img"></p>
<h5 id="3-16-公式大全"><a href="#3-16-公式大全" class="headerlink" title="3.16 公式大全"></a>3.16 公式大全</h5><p><img src="https://pic2.zhimg.com/80/v2-2f57dd9499cba748a39be06d2104fe21_720w.jpg" alt="img"></p>
<h5 id="3-17-二进制运算-相关符号"><a href="#3-17-二进制运算-相关符号" class="headerlink" title="3.17 二进制运算/相关符号"></a>3.17 二进制运算/相关符号</h5><p><img src="https://pic3.zhimg.com/80/v2-fd7827f7c554e1f2c6d9a356f868a0fe_720w.jpg" alt="img"></p>
<h5 id="3-18-空格表示"><a href="#3-18-空格表示" class="headerlink" title="3.18 空格表示"></a>3.18 空格表示</h5><p>在公式中如果需要有空格，可以用+空格的方式来实现</p>
<p>实例：max \ a</p>
<h5 id="3-19-花括号表示"><a href="#3-19-花括号表示" class="headerlink" title="3.19 花括号表示"></a>3.19 花括号表示</h5><p>为了美观，常用公式中可能会用到花括号</p>
<p>实例：c(u)=\begin{cases} \sqrt\frac{1}{N}，u=0\ \sqrt\frac{2}{N}， u\neq0\end{cases}</p>
<p>结果展示如下：</p>
<p><img src="https://www.zhihu.com/equation?tex=c(u)=%5Cbegin%7Bcases%7D+%5Csqrt%5Cfrac%7B1%7D%7BN%7D%EF%BC%8Cu=0%5C%5C+%5Csqrt%5Cfrac%7B2%7D%7BN%7D%EF%BC%8C+u%5Cneq0%5Cend%7Bcases%7D+" alt="[公式]"></p>
<hr>
<p>语法来源:<a href="https://zhuanlan.zhihu.com/p/90561228">知乎文章:Typora的安装和语法</a></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Markerdown</tag>
      </tags>
  </entry>
  <entry>
    <title>markerdown-高效上传图片工具PicGo</title>
    <url>/2021/04/12/markerdown-%E9%AB%98%E6%95%88%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E5%B7%A5%E5%85%B7PicGo/</url>
    <content><![CDATA[<p>在使用Typora时可随时便捷上传图片</p>
<span id="more"></span>

<h2 id="一-应用场景"><a href="#一-应用场景" class="headerlink" title="一 应用场景"></a>一 应用场景</h2><p>在编写markerdown文档时,需要插入图片,因文档最终上传到云端,所以需要将网络图片地址插入其中;</p>
<p><strong>PicGo</strong>工具在Typora中内置并集成,可使用该插件将本地或其它网络图片直接上传到云端</p>
<h2 id="二-下载地址"><a href="#二-下载地址" class="headerlink" title="二 下载地址"></a>二 下载地址</h2><p>官方网站:<a href="https://molunerfinn.com/PicGo/">https://molunerfinn.com/PicGo/</a></p>
<p>下载地址:<a href="https://github.com/Molunerfinn/picgo/releases">https://github.com/Molunerfinn/picgo/releases</a></p>
<h2 id="三-使用方式"><a href="#三-使用方式" class="headerlink" title="三 使用方式"></a>三 使用方式</h2><h4 id="1下载PicGo并配置"><a href="#1下载PicGo并配置" class="headerlink" title="1下载PicGo并配置"></a>1下载PicGo并配置</h4><p>​    下载安装完毕后,参照<a href="https://picgo.github.io/PicGo-Doc/zh/guide/config.html">文档</a>进行配置,如图是糖糖的配置项</p>
<p>​    <img src="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210324162152.png" alt="image-20210324162149788"></p>
<p>这里推荐<a href="https://picgo.github.io/PicGo-Doc/zh/guide/config.html#github%E5%9B%BE%E5%BA%8A">github配置</a>,设定的自定义域名为<strong>jsdelivr</strong>可享有免费的CDN加速</p>
<p><a href="https://cdn.jsdelivr.net/gh/%60[github%E7%94%A8%E6%88%B7%E5%90%8D]%60/%60[%E4%BB%93%E5%BA%93%E5%90%8D]%60@%60[%E7%89%88%E6%9C%AC%E5%88%86%E6%94%AF]%60">https://cdn.jsdelivr.net/gh/`[github用户名]`/`[仓库名]`@`[版本分支]`</a></p>
<p>例如:<a href="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest">https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest</a></p>
<h4 id="2-在Typora中配置"><a href="#2-在Typora中配置" class="headerlink" title="2 在Typora中配置"></a>2 在Typora中配置</h4><img src="https://cdn.jsdelivr.net/gh/tangyuxian/blog_image@latest/PicGo/20210324162544.png" alt="image-20210324162542890"  />

<p>在<code>文件</code>-&gt;<code>偏好设置</code>-&gt;<code>图像</code>中配置<code>上传服务设定</code></p>
<p>按照图中配置即可</p>
<p>插件配置方式可参照<a href="https://support.typora.io/Upload-Image/">官方文档</a>进行配置</p>
<h4 id="3-使用"><a href="#3-使用" class="headerlink" title="3 使用"></a>3 使用</h4><p>日常编辑时,可随时截图,在Typora处粘贴,右键图片便可看到<code>上传图片</code>功能,上传成功后会自动替换本地图片路径;</p>
<p>在网上复制文章中,会夹带网络地址的图片,部分网络图片因为<strong>防盗链</strong>技术,无法在自己的网站上显示这些图,同样可以在图片上右键选择<code>上传图片</code>,将图片上传到自己的服务源,一劳永逸</p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>Markerdown</tag>
      </tags>
  </entry>
  <entry>
    <title>关于我</title>
    <url>/2021/03/11/me/</url>
    <content><![CDATA[<span id="more"></span>

<p>姓名：侯湃<br>现居：沈阳<br>GitHub: houpai<br>QQ: 784950731<br>微信: houpai314</p>
]]></content>
  </entry>
  <entry>
    <title>node自定义环境变量NODE_ENV</title>
    <url>/2021/04/26/node%E8%87%AA%E5%AE%9A%E4%B9%89%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8FNODE_ENV/</url>
    <content><![CDATA[<p>记录一下如何指定node自定义环境变量NODE_ENV…</p>
<span id="more"></span>

<p>  在很多前端项目中都需要配置node的环境变量，通常在package.json的scripts命令内容和webpack配置文件中可以看到NODE_ENV这个变量，值一般为production或者product，也有人简写为’dev’或’prod’。</p>
<h4 id="NODE-ENV的作用"><a href="#NODE-ENV的作用" class="headerlink" title="NODE_ENV的作用"></a>NODE_ENV的作用</h4><p>​     通常这个变量用来区分开发与生产环境，加载不同的配置。</p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>​    node中有全局变量process表示当前node进程，process.env包含着关于系统环境的信息。但是process.env中并不存在NODE_ENV这个东西，NODE_ENV只是一个用户自定义的变量，当我们在服务启动时配置NODE_ENV,或在代码中给process.env.NODE_ENV赋值，js便能通过process.env.NODE_ENV获取信息，通常可以在package.json的scripts里设置</p>
<pre><code class="bash">  &quot;scripts&quot;: &#123;
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,
    &quot;start&quot;: &quot;SET NODE_ENV=production &amp;&amp; node index.js&quot;
  &#125;,
</code></pre>
<p>一般也可以在webpack配置文件中对NODE_ENV作默认处理</p>
<pre><code class="bash">NODE_ENV: process.env.NODE_ENV || &#39;development&#39;
</code></pre>
<h4 id="不同平台下的设置"><a href="#不同平台下的设置" class="headerlink" title="不同平台下的设置"></a>不同平台下的设置</h4><p>在类unix系统和安装并使用了bash的windows的系统上:</p>
<pre><code class="bash">&quot;EXPORT  NODE_ENV=production &amp;&amp; webpack --config build/webpack.config.js&quot;
</code></pre>
<p>在windows系统上：</p>
<pre><code class="bash">&quot;SET NODE_ENV=production &amp;&amp; webpack --config build/webpack.config.js&quot;
</code></pre>
<p>还可以引用第三方插件<a href="https://www.npmjs.com/package/cross-env">cross-env</a>，兼容win和linux</p>
<pre><code class="bash">  &quot;scripts&quot;: &#123;
        &quot;start&quot;: &quot;cross-env NODE_ENV=production  node index.js&quot;
  &#125;
</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>package.json详解</title>
    <url>/2021/07/22/package.json%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<p>package.json详解…</p>
<span id="more"></span>

<p>前言</p>
<p>平常在工作中，对<code>package.json</code>这个文件的接触非常非常少。</p>
<ul>
<li>一些同学可能还会看一下script里面有什么命令，执行了哪些方法。</li>
<li>又或者了解一下<code>dependencies</code>和<code>devDependencies</code></li>
<li>其他大部分的同学可能直接就<code>npm i</code>和<code>npm start</code>就开始工作了。</li>
<li>但是<code>package.json</code>的魅力远不止如此</li>
<li>今天就和我一起探索一下这个项目中不可或缺的——<code>package.json</code>吧！</li>
</ul>
<h2 id="由浅入深-核心内容"><a href="#由浅入深-核心内容" class="headerlink" title="由浅入深-核心内容"></a>由浅入深-核心内容</h2><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>手摸手新建一个空的package.json</p>
<p><img src="https://pic2.zhimg.com/v2-2ce64dabf60bff516c8bb918d726ad85_b.jpg" alt="img"></p>
<ol>
<li><code>npm init</code></li>
<li><code>上万个回车</code></li>
</ol>
<p>或者直接执行</p>
<ol>
<li><code>npm init -y</code></li>
<li>其意思就是全部都略过，和我们上面的无数个回车的效果一样</li>
</ol>
<p>先看看上面有的东西。</p>
<pre><code class="json">&#123;
  &quot;name&quot;: &quot;package.json&quot;, # 项目名称
  &quot;version&quot;: &quot;1.0.0&quot;, # 项目版本（格式：大版本.次要版本.小版本）
  &quot;description&quot;: &quot;&quot;, # 项目描述
  &quot;main&quot;: &quot;index.js&quot;, # 入口文件
  &quot;scripts&quot;: &#123; # 指定运行脚本命令的 npm 命令行缩写
    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;
  &#125;,
  &quot;keywords&quot;: [], # 关键词
  &quot;author&quot;: &quot;&quot;, # 作者
  &quot;license&quot;: &quot;ISC&quot; # 许可证
&#125;
</code></pre>
<h2 id="scripts（快捷脚本）"><a href="#scripts（快捷脚本）" class="headerlink" title="scripts（快捷脚本）"></a>scripts（快捷脚本）</h2><ul>
<li><code>scripts</code> 字段是 <code>package.json</code> 中的一种元数据功能，它接受一个对象，对象的属性为可以通过 <code>npm run</code>运行的脚本，值为实际运行的命令（通常是终端命令），如：</li>
</ul>
<pre><code class="text">&quot;scripts&quot;: &#123;
  &quot;start&quot;: &quot;node index.js&quot;
&#125;,
复制代码
</code></pre>
<ul>
<li>将终端命令放入 <code>scripts</code> 字段，既可以记录它们又可以实现轻松重用。</li>
</ul>
<h2 id="dependencies-amp-devDependencies（项目依赖）"><a href="#dependencies-amp-devDependencies（项目依赖）" class="headerlink" title="dependencies &amp; devDependencies（项目依赖）"></a>dependencies &amp; devDependencies（项目依赖）</h2><ul>
<li><code>dependencies</code> 字段指定了项目运行所依赖的模块</li>
<li>可以理解为我们的项目在生产环境运行中要用到的东西。</li>
<li>比如说我们常用的<code>antd</code>只能哪个代码块就会用到里面的组件，所以要放到<code>dependencies</code>里面去</li>
<li><code>devDependencies</code>字段指定了项目开发所需要的模块</li>
<li>开发环境会用到的东西，比如说webpack。我们打包的时候会用到，但是项目运行的时候却用不到，所以只需要放到<code>devDependencies</code>中去就好了</li>
<li>类似的<code>eslint</code>之类的</li>
</ul>
<p>这里重点谈一下这些版本号直接的差异</p>
<h3 id="1-1-1"><a href="#1-1-1" class="headerlink" title="~1.1.1"></a>~1.1.1</h3><ul>
<li><code>~1.2.3</code>:= <code>&gt;=1.2.3 &lt;1.(2+1).0</code>:=<code>&gt;=1.2.3 &lt;1.3.0-0</code></li>
<li><code>~1.2</code>:= <code>&gt;=1.2.0 &lt;1.(2+1).0</code>:= <code>&gt;=1.2.0 &lt;1.3.0-0</code>(同<code>1.2.x</code>)</li>
<li><code>~1</code>:= <code>&gt;=1.0.0 &lt;(1+1).0.0</code>:= <code>&gt;=1.0.0 &lt;2.0.0-0</code>(同<code>1.x</code>)</li>
<li><code>~0.2.3</code>:= <code>&gt;=0.2.3 &lt;0.(2+1).0</code>:=<code>&gt;=0.2.3 &lt;0.3.0-0</code></li>
<li><code>~0.2</code>:= <code>&gt;=0.2.0 &lt;0.(2+1).0</code>:= <code>&gt;=0.2.0 &lt;0.3.0-0</code>(同<code>0.2.x</code>)</li>
<li><code>~0</code>:= <code>&gt;=0.0.0 &lt;(0+1).0.0</code>:= <code>&gt;=0.0.0 &lt;1.0.0-0</code>(同<code>0.x</code>)</li>
<li><code>~1.2.3-beta.2</code>:=<code>&gt;=1.2.3-beta.2 &lt;1.3.0-0</code>请注意，<code>1.2.3</code>版本中的预发布将被允许，如果它们大于或等于<code>beta.2</code>. 所以，<code>1.2.3-beta.4</code>会被允许，但 <code>1.2.4-beta.2</code>不会，因为它是不同<code>[major, minor, patch]</code>元组的预发布。</li>
</ul>
<h3 id="1-1-1-1"><a href="#1-1-1-1" class="headerlink" title="^1.1.1"></a>^1.1.1</h3><p>允许不修改<code>[major, minor, patch]</code>元组中最左边的非零元素的更改 。换句话说，这允许版本<code>1.0.0</code>及以上版本的补丁和次要更新，版本的补丁更新<code>0.X &gt;=0.1.0</code>，以及版本的<em>不</em>更新<code>0.0.X</code>。</p>
<p>许多作者将<code>0.x</code>版本视为<code>x</code>主要的“重大变化”指标。</p>
<p>当作者可能在发行版<code>0.2.4</code>和<code>0.3.0</code>发行版之间进行重大更改时，插入符范围是理想的，这是一种常见做法。但是，它假定和之间<em>不会</em>有重大变化 。根据通常观察到的做法，它允许进行假定为附加（但不会破坏）的更改。<code>0.2.4``0.2.5</code></p>
<ul>
<li><code>^1.2.3</code> := <code>&gt;=1.2.3 &lt;2.0.0-0</code></li>
<li><code>^0.2.3</code> := <code>&gt;=0.2.3 &lt;0.3.0-0</code></li>
<li><code>^0.0.3</code> := <code>&gt;=0.0.3 &lt;0.0.4-0</code></li>
<li><code>^1.2.3-beta.2</code>:=<code>&gt;=1.2.3-beta.2 &lt;2.0.0-0</code>请注意，<code>1.2.3</code>版本中的预发布将被允许，如果它们大于或等于<code>beta.2</code>. 所以，<code>1.2.3-beta.4</code>会被允许，但 <code>1.2.4-beta.2</code>不会，因为它是不同<code>[major, minor, patch]</code>元组的预发布。</li>
<li><code>^0.0.3-beta</code>:=<code>&gt;=0.0.3-beta &lt;0.0.4-0</code> 请注意，<em>仅</em>允许<code>0.0.3</code>版本中的预发布 ，如果它们大于或等于. 所以，会被允许。<code>beta``0.0.3-pr.2</code></li>
</ul>
<p>解析插入符范围时，缺失<code>patch</code>值会被减为数字<code>0</code>，但即使主要版本和次要版本都是<code>0</code>.</p>
<ul>
<li><code>1.2.x</code> := <code>&gt;=1.2.0 &lt;1.3.0-0</code></li>
<li><code>^0.0.x</code> := <code>&gt;=0.0.0 &lt;0.1.0-0</code></li>
<li><code>^0.0</code> := <code>&gt;=0.0.0 &lt;0.1.0-0</code></li>
</ul>
<p>缺失值<code>minor</code>和<code>patch</code>值将脱糖为零，但也允许在这些值内具有灵活性，即使主要版本为零。</p>
<ul>
<li><code>^1.x</code> := <code>&gt;=1.0.0 &lt;2.0.0-0</code></li>
<li><code>^0.x</code> := <code>&gt;=0.0.0 &lt;1.0.0-0</code></li>
</ul>
<h3 id="1-1-x"><a href="#1-1-x" class="headerlink" title="1.1.x"></a>1.1.x</h3><p>任何的<code>X</code>，<code>x</code>或<code>*</code>可被用来“立场在”在数字值中的一个<code>[major, minor, patch]</code>元组。</p>
<ul>
<li><code>*</code>:= <code>&gt;=0.0.0</code>(任何版本都满足)</li>
<li><code>1.x</code>:= <code>&gt;=1.0.0 &lt;2.0.0-0</code>(匹配主要版本)</li>
<li><code>1.2.x</code>:= <code>&gt;=1.2.0 &lt;1.3.0-0</code>（匹配主要和次要版本）</li>
</ul>
<p>部分版本范围被视为 X 范围，因此特殊字符实际上是可选的。</p>
<ul>
<li><code>&quot;&quot;</code>（空字符串）:= <code>*</code>:=<code>&gt;=0.0.0</code></li>
<li><code>1</code>:= <code>1.x.x</code>:=<code>&gt;=1.0.0 &lt;2.0.0-0</code></li>
<li><code>1.2</code>:= <code>1.2.x</code>:=<code>&gt;=1.2.0 &lt;1.3.0-0</code></li>
</ul>
<h3 id="1-1-1-1-1-2"><a href="#1-1-1-1-1-2" class="headerlink" title="1.1.1 - 1.1.2"></a>1.1.1 - 1.1.2</h3><p>指定一个包含集。</p>
<ul>
<li><code>1.2.3 - 2.3.4</code> := <code>&gt;=1.2.3 &lt;=2.3.4</code></li>
</ul>
<p>如果部分版本作为包含范围中的第一个版本提供，则缺失的部分将替换为零。</p>
<ul>
<li><code>1.2 - 2.3.4</code> := <code>&gt;=1.2.0 &lt;=2.3.4</code></li>
</ul>
<p>如果部分版本作为包含范围中的第二个版本提供，则接受以元组提供的部分开头的所有版本，但不会大于提供的元组部分。</p>
<ul>
<li><code>1.2.3 - 2.3</code> := <code>&gt;=1.2.3 &lt;2.4.0-0</code></li>
<li><code>1.2.3 - 2</code> := <code>&gt;=1.2.3 &lt;3.0.0-0</code></li>
</ul>
<h2 id="engines（指定项目-node-版本）"><a href="#engines（指定项目-node-版本）" class="headerlink" title="engines（指定项目 node 版本）"></a>engines（指定项目 node 版本）</h2><ul>
<li>有时候，新拉一个项目的时候，由于和其他开发使用的 <code>node</code> 版本不同，导致会出现很多奇奇怪怪的问题（如某些依赖安装报错、依赖安装完项目跑步起来等）。</li>
<li>为了实现项目开箱即用的伟大理想，这时候可以使用 <code>package.json</code> 的 <code>engines</code> 字段来指定项目 node 版本：</li>
</ul>
<pre><code class="text">&quot;engines&quot;: &#123;
   &quot;node&quot;: &quot;&gt;= 8.16.0&quot;
&#125;,
复制代码
</code></pre>
<ul>
<li>该字段也可以指定适用的 <code>npm</code> 版本：</li>
</ul>
<pre><code class="text">&quot;engines&quot;: &#123;
   &quot;npm&quot;: &quot;&gt;= 6.9.0&quot;
 &#125;,
复制代码
</code></pre>
<ul>
<li>需要注意的是，engines属性仅起到一个说明的作用，当用户版本不符合指定值时也不影响依赖的安装。</li>
</ul>
<h2 id="os（模块适用系统）"><a href="#os（模块适用系统）" class="headerlink" title="os（模块适用系统）"></a>os（模块适用系统）</h2><ul>
<li>假如我们开发了一个模块，只能跑在 <code>darwin</code> 系统下，我们需要保证 <code>windows</code> 用户不会安装到该模块，从而避免发生不必要的错误。</li>
<li>这时候，使用 <code>os</code> 属性则可以帮助我们实现以上的需求，该属性可以指定模块适用系统的系统，或者指定不能安装的系统黑名单（当在系统黑名单中的系统中安装模块则会报错）：</li>
</ul>
<pre><code class="text">&quot;os&quot; : [ &quot;darwin&quot;, &quot;linux&quot; ] # 适用系统
&quot;os&quot; : [ &quot;!win32&quot; ] # 黑名单
复制代码
</code></pre>
<blockquote>
<p>Tips：在 <code>node</code> 环境下可以使用 <code>process.platform</code> 来判断操作系统。</p>
</blockquote>
<h2 id="cpu（指定模块适用-cpu-架构）"><a href="#cpu（指定模块适用-cpu-架构）" class="headerlink" title="cpu（指定模块适用 cpu 架构）"></a>cpu（指定模块适用 cpu 架构）</h2><ul>
<li>和上面的 <code>os</code> 字段类似，我们可以用 <code>cpu</code> 字段更精准的限制用户安装环境：</li>
</ul>
<pre><code class="text">&quot;cpu&quot; : [ &quot;x64&quot;, &quot;ia32&quot; ] # 适用 cpu
&quot;cpu&quot; : [ &quot;!arm&quot;, &quot;!mips&quot; ] # 黑名单
复制代码
</code></pre>
<blockquote>
<p>Tips：在 <code>node</code> 环境下可以使用 <code>process.arch</code> 来判断 <code>cpu</code> 架构。</p>
</blockquote>
<h2 id="private（定义私有模块）"><a href="#private（定义私有模块）" class="headerlink" title="private（定义私有模块）"></a>private（定义私有模块）</h2><ul>
<li>一般公司的非开源项目，都会设置 <code>private</code> 属性的值为 <code>true</code>，这是因为 <code>npm</code> 拒绝发布私有模块，通过设置该字段可以防止私有模块被无意间发布出去。</li>
</ul>
<h2 id="次重要（可以当百科全书）"><a href="#次重要（可以当百科全书）" class="headerlink" title="次重要（可以当百科全书）"></a>次重要（可以当百科全书）</h2><h2 id="name（项目名称）"><a href="#name（项目名称）" class="headerlink" title="name（项目名称）"></a>name（项目名称）</h2><ul>
<li>这个名称和你要发布项目到<code>npm</code>上的有关系。</li>
<li>假如你不想发布的话那这个<code>name</code>和<code>version</code>就不是必填项了</li>
</ul>
<p>名字就是你的东西叫什么。（name名称）和（version版本号）构成一个唯一的标识符。</p>
<p>名称的一些规则：</p>
<ul>
<li>名称必须小于或等于 214 个字符。这包括范围包的范围。</li>
<li>作用域包的名称可以以点或下划线开头。这在没有范围的情况下是不允许的。</li>
<li>新包的名称中不得包含大写字母。</li>
<li>该名称最终成为 URL 的一部分、命令行上的参数和文件夹名称。因此，名称不能包含任何非 URL 安全字符。</li>
</ul>
<p>一些技巧：</p>
<ul>
<li>不要使用与核心节点模块相同的名称。</li>
<li>不要在名称中加入“js”或“node”。假设它是 js，因为您正在编写 package.json 文件，并且您可以使用“engines”字段指定引擎。（见下文。）</li>
<li>该名称可能会作为参数传递给 require()，因此它应该是简短的，但也应该具有合理的描述性。</li>
<li>您可能需要检查 npm 注册表以查看是否已经存在使用该名称的内容，以免过于依赖它。 <a href="https://link.zhihu.com/?target=https://www.npmjs.com/">https://www.npmjs.com/</a></li>
<li>方法一：直接到npm官网去搜</li>
<li>方法二：<code>npm view &lt;packageName&gt;</code></li>
</ul>
<p>如果模块存在，可以查看该模块的一些基本信息：</p>
<p><img src="https://pic2.zhimg.com/80/v2-0fc7f64ddf2a372fe1696cd65867f311_720w.jpg" alt="img"></p>
<p>如果该模块名从未被使用过，则会抛出 404 错误：</p>
<p><img src="https://pic4.zhimg.com/80/v2-802ccfcfefdbc897cf630949cc1658eb_720w.jpg" alt="img"></p>
<h2 id="version（版本号）"><a href="#version（版本号）" class="headerlink" title="version（版本号）"></a>version（版本号）</h2><ul>
<li><code>version</code>和<code>name</code>组成在<code>npm</code>内部的一个唯一标识符。</li>
<li>假如你不想发布的话那这个<code>name</code>和<code>version</code>就不是必填项了</li>
<li>版本必须可由<a href="https://link.zhihu.com/?target=https://github.com/npm/node-semver">node-semver</a>解析 ，它作为依赖项与 npm 捆绑在一起。（<code>npm install semver</code>自己使用。）</li>
<li>我们可以执行以下命令查看模块的版本：</li>
</ul>
<pre><code class="js">npm view &lt;packageName&gt; version # 查看某个模块的最新版本
npm view &lt;packageName&gt; versions # 查看某个模块的所有历史版本
</code></pre>
<ul>
<li><code>npm view &lt;packageName&gt; version</code></li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-0a5272fc9bd8588952194e3c025d0955_720w.png" alt="img"></p>
<ul>
<li><code>npm view &lt;packageName&gt; versions</code></li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-ed74b209c798284b2745ac0af1e175b9_720w.png" alt="img"></p>
<h2 id="description（项目描述）"><a href="#description（项目描述）" class="headerlink" title="description（项目描述）"></a>description（项目描述）</h2><p>此文档是您需要了解的有关 <code>package.json</code> 文件中所需内容的全部信息。它必须是实际的 <code>JSON</code>，而不仅仅是 <code>JavaScript</code>对象文字。</p>
<p>本文档中描述的许多行为受 中描述的配置设置的影响<code>config</code>。</p>
<h2 id="keywords"><a href="#keywords" class="headerlink" title="keywords"></a>keywords</h2><p>把关键字放进去。它是一个字符串数组。这有助于人们发现您的包裹，因为它在 中列出<code>npm search</code>。</p>
<h2 id="homepage（项目主页）"><a href="#homepage（项目主页）" class="headerlink" title="homepage（项目主页）"></a>homepage（项目主页）</h2><p>项目主页的<code>url</code>。</p>
<p>例子：</p>
<pre><code class="json">&quot;homepage&quot; ：“https://github.com/owner/project#readme”
</code></pre>
<h2 id="bugs（问题追踪）"><a href="#bugs（问题追踪）" class="headerlink" title="bugs（问题追踪）"></a>bugs（问题追踪）</h2><p>项目问题跟踪器的 url 和/或应报告问题的电子邮件地址。这些对于遇到包裹问题的人很有帮助。</p>
<p>它应该是这样的：</p>
<pre><code class="json">&#123;
  &quot;url&quot; : &quot;https://github.com/owner/project/issues&quot; ,  
  &quot;email&quot; ：&quot;project@hostname.com&quot;
&#125;
</code></pre>
<p>您可以指定一个或两个值。如果您只想提供一个 url，您可以将“bugs”的值指定为一个简单的字符串而不是一个对象。</p>
<p>如果提供了<code>url</code>，它将被<code>npm bugs</code>命令使用。</p>
<h2 id="license（执照）"><a href="#license（执照）" class="headerlink" title="license（执照）"></a>license（执照）</h2><p>你应该为你的包指定一个许可证，以便人们知道他们如何被允许使用它，以及你对它施加的任何限制。</p>
<p>如果您使用的是 BSD-2-Clause 或 MIT 等通用许可证，请为您使用的许可证添加当前的<code>SPDX</code> 许可证标识符，如下所示：</p>
<pre><code class="json">&#123;
  &quot;license&quot; : &quot;BSD-3-Clause&quot;
&#125;
</code></pre>
<p>您可以查看<a href="https://link.zhihu.com/?target=https://spdx.org/licenses/">SPDX 许可证 ID 的完整列表</a>。理想情况下，您应该选择 <a href="https://link.zhihu.com/?target=https://opensource.org/licenses/alphabetical">OSI</a>批准的一种。</p>
<p>如果您的软件包在多个通用许可下获得许可，请使用<a href="https://link.zhihu.com/?target=https://www.npmjs.com/package/spdx">SPDX 许可表达式语法版本 2.0 string</a>，如下所示：</p>
<pre><code class="json">&#123;
  &quot;license&quot; : &quot;(ISC OR GPL-3.0)&quot;
&#125;
</code></pre>
<p>如果您使用的许可证尚未分配<code>SPDX</code> 标识符，或者您使用的是自定义许可证，请使用如下字符串值：</p>
<pre><code class="json">&#123;
  &quot;license&quot; : &quot;SEE LICENSE IN &lt;filename&gt;&quot;
&#125;
</code></pre>
<p>然后包含一个<code>&lt;filename&gt;</code>在包的顶层命名的文件。</p>
<p>一些旧包使用许可证对象或包含许可证对象数组的“许可证”属性：</p>
<pre><code class="json">// 无效的元数据
&#123;
  &quot;license&quot; : &#123;
    &quot;type&quot; : &quot;ISC&quot;,
    &quot;url&quot; : &quot;https://opensource.org/licenses/ISC&quot;
  &#125;
&#125;

// 无效的元数据
&#123;
  &quot;licenses&quot; : [
    &#123;
      &quot;type&quot;: &quot;MIT&quot;,
      &quot;url&quot;: &quot;https://www.opensource.org/licenses/mit-license.php&quot;
    &#125;,
    &#123;
      &quot;type&quot;: &quot;Apache-2.0&quot;,
      &quot;url&quot;: &quot;https://opensource.org/licenses/apache2.0.php&quot;
    &#125;
  ]
&#125;
</code></pre>
<p>这些样式现在已被弃用。相反，使用<code>SPDX</code>表达式，如下所示：</p>
<pre><code class="json">&#123;
  &quot;license&quot;: &quot;ISC&quot;
&#125;
&#123;
  &quot;license&quot;: &quot;(MIT OR Apache-2.0)&quot;
&#125;
</code></pre>
<p>最后，如果您不希望根据任何条款授予他人使用私有或未发布包的权利：</p>
<pre><code class="json">&#123;
  &quot;license&quot;: &quot;UNLICENSED&quot;
&#125;
</code></pre>
<p>还要考虑设置<code>&quot;private&quot;: true</code>以防止意外发布。</p>
<h2 id="author-contributors（作者和贡献者）"><a href="#author-contributors（作者和贡献者）" class="headerlink" title="author, contributors（作者和贡献者）"></a>author, contributors（作者和贡献者）</h2><p>“作者”是一个人。“贡献者”是一群人。“person”是一个带有“name”字段和可选的“url”和“email”的对象，像这样：</p>
<pre><code class="json">&#123;
  &quot;name&quot; : &quot;Barney Rubble&quot;,
  &quot;email&quot; : &quot;b@rubble.com&quot;,
  &quot;url&quot; : &quot;http://barnyrubble.tumblr.com/&quot;
&#125;
</code></pre>
<p>或者，您可以将其全部缩短为一个字符串，然后 npm 将为您解析它：</p>
<pre><code class="json">&#123;
  &quot;author&quot;: &quot;Barney Rubble &lt;b@rubble.com&gt; (http://barnyrubble.tumblr.com/)&quot;
&#125;
</code></pre>
<p>email 和 url 都是可选的。</p>
<p>npm 还使用您的 npm 用户信息设置顶级“维护者”字段。</p>
<h2 id="funding（档案）"><a href="#funding（档案）" class="headerlink" title="funding（档案）"></a>funding（档案）</h2><p>可选<code>files</code>字段是一个文件模式数组，它描述了当您的包作为依赖项安装时要包含的条目。文件模式遵循与 类似的语法<code>.gitignore</code>，但相反：包含文件、目录或 glob 模式（<code>*</code>,<code>**/*</code>等）将使该文件在打包时包含在 tarball 中。省略该字段将使其默认为<code>[&quot;*&quot;]</code>，这意味着它将包含所有文件。</p>
<p>一些特殊的文件和目录也会被包含或排除，无论它们是否存在于<code>files</code>数组中（见下文）。</p>
<p>您还可以<code>.npmignore</code>在包的根目录或子目录中提供一个文件，以防止文件被包含在内。在包的根目录中，它不会覆盖“文件”字段，但在子目录中会覆盖。该<code>.npmignore</code>文件就像一个<code>.gitignore</code>. 如果有一个<code>.gitignore</code>文件，并且<code>.npmignore</code>丢失了，<code>.gitignore</code>则将使用 的内容。</p>
<p>文件包含了“的package.json＃文件”栏中<em>无法</em>通过排除<code>.npmignore</code>或<code>.gitignore</code>。</p>
<p>无论设置如何，始终包含某些文件：</p>
<ul>
<li><code>package.json</code></li>
<li><code>README</code></li>
<li><code>CHANGES</code>/ <code>CHANGELOG</code>/<code>HISTORY</code></li>
<li><code>LICENSE</code> / <code>LICENCE</code></li>
<li><code>NOTICE</code></li>
<li>“主要”字段中的文件</li>
</ul>
<p><code>README</code>, <code>CHANGES</code>, <code>LICENSE</code>&amp;<code>NOTICE</code>可以有任何大小写和扩展名。</p>
<p>相反，一些文件总是被忽略：</p>
<ul>
<li><code>.git</code></li>
<li><code>CVS</code></li>
<li><code>.svn</code></li>
<li><code>.hg</code></li>
<li><code>.lock-wscript</code></li>
<li><code>.wafpickle-N</code></li>
<li><code>.*.swp</code></li>
<li><code>.DS_Store</code></li>
<li><code>._*</code></li>
<li><code>npm-debug.log</code></li>
<li><code>.npmrc</code></li>
<li><code>node_modules</code></li>
<li><code>config.gypi</code></li>
<li><code>*.orig</code></li>
<li><code>package-lock.json</code>（ <code>npm-shrinkwrap.json</code>如果您希望发布，请使用）</li>
</ul>
<h2 id="main（主要入口）"><a href="#main（主要入口）" class="headerlink" title="main（主要入口）"></a>main（主要入口）</h2><ul>
<li><code>main</code> 字段是 <code>package.json</code> 中的另一种元数据功能，它可以用来指定加载的入口文件。假如你的项目是一个 <code>npm</code> 包，当用户安装你的包后，<code>require(&#39;my-module&#39;)</code> 返回的是 <code>main</code> 字段中所列出文件的 <code>module.exports</code> 属性。</li>
<li>当不指定<code>main</code> 字段时，默认值是模块根目录下面的<code>index.js</code> 文件。</li>
</ul>
<h2 id="browser（浏览器）"><a href="#browser（浏览器）" class="headerlink" title="browser（浏览器）"></a>browser（浏览器）</h2><p>如果您的模块打算在客户端使用，则应使用浏览器字段而不是主字段。这有助于提示用户它可能依赖于 Node.js 模块中不可用的原语。（例如 <code>window</code>）</p>
<h2 id="bin（自定义命令）"><a href="#bin（自定义命令）" class="headerlink" title="bin（自定义命令）"></a>bin（自定义命令）</h2><p>很多包都有一个或多个他们想要安装到 PATH 中的可执行文件。npm 使这变得非常简单（实际上，它使用此功能来安装“npm”可执行文件。）</p>
<p>要使用它，请<code>bin</code>在 package.json 中提供一个字段，它是命令名到本地文件名的映射。在安装时，npm 会将该文件符号链接到<code>prefix/bin</code>全局安装或<code>./node_modules/.bin/</code>本地安装。</p>
<p>给大家看看我自己做一个简单的demo：</p>
<pre><code class="json">&#123;
  &quot;name&quot;: &quot;react-cli-library&quot;,
  &quot;version&quot;: &quot;0.0.2&quot;,
  &quot;description&quot;: &quot;&quot;,
  &quot;bin&quot;: &#123;
    &quot;react-cli&quot;: &quot;./bin/index.js&quot;
  &#125;,
&#125;
</code></pre>
<p>我的名称叫做react-cli-library。</p>
<p>所以，<code>npm i react-cli-library</code></p>
<p><img src="https://pic2.zhimg.com/80/v2-6777e0ac0b1d8514f8e755de0c05e77d_720w.jpg" alt="img"></p>
<p>安装完成之后，执行react-cli就会有一些命令，他会执行我的根目录底下<code>./bin/index.js</code>这个文件。</p>
<p><img src="https://pic2.zhimg.com/80/v2-90bb4956b588876b561e5dfaf0f8d629_720w.jpg" alt="img"></p>
<p>虽然我的项目名称是：<code>react-cli-library</code>。但是我执行的内容却是<code>react-cli</code>，这个取决于bin的内容</p>
<h2 id="man（快捷入口）"><a href="#man（快捷入口）" class="headerlink" title="man（快捷入口）"></a>man（快捷入口）</h2><p>用来给Linux下的man命令查找文档地址，是个单一文件或者文件数组。 如果是单一文件，安装完成后，他就是man + 的结果，和此文件名无关，例如：</p>
<pre><code class="text">&#123;
  &quot;name&quot;: &quot;foo&quot;,
  &quot;version&quot;: &quot;1.2.3&quot;,
  &quot;description&quot;: &quot;A packaged foo fooer for fooing foos&quot;,
  &quot;main&quot;: &quot;foo.js&quot;,
  &quot;man&quot;: &quot;./man/doc.1&quot;
&#125;
</code></pre>
<p>通过man foo命令会得到 ./man/doc.1 文件的内容。 如果man文件名称不是以模块名称开头的，安装的时候会给加上模块名称前缀。因此，下面这段配置：</p>
<pre><code class="text">&#123;
  &quot;name&quot;: &quot;foo&quot;,
  &quot;version&quot;: &quot;1.2.3&quot;,
  &quot;description&quot;: &quot;A packaged foo fooer for fooing foos&quot;,
  &quot;main&quot;: &quot;foo.js&quot;,
  &quot;man&quot;: [
    &quot;./man/foo.1&quot;,
    &quot;./man/bar.1&quot;
  ]
&#125;
</code></pre>
<p>会创建一些文件来作为man foo和man foo-bar命令的结果。 man文件必须以数字结尾，或者如果被压缩了，以.gz结尾。数字表示文件将被安装到man的哪个部分。</p>
<pre><code class="text">&#123;
  &quot;name&quot;: &quot;foo&quot;,
  &quot;version&quot;: &quot;1.2.3&quot;,
  &quot;description&quot;: &quot;A packaged foo fooer for fooing foos&quot;,
  &quot;main&quot;: &quot;foo.js&quot;,
  &quot;man&quot;: [
    &quot;./man/foo.1&quot;,
    &quot;./man/foo.2&quot;
  ]
&#125;
</code></pre>
<p>会创建 man foo 和 man 2 foo 两条命令。</p>
<h2 id="directories（目录）"><a href="#directories（目录）" class="headerlink" title="directories（目录）"></a>directories（目录）</h2><p>CommonJS <a href="https://link.zhihu.com/?target=http://wiki.commonjs.org/wiki/Packages/1.0">Packages</a>规范详细说明了一些可以使用<code>directories</code>对象指示包结构的方法。如果您查看<a href="https://link.zhihu.com/?target=https://registry.npmjs.org/npm/latest">npm 的 package.json</a>，您会看到它包含 doc、lib 和 man 目录。</p>
<p>将来，这些信息可能会以其他创造性的方式使用。</p>
<h3 id="目录-bin"><a href="#目录-bin" class="headerlink" title="目录.bin"></a>目录.bin</h3><p>如果在 中指定<code>bin</code>目录<code>directories.bin</code>，则将添加该文件夹中的所有文件。</p>
<p>由于<code>bin</code>指令的工作方式，同时指定<code>bin</code>路径和设置<code>directories.bin</code>是错误的。如果要指定单个文件，请使用<code>bin</code>，对于现有<code>bin</code> 目录中的所有文件，请使用<code>directories.bin</code>。</p>
<h3 id="目录-man"><a href="#目录-man" class="headerlink" title="目录.man"></a>目录.man</h3><p>一个充满手册页的文件夹。Sugar 通过遍历文件夹来生成“man”数组。</p>
<h2 id="repository（代码存储位置）"><a href="#repository（代码存储位置）" class="headerlink" title="repository（代码存储位置）"></a>repository（代码存储位置）</h2><p>指定代码所在的位置。这对想要贡献的人很有帮助。如果 git repo 在 GitHub 上，那么该<code>npm docs</code> 命令将能够找到您。</p>
<p>像这样做：</p>
<pre><code class="json">&#123;
  &quot;repository&quot;: &#123;
    &quot;type&quot;: &quot;git&quot;,
    &quot;url&quot;: &quot;https://github.com/npm/cli.git&quot;
  &#125;
&#125;
</code></pre>
<p>URL 应该是一个公开可用的（可能是只读的）url，可以直接传递给 VCS 程序，无需任何修改。它不应该是您放入浏览器的 html 项目页面的 url。是给电脑用的。</p>
<p>对于 GitHub、GitHub gist、Bitbucket 或 GitLab 存储库，您可以使用与 相同的快捷语法<code>npm install</code>：</p>
<pre><code class="json">&#123;
  &quot;repository&quot;: &quot;npm/npm&quot;,

  &quot;repository&quot;: &quot;github:user/repo&quot;,

  &quot;repository&quot;: &quot;gist:11081aaa281&quot;,

  &quot;repository&quot;: &quot;bitbucket:user/repo&quot;,

  &quot;repository&quot;: &quot;gitlab:user/repo&quot;
&#125;
</code></pre>
<p>如果<code>package.json</code>您的包的 不在根目录中（例如，如果它是 monorepo 的一部分），您可以指定它所在的目录：</p>
<pre><code class="json">&#123;
  &quot;repository&quot;: &#123;
    &quot;type&quot;: &quot;git&quot;,
    &quot;url&quot;: &quot;https://github.com/facebook/react.git&quot;,
    &quot;directory&quot;: &quot;packages/react-dom&quot;
  &#125;
&#125;
</code></pre>
<h2 id="config（配置内容）"><a href="#config（配置内容）" class="headerlink" title="config（配置内容）"></a>config（配置内容）</h2><p>“config”对象可用于设置在升级过程中持续存在的包脚本中使用的配置参数。例如，如果一个包具有以下内容：</p>
<pre><code class="json">&#123;
  &quot;name&quot;: &quot;foo&quot;,
  &quot;config&quot;: &#123;
    &quot;port&quot;: &quot;8080&quot;
  &#125;
&#125;
</code></pre>
<p>然后有一个“开始”命令，然后引用 <code>npm_package_config_port</code>环境变量，然后用户可以通过执行<code>npm config set foo:port 8001</code>.</p>
<p>查看<code>config</code>和<code>scripts</code>了解更多关于包配置的信息。</p>
<h2 id="peerDependencies（对等依赖）"><a href="#peerDependencies（对等依赖）" class="headerlink" title="peerDependencies（对等依赖）"></a>peerDependencies（对等依赖）</h2><p>在某些情况下，您希望表达您的包与主机工具或库的兼容性，而不必执行<code>require</code>此主机的操作。这通常称为<em>插件</em>。值得注意的是，您的模块可能会公开主机文档所预期和指定的特定接口。</p>
<p>例如：</p>
<pre><code class="json">&#123;
  &quot;name&quot;: &quot;tea-latte&quot;,
  &quot;version&quot;: &quot;1.3.5&quot;,
  &quot;peerDependencies&quot;: &#123;
    &quot;tea&quot;: &quot;2.x&quot;
  &#125;
&#125;
</code></pre>
<p>这确保您的软件包<code>tea-latte</code>只能与主机软件包的第二个主要版本<em>一起</em>安装<code>tea</code>。<code>npm install tea-latte</code>可能会产生以下依赖图：</p>
<pre><code class="bash">├── tea-latte@1.3.5
└── tea@2.2.0
</code></pre>
<p>在 npm 版本 3 到 6 中，<code>peerDependencies</code>不会自动安装，如果在树中发现对等依赖项的无效版本，则会发出警告。由于NPM V7的，peerDependencies<em>被</em> 默认安装。</p>
<p>如果无法正确解析树，尝试安装具有冲突要求的另一个插件可能会导致错误。因此，请确保您的插件要求尽可能广泛，而不是将其锁定为特定的补丁版本。</p>
<p>假设主机符合<a href="https://link.zhihu.com/?target=https://semver.org/">semver</a>，只有主机包的主要版本中的更改才会破坏您的插件。因此，如果您使用过主机包的每个 1.x 版本，请使用<code>&quot;^1.0&quot;</code>或<code>&quot;1.x&quot;</code> 来表达这一点。如果您依赖 1.5.2 中引入的功能，请使用 <code>&quot;^1.5.2&quot;</code>.</p>
<h2 id="peerDependenciesMeta（捆绑依赖）"><a href="#peerDependenciesMeta（捆绑依赖）" class="headerlink" title="peerDependenciesMeta（捆绑依赖）"></a>peerDependenciesMeta（捆绑依赖）</h2><p>这定义了在发布包时将捆绑的包名称数组。</p>
<p>如果您需要在本地保留 npm 包或通过单个文件下载使它们可用，您可以通过在<code>bundledDependencies</code> 数组中指定包名称并执行<code>npm pack</code>.</p>
<p>例如：</p>
<p>如果我们像这样定义 package.json：</p>
<pre><code class="json">&#123;
  &quot;name&quot;: &quot;awesome-web-framework&quot;,
  &quot;version&quot;: &quot;1.0.0&quot;,
  &quot;bundledDependencies&quot;: [
    &quot;renderized&quot;,
    &quot;super-streams&quot;
  ]
&#125;
</code></pre>
<p>我们可以<code>awesome-web-framework-1.0.0.tgz</code>通过运行获取文件<code>npm pack</code>。此文件包含的依赖关系<code>renderized</code>，并<code>super-streams</code>可以通过执行安装在一个新的项目<code>npm install awesome-web-framework-1.0.0.tgz</code>。请注意，包名称不包含任何版本，因为该信息在<code>dependencies</code>.</p>
<p>如果这是拼写<code>&quot;bundleDependencies&quot;</code>，那么这也很荣幸。</p>
<h2 id="optionalDependencies（可选依赖项）"><a href="#optionalDependencies（可选依赖项）" class="headerlink" title="optionalDependencies（可选依赖项）"></a>optionalDependencies（可选依赖项）</h2><p>如果可以使用依赖项，但如果找不到或安装失败，您希望 npm 继续，那么您可以将其放入 <code>optionalDependencies</code>对象中。这是包名称到版本或 url 的映射，就像<code>dependencies</code>对象一样。不同之处在于构建失败不会导致安装失败。运行<code>npm install --no-optional</code>将阻止安装这些依赖项。</p>
<p>处理缺少依赖项仍然是您的程序的责任。例如，这样的事情：</p>
<pre><code class="js">try &#123;
  var foo = require(&#39;foo&#39;)
  var fooVersion = require(&#39;foo/package.json&#39;).version
&#125; catch (er) &#123;
  foo = null
&#125;
if ( notGoodFooVersion(fooVersion) ) &#123;
  foo = null
&#125;

// .. then later in your program ..

if (foo) &#123;
  foo.doFooThings()
&#125;
</code></pre>
<p>中的条目<code>optionalDependencies</code>将覆盖 中的同名条目 <code>dependencies</code>，因此通常最好只放在一个地方。</p>
<h2 id="publishConfig（发布配置）"><a href="#publishConfig（发布配置）" class="headerlink" title="publishConfig（发布配置）"></a>publishConfig（发布配置）</h2><p>这是一组将在发布时使用的配置值。如果您想设置标记、注册表或访问权限，这将特别方便，这样您就可以确保给定的包没有被标记为“最新”、未发布到全局公共注册表或默认情况下范围模块是私有的。</p>
<p>查看<code>config</code>可覆盖的配置选项列表。</p>
<h2 id="workspaces（工作区）"><a href="#workspaces（工作区）" class="headerlink" title="workspaces（工作区）"></a>workspaces（工作区）</h2><p>可选<code>workspaces</code>字段是一个文件模式数组，它描述了本地文件系统内的位置，安装客户端应该查找这些位置以找到需要符号链接到顶级文件夹的每个<a href="https://link.zhihu.com/?target=https://docs.npmjs.com/cli/v7/using-npm/workspaces">工作区</a><code>node_modules</code>。</p>
<p>它可以描述要用作工作区的文件夹的直接路径，也可以定义将解析为这些相同文件夹的 glob。</p>
<p>在以下示例中，<code>./packages</code>只要文件夹中包含有效<code>package.json</code>文件，位于文件夹内的所有文件夹 都将被视为工作区 ：</p>
<pre><code class="json">&#123;
  &quot;name&quot;: &quot;workspace-example&quot;,
  &quot;workspaces&quot;: [
    &quot;./packages/*&quot;
  ]
&#125;
</code></pre>
<p>有关<code>workspaces</code>更多示例，请参见。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文几乎是全网最全的package.json的讲解了。一些常用的和不常用的都有区分，不常用的可以当百科全书查一下，面试主要也是会问一些主要内容。</p>
<blockquote>
<p>如果觉得本文对你有帮助的话，请点个赞。</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://link.zhihu.com/?target=https://docs.npmjs.com/cli/v7/configuring-npm/package-json%23workspaces">https://docs.npmjs.com/cli/v7/c</a></p>
<p>转载于:<a href="https://zhuanlan.zhihu.com/p/384484213">面试官：听说你对package.json很熟？</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title>一款vue虚拟键盘(支持中文和手写)插件</title>
    <url>/2021/05/07/%E4%B8%80%E6%AC%BEvue%E8%99%9A%E6%8B%9F%E9%94%AE%E7%9B%98(%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%87%E5%92%8C%E6%89%8B%E5%86%99)%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<p>推荐一款vue虚拟键盘(支持中文和手写)插件…</p>
<span id="more"></span>



<h2 id="关于"><a href="#关于" class="headerlink" title="关于"></a>关于</h2><h3 id="特性-🎉"><a href="#特性-🎉" class="headerlink" title="特性 🎉"></a>特性 🎉</h3><ul>
<li>支持多达五种键盘模式</li>
<li>支持自定义主题色</li>
<li>已集成丰富的中文字库</li>
<li>支持急速识别的手写能力</li>
<li>vue3.0 组件开箱即用</li>
</ul>
<h2 id="支持环境"><a href="#支持环境" class="headerlink" title="支持环境"></a>支持环境</h2><table>
<thead>
<tr>
<th><a href="http://godban.github.io/browsers-support-badges/"><img src="https://raw.githubusercontent.com/alrra/browser-logos/master/src/edge/edge_48x48.png" alt="IE / Edge"></a> Edge</th>
<th><a href="http://godban.github.io/browsers-support-badges/"><img src="https://raw.githubusercontent.com/alrra/browser-logos/master/src/firefox/firefox_48x48.png" alt="Firefox"></a>Firefox</th>
<th><a href="http://godban.github.io/browsers-support-badges/"><img src="https://raw.githubusercontent.com/alrra/browser-logos/master/src/chrome/chrome_48x48.png" alt="Chrome"></a>Chrome</th>
<th><a href="http://godban.github.io/browsers-support-badges/"><img src="https://raw.githubusercontent.com/alrra/browser-logos/master/src/safari/safari_48x48.png" alt="Safari"></a>Safari</th>
<th><a href="http://godban.github.io/browsers-support-badges/"><img src="https://raw.githubusercontent.com/alrra/browser-logos/master/src/opera/opera_48x48.png" alt="Opera"></a>Opera</th>
</tr>
</thead>
<tbody><tr>
<td>Edge</td>
<td>last 2 versions</td>
<td>last 2 versions</td>
<td>last 2 versions</td>
<td>last 2 versions</td>
</tr>
</tbody></table>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="使用-npm-或-yarn-安装"><a href="#使用-npm-或-yarn-安装" class="headerlink" title="使用 npm 或 yarn 安装"></a>使用 npm 或 yarn 安装</h3><pre><code>$ npm install vue-keyboard-virtual-next --save
$ yarn add vue-keyboard-virtual-next --save
</code></pre>
<p>如果你的网络环境不佳，推荐使用 <a href="https://github.com/cnpm/cnpm">cnpm</a>。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="全局引入"><a href="#全局引入" class="headerlink" title="全局引入"></a>全局引入</h3><pre><code class="js">import App from &quot;./app.vue&quot;;
import &#123; createApp &#125; from &quot;vue&quot;;
import &quot;vue-keyboard-virtual-next/keyboard.min.css&quot;;
import KeyBoard from &quot;vue-keyboard-virtual-next&quot;;

createApp(App)
  .use(keyBoard)
  .mount(&quot;#app&quot;);
</code></pre>
<h3 id="局部引入"><a href="#局部引入" class="headerlink" title="局部引入"></a>局部引入</h3><pre><code class="vuejs">&lt;template&gt;
  &lt;!-- keyboard 只识别带有 data-mode 标识的输入框 --&gt;
  &lt;input data-mode v-model=&quot;value&quot; /&gt;
  &lt;Key-Board 
      :handApi=&quot;&#39;https://service.chaunve.com/HandWriteRecognizerService.asmx/Command&#39;&quot; 
      :color=&quot;&#39;#06f&#39;&quot;
  /&gt;
&lt;/template&gt;
</code></pre>
<pre><code class="js">&lt;script lang=&quot;ts&quot;&gt;
  import &quot;keyboard-virtual-vue/keyboard.min.css&quot;;
  import KeyBoard from &quot;keyboard-virtual-vue&quot;;
  import &#123; defineComponent, ref &#125; from &quot;vue&quot;;
  export default defineComponent(&#123;
    components: &#123; KeyBoard &#125;,
    setup() &#123;
      const value = ref&lt;string&gt;(&quot;你好&quot;);
      return &#123;
        value,
      &#125;;
    &#125;,
  &#125;);
&lt;/script&gt;
</code></pre>
<h3 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h3><h3 id="Input标签属性"><a href="#Input标签属性" class="headerlink" title="Input标签属性"></a>Input标签属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
<th>类型</th>
<th>可选值</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td><strong>data-mode</strong></td>
<td>弹出输入法的类型： <code>en</code> 英文小写 <code>number</code>数字 <code>symbol</code> 标点 <code>handwrite</code> 手写 <code>不传</code> 默认中文</td>
<td>String</td>
<td><code>en</code> <code>number</code> <code>symbol</code> <code>handwrite</code></td>
<td><code>default as *</code></td>
</tr>
<tr>
<td><strong>data-prop</strong></td>
<td>注册的输入框的类型</td>
<td>String</td>
<td>*</td>
<td></td>
</tr>
</tbody></table>
<h3 id="Props属性"><a href="#Props属性" class="headerlink" title="Props属性"></a>Props属性</h3><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th>默认值</th>
<th>类型</th>
<th>是否必须</th>
<th>版本</th>
</tr>
</thead>
<tbody><tr>
<td>v-model</td>
<td><em>绑定的输入框value</em>,可同时双向绑定多个输入框，不传则只与当前focus输入框做数据绑定关系</td>
<td></td>
<td>string|number</td>
<td>否</td>
<td>v1.0.0+</td>
</tr>
<tr>
<td>color</td>
<td><em>主题色</em></td>
<td><code>#eaa050</code></td>
<td>string</td>
<td>否</td>
<td>v1.0.0+</td>
</tr>
<tr>
<td>modeList</td>
<td><em>键盘渲染模式列表</em>，若不传handApi则不会出现手写板</td>
<td>[“handwrite”, “symbol”]</td>
<td>string[]</td>
<td>否</td>
<td>v1.0.0+</td>
</tr>
<tr>
<td>blurHide</td>
<td><em>是否当前输入框blur事件触发隐藏</em></td>
<td>true</td>
<td>boolean</td>
<td>否</td>
<td>v1.0.0+</td>
</tr>
<tr>
<td>showHandleBar</td>
<td><em>是否显示拖拽句柄</em></td>
<td>true</td>
<td>boolean</td>
<td>否</td>
<td>v1.0.0+</td>
</tr>
<tr>
<td>dargHandleText</td>
<td>拖拽句柄提示文字</td>
<td></td>
<td>string</td>
<td>否</td>
<td>v1.0.0+</td>
</tr>
<tr>
<td>modal</td>
<td><em>是否显示遮罩层</em></td>
<td>false</td>
<td>boolean</td>
<td>否</td>
<td>v1.0.0+</td>
</tr>
<tr>
<td>closeOnClickModal</td>
<td>是否点击遮罩层隐藏键盘</td>
<td>true</td>
<td>boolean</td>
<td>否</td>
<td>v1.0.0+</td>
</tr>
<tr>
<td>handApi</td>
<td>手写识别接口，若不传则无法切换手写模块</td>
<td></td>
<td>string</td>
<td>否</td>
<td>v1.0.0+</td>
</tr>
<tr>
<td>animateClass</td>
<td>键盘显隐动画，内置slide动画，如若需要其他动画，可传入相应类名自定义动画</td>
<td></td>
<td>string</td>
<td>否</td>
<td>v1.0.0+</td>
</tr>
</tbody></table>
<h3 id="Events"><a href="#Events" class="headerlink" title="Events"></a>Events</h3><table>
<thead>
<tr>
<th>参数</th>
<th>说明</th>
<th>类型</th>
<th>版本</th>
</tr>
</thead>
<tbody><tr>
<td>keyChange</td>
<td>按键触发事件，第一个参数为当前触发的按键的标识,<code>第二个参数为当前聚焦输入框的props值，若没有则直接返回当前聚焦的input元素（v1.0.1版本之后）</code></td>
<td>(<em>value</em>: string,prop:string|HTMLInputElement) =&gt; void</td>
<td>v1.0.0+</td>
</tr>
<tr>
<td>change</td>
<td>value改变事件，第一个参数为当前最新通过键盘输入的值，<code>第二个参数为当前聚焦输入框的props值，若没有则直接返回当前聚焦的input元素（v1.0.1版本之后）</code></td>
<td>(<em>value</em>: string,prop:string|HTMLInputElement) =&gt; void</td>
<td>v1.0.0+</td>
</tr>
<tr>
<td>closed</td>
<td>键盘关闭事件</td>
<td>() =&gt; void</td>
<td>v1.0.0+</td>
</tr>
<tr>
<td>modalClick</td>
<td>遮罩点击事件</td>
<td>() =&gt; void</td>
<td>v1.0.0+</td>
</tr>
</tbody></table>
<h2 id="Component-Event"><a href="#Component-Event" class="headerlink" title="Component Event"></a>Component Event</h2><table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
<th>类型</th>
<th>版本</th>
</tr>
</thead>
<tbody><tr>
<td>reSignUp</td>
<td>重新给input注册绑定键盘,当页面有新的input标签出现时调用此方法</td>
<td>（）=&gt; void</td>
<td>v1.0.0+</td>
</tr>
<tr>
<td>getCurrentInput</td>
<td>获取当前聚焦的输入框</td>
<td>（）=&gt; HTMLInputElement | null</td>
<td>v1.0.1+</td>
</tr>
</tbody></table>
<pre><code class="vuejs">&lt;template&gt;
  &lt;!-- keyboard 只识别带有 data-mode 标识的输入框 --&gt;
  &lt;input data-mode v-model=&quot;value&quot; /&gt;
  &lt;Key-Board 
      :handApi=&quot;&#39;https://service.chaunve.com/HandWriteRecognizerService.asmx/Command&#39;&quot; 
      :color=&quot;&#39;#06f&#39;&quot;
  /&gt;
&lt;/template&gt;

&lt;script lang=&quot;ts&quot;&gt;
import &quot;vue-keyboard-virtual-next/keyboard.min.css&quot;;
import KeyBoard from &quot;vue-keyboard-virtual-next&quot;;
import &#123; defineComponent, ref, onMounted &#125; from &quot;vue&quot;;
export default defineComponent(&#123;
  components: &#123; KeyBoard &#125;,
  setup() &#123;
    const value = ref&lt;string&gt;(&quot;你好&quot;);
    const keyBoardRef = ref&lt;typeof KeyBoard | null&gt;(null);
      
    onMounted(() =&gt; &#123;
        // xxxx逻辑 给键盘重新注册输入框
        keyBoardRef.value?.reSignUp();
    &#125;)
      
    return &#123;
      value,
      keyBoardRef
    &#125;;
  &#125;,
&#125;);
&lt;/script&gt;
</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>Npm</tag>
      </tags>
  </entry>
  <entry>
    <title>了不起的 tsconfig.json 指南</title>
    <url>/2021/06/01/%E4%BA%86%E4%B8%8D%E8%B5%B7%E7%9A%84%20tsconfig.json%20%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>tsconfig.json配置详细说明…</p>
<span id="more"></span>
<p>在 TypeScript 开发中，tsconfig.json 是个不可或缺的配置文件，它是我们在 TS 项目中最常见的配置文件，那么你真的了解这个文件吗？它里面都有哪些优秀配置？如何配置一个合理的 tsconfig.json 文件？本文将全面带大家一起详细了解 tsconfig.json 的各项配置。</p>
<p>本文将从以下几个方面全面介绍 tsconfig.json 文件：<br><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210601142104462.png" alt="image-20210601142104462"></p>
<p>水平有限，欢迎各位大佬指点~~</p>
<h2 id="一、tsconfig-json-简介"><a href="#一、tsconfig-json-简介" class="headerlink" title="一、tsconfig.json 简介"></a>一、tsconfig.json 简介</h2><h3 id="1-什么是-tsconfig-json"><a href="#1-什么是-tsconfig-json" class="headerlink" title="1. 什么是 tsconfig.json"></a>1. 什么是 tsconfig.json</h3><p>TypeScript 使用 tsconfig.json 文件作为其配置文件，当一个目录中存在 tsconfig.json 文件，则认为该目录为 TypeScript 项目的根目录。<br>通常 tsconfig.json 文件主要包含两部分内容：<strong>指定待编译文件</strong>和<strong>定义编译选项</strong>。</p>
<p>从《<a href="http://json.schemastore.org/tsconfig">TypeScript编译器的配置文件的JSON模式</a>》可知，目前 tsconfig.json 文件有以下几个顶层属性：</p>
<ul>
<li>compileOnSave</li>
<li>compilerOptions</li>
<li>exclude</li>
<li>extends</li>
<li>files</li>
<li>include</li>
<li>references</li>
<li>typeAcquisition</li>
</ul>
<p>文章后面会详细介绍一些常用属性配置。</p>
<h3 id="2-为什么使用-tsconfig-json"><a href="#2-为什么使用-tsconfig-json" class="headerlink" title="2. 为什么使用 tsconfig.json"></a>2. 为什么使用 tsconfig.json</h3><p>通常我们可以使用 <code>tsc</code> 命令来编译少量 TypeScript 文件：</p>
<pre><code>/*
  参数介绍：
  --outFile // 编译后生成的文件名称
  --target  // 指定ECMAScript目标版本
  --module  // 指定生成哪个模块系统代码
  index.ts  // 源文件
*/
$ tsc --outFile leo.js --target es3 --module amd index.ts
</code></pre>
<p>但如果实际开发的项目，很少是只有单个文件，当我们需要编译整个项目时，就可以使用 tsconfig.json 文件，将需要使用到的配置都写进 tsconfig.json 文件，<strong>这样就不用每次编译都手动输入配置，另外也方便团队协作开发</strong>。</p>
<h2 id="二、使用-tsconfig-json"><a href="#二、使用-tsconfig-json" class="headerlink" title="二、使用 tsconfig.json"></a>二、使用 tsconfig.json</h2><p>目前使用 tsconfig.json 有2种操作：</p>
<h3 id="1-初始化-tsconfig-json"><a href="#1-初始化-tsconfig-json" class="headerlink" title="1. 初始化 tsconfig.json"></a>1. 初始化 tsconfig.json</h3><p>在初始化操作，也有 2 种方式：</p>
<ol>
<li>手动在项目根目录（或其他）创建 tsconfig.json 文件并填写配置；</li>
<li>通过 <code>tsc --init</code> 初始化 tsconfig.json 文件。</li>
</ol>
<h3 id="2-指定需要编译的目录"><a href="#2-指定需要编译的目录" class="headerlink" title="2. 指定需要编译的目录"></a>2. 指定需要编译的目录</h3><p><strong>在不指定输入文件的情况下</strong>执行 <code>tsc</code> 命令，默认从当前目录开始编译，编译所有 <code>.ts</code> 文件，并且从当前目录开始查找 tsconfig.json 文件，并逐级向上级目录搜索。</p>
<pre><code>$ tsc
</code></pre>
<p>另外也可以为 <code>tsc</code> 命令指定参数 <code>--project</code> 或 <code>-p</code> 指定需要编译的目录，该目录需要包含一个 tsconfig.json 文件，如：</p>
<pre><code>/*
  文件目录：
  ├─src/
  │  ├─index.ts
  │  └─tsconfig.json
  ├─package.json
*/
$ tsc --project src
</code></pre>
<p><strong>注意，tsc 的命令行选项具有优先级，会覆盖 tsconfig.json 中的同名选项。</strong></p>
<p>更多 tsc 编译选项，可查看<a href="https://www.tslang.cn/docs/handbook/compiler-options.html">《编译选项》</a>章节。</p>
<h2 id="三、使用示例"><a href="#三、使用示例" class="headerlink" title="三、使用示例"></a>三、使用示例</h2><p>这个章节，我们将通过本地一个小项目 <code>learnTsconfig</code> 来学着实现一个简单配置。<br>当前开发环境：windows / node 10.15.1 / TypeScript3.9</p>
<h3 id="1-初始化-learnTsconfig-项目"><a href="#1-初始化-learnTsconfig-项目" class="headerlink" title="1. 初始化 learnTsconfig 项目"></a>1. 初始化 learnTsconfig 项目</h3><p>执行下面命令：</p>
<pre><code>$ mkdir learnTsconfig
$ cd .\learnTsconfig\
$ mkdir src
$ new-item index.ts
</code></pre>
<p>并且我们为 index.ts 文件写一些简单代码：</p>
<pre><code>// 返回当前版本号
function getVersion(version:string = &quot;1.0.0&quot;): string&#123;
    return version;
&#125;

console.log(getVersion(&quot;1.0.1&quot;))
</code></pre>
<p>我们将获得这么一个目录结构：</p>
<pre><code>  └─src/
     └─index.ts
</code></pre>
<h3 id="2-初始化-tsconfig-json-文件"><a href="#2-初始化-tsconfig-json-文件" class="headerlink" title="2. 初始化 tsconfig.json 文件"></a>2. 初始化 tsconfig.json 文件</h3><p>在 learnTsconfig 根目录执行：</p>
<pre><code>$ tsc --init
</code></pre>
<h3 id="3-修改-tsconfig-json-文件"><a href="#3-修改-tsconfig-json-文件" class="headerlink" title="3. 修改 tsconfig.json 文件"></a>3. 修改 tsconfig.json 文件</h3><p>我们设置几个常见配置项：</p>
<pre><code>&#123;
  &quot;compilerOptions&quot;: &#123;
    &quot;target&quot;: &quot;ES5&quot;,             // 目标语言的版本
    &quot;module&quot;: &quot;commonjs&quot;,        // 指定生成代码的模板标准
    &quot;noImplicitAny&quot;: true,       // 不允许隐式的 any 类型
    &quot;removeComments&quot;: true,      // 删除注释 
    &quot;preserveConstEnums&quot;: true,  // 保留 const 和 enum 声明
    &quot;sourceMap&quot;: true            // 生成目标文件的sourceMap文件
  &#125;,
  &quot;files&quot;: [   // 指定待编译文件
    &quot;./src/index.ts&quot;  
  ]
&#125;
</code></pre>
<p>其中需要注意一点：<br> <code>files</code> 配置项值是一个<strong>数组</strong>，用来指定了待编译文件，即<strong>入口文件</strong>。<br>当入口文件依赖其他文件时，不需要将被依赖文件也指定到 <code>files</code> 中，因为<strong>编译器会自动将所有的依赖文件归纳为编译对象</strong>，即 <code>index.ts</code> 依赖 <code>user.ts</code> 时，不需要在 <code>files</code> 中指定 <code>user.ts</code> ， <code>user.ts</code> 会自动纳入待编译文件。</p>
<h3 id="4-执行编译"><a href="#4-执行编译" class="headerlink" title="4. 执行编译"></a>4. 执行编译</h3><p>配置完成后，我们可以在命令行执行 <code>tsc</code> 命令，执行编译完成后，我们可以得到一个 <code>index.js</code> 文件和一个 <code>index.js.map</code> 文件，证明我们编译成功，其中 <code>index.js</code> 文件内容如下：</p>
<pre><code>function getVersion(version) &#123;
    if (version === void 0) &#123; version = &quot;1.0.0&quot;; &#125;
    return version;
&#125;
console.log(getVersion(&quot;1.0.1&quot;));
//# sourceMappingURL=index.js.map
</code></pre>
<p>可以看出，tsconfig.json 中的 <code>removeComments</code> 配置生效了，将我们添加的注释代码移除了。</p>
<p>到这一步，就完成了这个简单的示例，接下来会基于这个示例代码，讲解《七、常见配置示例》。</p>
<h2 id="四、tsconfig-json-文件结构介绍"><a href="#四、tsconfig-json-文件结构介绍" class="headerlink" title="四、tsconfig.json 文件结构介绍"></a>四、tsconfig.json 文件结构介绍</h2><h3 id="1-按顶层属性分类"><a href="#1-按顶层属性分类" class="headerlink" title="1. 按顶层属性分类"></a>1. 按顶层属性分类</h3><p>在 tsconfig.json 文件中按照<strong>顶层属性</strong>，分为以下几类：<br><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210601142314935.png" alt="image-20210601142314935"></p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210601142206106.png" alt="image-20210601142206106"></p>
<h3 id="2-按功能分类"><a href="#2-按功能分类" class="headerlink" title="2. 按功能分类"></a>2. 按功能分类</h3><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210601142338923.png" alt="image-20210601142338923"></p>
<h2 id="五、tsconfig-json-配置介绍"><a href="#五、tsconfig-json-配置介绍" class="headerlink" title="五、tsconfig.json 配置介绍"></a>五、tsconfig.json 配置介绍</h2><h3 id="1-compileOnSave"><a href="#1-compileOnSave" class="headerlink" title="1. compileOnSave"></a>1. compileOnSave</h3><p><code>compileOnSave</code> 属性作用是<strong>设置保存文件的时候自动编译，但需要编译器支持</strong>。</p>
<pre><code>&#123;
    // ...
  &quot;compileOnSave&quot;: false,
&#125;
</code></pre>
<h3 id="2-compilerOptions"><a href="#2-compilerOptions" class="headerlink" title="2. compilerOptions"></a>2. compilerOptions</h3><p><code>compilerOptions</code> 属性作用是<strong>配置编译选项</strong>。<br>若 <code>compilerOptions</code> 属性被忽略，则编译器会使用默认值，可以查看<a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html">《官方完整的编译选项列表》</a>。<br>编译选项配置非常繁杂，有很多配置，这里只列出常用的配置。</p>
<pre><code>&#123;
  // ...
  &quot;compilerOptions&quot;: &#123;
    &quot;incremental&quot;: true, // TS编译器在第一次编译之后会生成一个存储编译信息的文件，第二次编译会在第一次的基础上进行增量编译，可以提高编译的速度
    &quot;tsBuildInfoFile&quot;: &quot;./buildFile&quot;, // 增量编译文件的存储位置
    &quot;diagnostics&quot;: true, // 打印诊断信息 
    &quot;target&quot;: &quot;ES5&quot;, // 目标语言的版本
    &quot;module&quot;: &quot;CommonJS&quot;, // 生成代码的模板标准
    &quot;outFile&quot;: &quot;./app.js&quot;, // 将多个相互依赖的文件生成一个文件，可以用在AMD模块中，即开启时应设置&quot;module&quot;: &quot;AMD&quot;,
    &quot;lib&quot;: [&quot;DOM&quot;, &quot;ES2015&quot;, &quot;ScriptHost&quot;, &quot;ES2019.Array&quot;], // TS需要引用的库，即声明文件，es5 默认引用dom、es5、scripthost,如需要使用es的高级版本特性，通常都需要配置，如es8的数组新特性需要引入&quot;ES2019.Array&quot;,
    &quot;allowJS&quot;: true, // 允许编译器编译JS，JSX文件
    &quot;checkJs&quot;: true, // 允许在JS文件中报错，通常与allowJS一起使用
    &quot;outDir&quot;: &quot;./dist&quot;, // 指定输出目录
    &quot;rootDir&quot;: &quot;./&quot;, // 指定输出文件目录(用于输出)，用于控制输出目录结构
    &quot;declaration&quot;: true, // 生成声明文件，开启后会自动生成声明文件
    &quot;declarationDir&quot;: &quot;./file&quot;, // 指定生成声明文件存放目录
    &quot;emitDeclarationOnly&quot;: true, // 只生成声明文件，而不会生成js文件
    &quot;sourceMap&quot;: true, // 生成目标文件的sourceMap文件
    &quot;inlineSourceMap&quot;: true, // 生成目标文件的inline SourceMap，inline SourceMap会包含在生成的js文件中
    &quot;declarationMap&quot;: true, // 为声明文件生成sourceMap
    &quot;typeRoots&quot;: [], // 声明文件目录，默认时node_modules/@types
    &quot;types&quot;: [], // 加载的声明文件包
    &quot;removeComments&quot;:true, // 删除注释 
    &quot;noEmit&quot;: true, // 不输出文件,即编译后不会生成任何js文件
    &quot;noEmitOnError&quot;: true, // 发送错误时不输出任何文件
    &quot;noEmitHelpers&quot;: true, // 不生成helper函数，减小体积，需要额外安装，常配合importHelpers一起使用
    &quot;importHelpers&quot;: true, // 通过tslib引入helper函数，文件必须是模块
    &quot;downlevelIteration&quot;: true, // 降级遍历器实现，如果目标源是es3/5，那么遍历器会有降级的实现
    &quot;strict&quot;: true, // 开启所有严格的类型检查
    &quot;alwaysStrict&quot;: true, // 在代码中注入&#39;use strict&#39;
    &quot;noImplicitAny&quot;: true, // 不允许隐式的any类型
    &quot;strictNullChecks&quot;: true, // 不允许把null、undefined赋值给其他类型的变量
    &quot;strictFunctionTypes&quot;: true, // 不允许函数参数双向协变
    &quot;strictPropertyInitialization&quot;: true, // 类的实例属性必须初始化
    &quot;strictBindCallApply&quot;: true, // 严格的bind/call/apply检查
    &quot;noImplicitThis&quot;: true, // 不允许this有隐式的any类型
    &quot;noUnusedLocals&quot;: true, // 检查只声明、未使用的局部变量(只提示不报错)
    &quot;noUnusedParameters&quot;: true, // 检查未使用的函数参数(只提示不报错)
    &quot;noFallthroughCasesInSwitch&quot;: true, // 防止switch语句贯穿(即如果没有break语句后面不会执行)
    &quot;noImplicitReturns&quot;: true, //每个分支都会有返回值
    &quot;esModuleInterop&quot;: true, // 允许export=导出，由import from 导入
    &quot;allowUmdGlobalAccess&quot;: true, // 允许在模块中全局变量的方式访问umd模块
    &quot;moduleResolution&quot;: &quot;node&quot;, // 模块解析策略，ts默认用node的解析策略，即相对的方式导入
    &quot;baseUrl&quot;: &quot;./&quot;, // 解析非相对模块的基地址，默认是当前目录
    &quot;paths&quot;: &#123; // 路径映射，相对于baseUrl
      // 如使用jq时不想使用默认版本，而需要手动指定版本，可进行如下配置
      &quot;jquery&quot;: [&quot;node_modules/jquery/dist/jquery.min.js&quot;]
    &#125;,
    &quot;rootDirs&quot;: [&quot;src&quot;,&quot;out&quot;], // 将多个目录放在一个虚拟目录下，用于运行时，即编译后引入文件的位置可能发生变化，这也设置可以虚拟src和out在同一个目录下，不用再去改变路径也不会报错
    &quot;listEmittedFiles&quot;: true, // 打印输出文件
    &quot;listFiles&quot;: true// 打印编译的文件(包括引用的声明文件)
  &#125;
&#125;
</code></pre>
<h3 id="3-exclude"><a href="#3-exclude" class="headerlink" title="3. exclude"></a>3. exclude</h3><p><code>exclude</code> 属性作用是<strong>指定编译器需要排除的文件或文件夹。</strong><br>默认排除 <code>node_modules</code> 文件夹下文件。</p>
<pre><code>&#123;
    // ...
  &quot;exclude&quot;: [
    &quot;src/lib&quot; // 排除src目录下的lib文件夹下的文件不会编译
  ]
&#125;
</code></pre>
<p>和 <code>include</code> 属性一样，支持 glob 通配符：</p>
<ul>
<li><code>*</code> 匹配0或多个字符（不包括目录分隔符）</li>
<li><code>?</code> 匹配一个任意字符（不包括目录分隔符）</li>
<li><code>**/</code> 递归匹配任意子目录</li>
</ul>
<h3 id="4-extends"><a href="#4-extends" class="headerlink" title="4. extends"></a>4. extends</h3><p><code>extends</code> 属性作用是<strong>引入其他配置文件，继承配置</strong>。<br>默认包含当前目录和子目录下所有 TypeScript 文件。</p>
<pre><code>&#123;
    // ...
  // 把基础配置抽离成tsconfig.base.json文件，然后引入
    &quot;extends&quot;: &quot;./tsconfig.base.json&quot;
&#125;
</code></pre>
<h3 id="5-files"><a href="#5-files" class="headerlink" title="5. files"></a>5. files</h3><p><code>files</code> 属性作用是<strong>指定需要编译的单个文件列表</strong>。<br>默认包含当前目录和子目录下所有 TypeScript 文件。</p>
<pre><code>&#123;
    // ...
  &quot;files&quot;: [
    // 指定编译文件是src目录下的leo.ts文件
    &quot;scr/leo.ts&quot;
  ]
&#125;
</code></pre>
<h3 id="6-include"><a href="#6-include" class="headerlink" title="6. include"></a>6. include</h3><p><code>include</code> 属性作用是<strong>指定编译需要编译的文件或目录</strong>。</p>
<pre><code>&#123;
    // ...
  &quot;include&quot;: [
    // &quot;scr&quot; // 会编译src目录下的所有文件，包括子目录
    // &quot;scr/*&quot; // 只会编译scr一级目录下的文件
    &quot;scr/*/*&quot; // 只会编译scr二级目录下的文件
  ]
&#125;
</code></pre>
<h3 id="7-references"><a href="#7-references" class="headerlink" title="7. references"></a>7. references</h3><p><code>references</code> 属性作用是<strong>指定工程引用依赖。</strong><br>在项目开发中，有时候我们为了方便将前端项目和后端<code>node</code>项目放在同一个目录下开发，两个项目依赖同一个配置文件和通用文件，但我们希望前后端项目进行灵活的分别打包，那么我们可以进行如下配置：</p>
<pre><code>&#123;
    // ...
  &quot;references&quot;: [ // 指定依赖的工程
     &#123;&quot;path&quot;: &quot;./common&quot;&#125;
  ]
&#125;
</code></pre>
<h3 id="8-typeAcquisition"><a href="#8-typeAcquisition" class="headerlink" title="8. typeAcquisition"></a>8. typeAcquisition</h3><p><code>typeAcquisition</code> 属性作用是<strong>设置自动引入库类型定义文件(.d.ts)相关。</strong><br>包含 3 个子属性：</p>
<ul>
<li><code>enable</code> : 布尔类型，是否开启自动引入库类型定义文件(.d.ts)，默认为 false；</li>
<li><code>include</code> : 数组类型，允许自动引入的库名，如：[“jquery”, “lodash”]；</li>
<li><code>exculde</code> : 数组类型，排除的库名。</li>
</ul>
<pre><code>&#123;
    // ...
  &quot;typeAcquisition&quot;: &#123;
    &quot;enable&quot;: false,
    &quot;exclude&quot;: [&quot;jquery&quot;],
    &quot;include&quot;: [&quot;jest&quot;]
  &#125;
&#125;
</code></pre>
<h2 id="六、常见配置示例"><a href="#六、常见配置示例" class="headerlink" title="六、常见配置示例"></a>六、常见配置示例</h2><p>本部分内容中，我们找了几个实际开发中比较常见的配置，当然，还有很多配置需要自己摸索哟~~</p>
<h3 id="1-移除代码中注释"><a href="#1-移除代码中注释" class="headerlink" title="1. 移除代码中注释"></a>1. 移除代码中注释</h3><p>tsconfig.json：</p>
<pre><code>&#123;
  &quot;compilerOptions&quot;: &#123;
    &quot;removeComments&quot;: true,
  &#125;
&#125;
</code></pre>
<p>编译前：</p>
<pre><code>// 返回当前版本号
function getVersion(version:string = &quot;1.0.0&quot;): string&#123;
    return version;
&#125;
console.log(getVersion(&quot;1.0.1&quot;))
</code></pre>
<p>编译结果：</p>
<pre><code>function getVersion(version) &#123;
    if (version === void 0) &#123; version = &quot;1.0.0&quot;; &#125;
    return version;
&#125;
console.log(getVersion(&quot;1.0.1&quot;));
</code></pre>
<h3 id="2-开启null、undefined检测"><a href="#2-开启null、undefined检测" class="headerlink" title="2. 开启null、undefined检测"></a>2. 开启null、undefined检测</h3><p>tsconfig.json：</p>
<pre><code>&#123;
    &quot;compilerOptions&quot;: &#123;
        &quot;strictNullChecks&quot;: true
    &#125;,
&#125;
</code></pre>
<p>修改 <code>index.ts</code> 文件内容：</p>
<pre><code>const leo;
leo = new Pingan(&#39;leo&#39;,&#39;hello&#39;);
</code></pre>
<p>这时候编辑器也会提示错误信息，执行 <code>tsc</code> 后，控制台报错：</p>
<pre><code>src/index.ts:9:11 - error TS2304: Cannot find name &#39;Pingan&#39;.

9 leo = new Pingan(&#39;leo&#39;,&#39;hello&#39;);

Found 1 error.
</code></pre>
<h3 id="3-配置复用"><a href="#3-配置复用" class="headerlink" title="3. 配置复用"></a>3. 配置复用</h3><p>通过 <code>extends</code> 属性实现配置复用，即一个配置文件可以继承另一个文件的配置属性。<br>比如，建立一个基础的配置文件 <code>configs/base.json</code> ：</p>
<pre><code>&#123;
  &quot;compilerOptions&quot;: &#123;
    &quot;noImplicitAny&quot;: true,
    &quot;strictNullChecks&quot;: true
  &#125;
&#125;
</code></pre>
<p>在<code>tsconfig.json</code> 就可以引用这个文件的配置了：</p>
<pre><code>&#123;
  &quot;extends&quot;: &quot;./configs/base&quot;,
  &quot;files&quot;: [
    &quot;main.ts&quot;,
    &quot;supplemental.ts&quot;
  ]
&#125;
</code></pre>
<h3 id="4-生成枚举的映射代码"><a href="#4-生成枚举的映射代码" class="headerlink" title="4. 生成枚举的映射代码"></a>4. 生成枚举的映射代码</h3><p>在默认情况下，使用 <code>const</code> 修饰符后，枚举不会生成映射代码。<br>如下，我们可以看出：使用 <code>const</code> 修饰符后，编译器不会生成任何 <code>RequestMethod</code> 枚举的任何映射代码，在其他地方使用时，内联每个成员的值，节省很大开销。</p>
<pre><code>const enum RequestMethod &#123;
  Get,
  Post,
  Put,
  Delete
&#125;

let methods = [
  RequestMethod.Get,
  RequestMethod.Post
]
</code></pre>
<p>编译结果：</p>
<pre><code>&quot;use strict&quot;;
let methods = [
    0 /* Get */,
    1 /* Post */
];
</code></pre>
<p>当然，我们希望生成映射代码时，也可以设置 <code>tsconfig.json</code> 中的配置，设置 <code>preserveConstEnums</code> 编译器选项为 <code>true</code> ：</p>
<pre><code>&#123;
  &quot;compilerOptions&quot;: &#123;
    &quot;target&quot;: &quot;es5&quot;,
    &quot;preserveConstEnums&quot;: true
  &#125;
&#125;
</code></pre>
<p>最后编译结果变成：</p>
<pre><code>&quot;use strict&quot;;
var RequestMethod;
(function (RequestMethod) &#123;
    RequestMethod[RequestMethod[&quot;Get&quot;] = 0] = &quot;Get&quot;;
    RequestMethod[RequestMethod[&quot;Post&quot;] = 1] = &quot;Post&quot;;
    RequestMethod[RequestMethod[&quot;Put&quot;] = 2] = &quot;Put&quot;;
    RequestMethod[RequestMethod[&quot;Delete&quot;] = 3] = &quot;Delete&quot;;
&#125;)(RequestMethod || (RequestMethod = &#123;&#125;));
let methods = [
    0 /* Get */,
    1 /* Post */
];
</code></pre>
<h3 id="5-关闭-this-类型注解提示"><a href="#5-关闭-this-类型注解提示" class="headerlink" title="5. 关闭 this 类型注解提示"></a>5. 关闭 this 类型注解提示</h3><p>通过下面代码编译后会报错：</p>
<pre><code>const button = document.querySelector(&quot;button&quot;);
button?.addEventListener(&quot;click&quot;, handleClick);
function handleClick(this) &#123;
 console.log(&quot;Clicked!&quot;);
 this.removeEventListener(&quot;click&quot;, handleClick);
&#125;
</code></pre>
<p>报错内容：</p>
<pre><code>src/index.ts:10:22 - error TS7006: Parameter &#39;this&#39; implicitly has an &#39;any&#39; type.
10 function handleClick(this) &#123;
Found 1 error.
</code></pre>
<p>这是因为 <code>this</code> 隐式具有 <code>any</code> 类型，如果没有指定类型注解，编译器会提示“”this” 隐式具有类型 “any”，因为它没有类型注释。”。</p>
<p>解决方法有2种：</p>
<ol>
<li>指定 this 类型，如本代码中为 <code>HTMLElement</code> 类型：</li>
</ol>
<p><code>HTMLElement</code> 接口表示所有的 HTML 元素。一些HTML元素直接实现了 <code>HTMLElement</code> 接口，其它的间接实现<code>HTMLElement</code>接口。<br>关于<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement"> HTMLElement </a>可查看详细。</p>
<ol>
<li>使用 <code>--noImplicitThis</code> 配置项： </li>
</ol>
<p>在 TS2.0 还增加一个新的编译选项： <code>--noImplicitThis</code>，表示当 <code>this</code> 表达式值为 <code>any</code> 类型时生成一个错误信息。我们设置为 <code>true</code> 后就能正常编译。</p>
<pre><code>&#123;
  &quot;compilerOptions&quot;: &#123;
    &quot;noImplicitThis&quot;: true
  &#125;
&#125;
</code></pre>
<h2 id="七、Webpack-React-中使用示例"><a href="#七、Webpack-React-中使用示例" class="headerlink" title="七、Webpack/React 中使用示例"></a>七、Webpack/React 中使用示例</h2><h3 id="1-配置编译-ES6-代码，JSX-文件"><a href="#1-配置编译-ES6-代码，JSX-文件" class="headerlink" title="1. 配置编译 ES6 代码，JSX 文件"></a>1. 配置编译 ES6 代码，JSX 文件</h3><p>创建测试项目 webpack-demo，结构如下：</p>
<pre><code>webpack-demo/
  |- package.json
  |- tsconfig.json
  |- webpack.config.js
  |- /dist
    |- bundle.js
    |- index.html
  |- /src
    |- index.js
    |- index.ts
  |- /node_modules
</code></pre>
<p>安装 TypeScript 和 ts-loader：</p>
<pre><code>$ npm install --save-dev typescript ts-loader
</code></pre>
<p>配置 tsconfig.json，支持 JSX，并将 TypeScript 编译为 ES5：</p>
<pre><code>&#123;
  &quot;compilerOptions&quot;: &#123;
    &quot;outDir&quot;: &quot;./dist/&quot;,
    &quot;noImplicitAny&quot;: true,
+   &quot;module&quot;: &quot;es6&quot;,
+   &quot;target&quot;: &quot;es5&quot;,
+   &quot;jsx&quot;: &quot;react&quot;,
    &quot;allowJs&quot;: true
  &#125;
&#125;
</code></pre>
<p>还需要配置 webpack.config.js，使其能够处理 TypeScript 代码，这里主要在 <code>rules</code> 中添加 <code>ts-loader</code> ：</p>
<pre><code>const path = require(&#39;path&#39;);

module.exports = &#123;
  entry: &#39;./src/index.ts&#39;,
  module: &#123;
    rules: [
      &#123;
        test: /\.tsx?$/,
        use: &#39;ts-loader&#39;,
        exclude: /node_modules/
      &#125;
    ]
  &#125;,
  resolve: &#123;
    extensions: [ &#39;.tsx&#39;, &#39;.ts&#39;, &#39;.js&#39; ]
  &#125;,
  output: &#123;
    filename: &#39;bundle.js&#39;,
    path: path.resolve(__dirname, &#39;dist&#39;)
  &#125;
&#125;;
</code></pre>
<h3 id="2-配置-source-map"><a href="#2-配置-source-map" class="headerlink" title="2. 配置 source map"></a>2. 配置 source map</h3><p>想要启用 source map，我们必须配置 TypeScript，以将内联的 source map 输出到编译后的 JavaScript 文件中。<br>只需要在 tsconfig.json 中配置 sourceMap 属性：</p>
<pre><code>  &#123;
    &quot;compilerOptions&quot;: &#123;
      &quot;outDir&quot;: &quot;./dist/&quot;,
+     &quot;sourceMap&quot;: true,
      &quot;noImplicitAny&quot;: true,
      &quot;module&quot;: &quot;commonjs&quot;,
      &quot;target&quot;: &quot;es5&quot;,
      &quot;jsx&quot;: &quot;react&quot;,
      &quot;allowJs&quot;: true
    &#125;
  &#125;
</code></pre>
<p>然后配置 webpack.config.js 文件，让 webpack 提取 source map，并内联到最终的 bundle 中：</p>
<pre><code>  const path = require(&#39;path&#39;);

  module.exports = &#123;
    entry: &#39;./src/index.ts&#39;,
+   devtool: &#39;inline-source-map&#39;,
    module: &#123;
      rules: [
        &#123;
          test: /\.tsx?$/,
          use: &#39;ts-loader&#39;,
          exclude: /node_modules/
        &#125;
      ]
    &#125;,
    resolve: &#123;
      extensions: [ &#39;.tsx&#39;, &#39;.ts&#39;, &#39;.js&#39; ]
    &#125;,
    output: &#123;
      filename: &#39;bundle.js&#39;,
      path: path.resolve(__dirname, &#39;dist&#39;)
    &#125;
  &#125;;
</code></pre>
<h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>本文较全面介绍了 tsconfig.json 文件的知识，从“什么是 tsconfig.js 文件”开始，一步步带领大家全面认识 tsconfig.json 文件。<br>文中通过一个简单 learnTsconfig 项目，让大家知道项目中如何使用 tsconfig.json 文件。在后续文章中，我们将这么多的配置项进行分类学习。最后通过几个常见配置示例，解决我们开发中遇到的几个常见问题。</p>
<p>当然，本文篇幅有限，无法针对每个属性进行深入介绍，这就需要大家在实际开发中，多去尝试和使用啦~</p>
<h2 id="九、学习和参考资料"><a href="#九、学习和参考资料" class="headerlink" title="九、学习和参考资料"></a>九、学习和参考资料</h2><p>1.<a href="https://www.typescriptlang.org/tsconfig">《Intro to the TSConfig Reference》</a><br>2.<a href="https://www.tslang.cn/docs/handbook/tsconfig-json.html">《tsconfig.json》</a><br>3.<a href="http://json.schemastore.org/tsconfig">《TypeScript编译器的配置文件的JSON模式》</a><br>4.<a href="https://www.jianshu.com/p/0383bbd61a6b">《详解TypeScript项目中的tsconfig.json配置》</a><br>5.<a href="https://www.typescriptlang.org/docs/handbook/compiler-options.html">《官方完整的编译选项列表》</a></p>
<h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><ul>
<li><a href="https://segmentfault.com/a/1190000023091637">《1.2w字 ｜ 初中级前端 JavaScript 自测清单 - 1》</a></li>
<li><a href="https://segmentfault.com/a/1190000022991056">《了不起的 Webpack 构建流程学习指南》</a></li>
<li><a href="https://segmentfault.com/a/1190000022950736">《了不起的 Webpack HMR 学习指南（含源码分析）》</a></li>
<li><a href="https://segmentfault.com/a/1190000022940544">《你不知道的 WeakMap》番外篇</a></li>
<li><a href="https://segmentfault.com/a/1190000022875544">《你不知道的 Blob》番外篇</a></li>
</ul>
<p>转载于:<a href="https://segmentfault.com/a/1190000022809326">了不起的 tsconfig.json 指南</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue3</tag>
      </tags>
  </entry>
  <entry>
    <title>使用npm发布一个vue组件</title>
    <url>/2021/05/28/%E4%BD%BF%E7%94%A8npm%E5%8F%91%E5%B8%83%E4%B8%80%E4%B8%AAvue%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p>记录一下js获取公网和内网ip的方法</p>
<span id="more"></span>

<p><strong>这是一篇包教不包会的npm发布教程</strong>，为了避免很多文章中的分享，跟着一步步做，最后发包失败。。时间没了，搞得心情都不好了。</p>
<blockquote>
<p><strong>因此，在写这篇文章的同时[2019-08-18]我重新建立一个npm包，按照以下的流程，发布了一个npm包，也测试可用,所以童鞋们可以放心跟着一步步走，学会发布npm包。<a href="https://github.com/thomaszhou63/test-npm">发包的项目代码在这里</a>、 <a href="https://www.npmjs.com/package/our-btn">已经发布上线的npm包地址在这里</a></strong></p>
</blockquote>
<p>​    相信前端er对npm包不会陌生，<a href="https://www.npmjs.com/">npm</a> 本来是 Node.js 的包管理工具，但随着 JS 这几年的蓬勃发展，现在的 npm 已经成了几乎所有跟 JS 相关的工具和软件包的管理工具了，这次也会从0到1的走一遍发包的流程，</p>
<blockquote>
<p>1、本文是以vue项目为例子进行讲解，流程可通用，只是具体项目的安装有些许区别，不管vue还是react，相信对大家都有帮助</p>
<p>2、<strong>⚠️提示</strong>: 为了让童鞋们理解发包的流程和配置，所以还是建议按照步骤（1）-（10）的顺序来操作，为了突出整个发包流程，所以封装的测试组件非常简单。待理解所有文件的内容和具体原理，并成功发出一个测试npm包后，童鞋们可自行更换成自己的组件，发布属于自己的npm包，<strong>发布包的名字设置为<code>our-btn</code></strong></p>
</blockquote>
<h2 id="初始化webpack项目-组件封装-一气呵成"><a href="#初始化webpack项目-组件封装-一气呵成" class="headerlink" title="初始化webpack项目 + 组件封装 ===  一气呵成"></a>初始化webpack项目 + 组件封装 ===  一气呵成</h2><p>​    在项目中，我们都希望安装的插件体积尽可能的小，因此，我们在发包的时候也要尽量控制我们的依赖，所以我选择自己创建一个打包项目，而不是用笨重的vue和react脚手架。 话不多说，下面跟着做👇</p>
<ul>
<li><strong>（1）下方是推荐的目录结构，根据以下结构建立项目文件</strong></li>
</ul>
<blockquote>
<p>但是由于本文组件过于简单，所以删减<code>assets</code>、<code>utils</code>文件夹（有没有这两个文件夹不影响npm发包，仅仅方便你自己整理项目代码）</p>
</blockquote>
<pre><code>├── src
│ ├── assets # 本地静态资源（本文没有）
│ ├── components # 业务通用组件
│ │ ├── btnDemo.vue # 本文需要封装的简单button组件
│ ├── utils # 工具库（本文没有）
│ └── index.js # 应用入口 
├── .npmignore // 用于忽略不需要上传到npm的文件
├── README.md
├── package-lock.json
├── package.json
└── webpack.config.js # webpack配置

// 注意
# utils 文件夹一般存放的是你组件经常使用的一些工具函数
# assets 文件夹一般存放的是你组件用到的样式、图片、icon等静态资源
</code></pre>
<ul>
<li><strong>（2）<code>button组件</code></strong></li>
</ul>
<pre><code>// btnDemo.vue
&lt;template&gt;
  &lt;div class=&quot;btn&quot;&gt;
    &lt;button&gt;&#123;&#123;text&#125;&#125;&lt;/button&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  name: &#39;btn&#39;, // 组件的name属性（后面有提到这里有个坑）
  props: &#123;
    text: &#123; // 文本
      type: String,
      default () &#123;
        return &#39;&#39;
      &#125;
    &#125;
  &#125;,
  data () &#123;
    return &#123;
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<ul>
<li><strong>（3）<code>index.js</code></strong></li>
</ul>
<p>该文件是为了将我们的组件暴露出去</p>
<pre><code class="javascript">// src/index.js
// 这里import 的 btn和btnDemo.vue的name属性名相同 ！

import btn from &#39;./btnDemo.vue&#39;

btn.install = Vue =&gt; Vue.component(btn.name, btn) // 给组件配置install方法 

export default btn;
</code></pre>
<blockquote>
<p>⚠️（这里有个坑）：由于<code>Vue.component(btn.name, btn)</code>的<code>btn.name</code>是指向<code>btnDemo.vue</code>的<code>name</code>属性，因此，建议在这里最好用组件的<code>name</code>属性值作为<code>import</code>别名</p>
</blockquote>
<ul>
<li><strong>（4）<code>webpack.config.js</code></strong></li>
</ul>
<blockquote>
<p><code>webpack.config.js</code>配置如下，由于我们使用的版本是<code>webpack4</code>，所有的配置都在<code>webpack.config.js</code>里面，在我们这里仅仅需要把我们的资源打包，写的比较简单，具体<code>webpack</code>配置细节可以学习<a href="https://webpack.js.org/contribute/">官方文档</a></p>
</blockquote>
<p>这里配置是用于将<code>/src</code>中的内容打包到<code>/dist</code>（打包时会自动生成<code>/dist</code>文件夹）中的<code>btn.js</code>，<code>btn.js</code>其实就相当于我们的插件（后面在<code>package.json</code>的<code>main</code>字段也是指向这里）</p>
<pre><code class="javascript">// webpack.config.js
const path = require(&#39;path&#39;)
const &#123; VueLoaderPlugin &#125; = require(&#39;vue-loader&#39;)

module.exports = &#123;
  entry: &#123;
    index: path.join(__dirname, &quot;/src/index.js&quot;) // 入口文件（就是刚才用于暴露组件的index.js）
  &#125;, 
  output: &#123;
    path: path.join( __dirname, &quot;/dist&quot;), // 打包后的文件存放在dist文件夹
    publicPath: &#39;/dist/&#39;, // 设置公共路径
    filename: &quot;btn.js&quot;, // 打包后输出文件的文件设置为btn.js
    libraryTarget: &#39;umd&#39; // 这个选项会尝试把库暴露给前使用的模块定义系统，这使其和CommonJS、AMD兼容或者暴露为全局变量
  &#125;,
  module: &#123;
    rules: [
      &#123;
        test: /\.vue$/,
        loader: &#39;vue-loader&#39;
      &#125;,
      &#123;
        test: /\.css$/,
        use: [&#39;style-loader&#39;, &#39;css-loader&#39;]
      &#125;,
      &#123;
        test: /\.(scss|sass)$/,
        use: [&#39;style-loader&#39;, &#39;css-loader&#39;, &#39;sass-loader&#39;]
      &#125;,
      &#123;
        test: /\.(png|jpg|svg|gif)$/,
        use: [&#39;url-loader&#39;]
      &#125;,
      &#123;
        test: /\.js$/,
        exclude: /node_modules|vue\/dist|vue-router\/|vue-loader\/|vue-hot-reload-api\//,
        loader: &#39;babel-loader&#39;
      &#125;
    ]
  &#125;,
  plugins: [
    new VueLoaderPlugin()
  ]
&#125;
</code></pre>
<ul>
<li><strong>（5）<code>package.json</code></strong></li>
</ul>
<p><code>package.json</code>字段如下，要强调的是，字段<code>devDependencies</code>中的依赖项不唯一，你可以根据自己情况去写，<strong>但是此时此刻，请务必和我一样，这也是为了保证你可以按照我的操作，成功发包</strong></p>
<pre><code class="json">// 具体字段后面详细说明
&#123;
  &quot;name&quot;: &quot;our-btn&quot;, // 发布npm包的名字
  &quot;version&quot;: &quot;1.0.0&quot;, // 你的npm包版本
  &quot;description&quot;: &quot;A test button&quot;, // 包的描述
  &quot;main&quot;: &quot;dist/btn.js&quot;, // *重点*：指定你组件的主入口文件
  &quot;scripts&quot;: &#123;
    &quot;build&quot;: &quot;webpack --mode production&quot;,
    &quot;dev&quot;: &quot;webpack-dev-server --open --mode development&quot;
  &#125;,
  &quot;keywords&quot;: [
    &quot;our-btn&quot;,
    &quot;button&quot;
  ],
  &quot;repository&quot;: &#123;
    &quot;type&quot;: &quot;git&quot;,
    &quot;url&quot;: &quot;git+https://github.com/thomaszhou63/test-npm.git&quot;
  &#125;,
  &quot;author&quot;: &quot;thomaszhou&quot;,
  &quot;license&quot;: &quot;MIT&quot;,
  &quot;devDependencies&quot;: &#123;
    &quot;babel-core&quot;: &quot;^6.26.3&quot;,
    &quot;babel-loader&quot;: &quot;^7.1.5&quot;,
    &quot;babel-preset-env&quot;: &quot;^1.7.0&quot;,
    &quot;css-loader&quot;: &quot;^1.0.0&quot;,
    &quot;file-loader&quot;: &quot;^2.0.0&quot;,
    &quot;style-loader&quot;: &quot;^0.23.1&quot;,
    &quot;url-loader&quot;: &quot;^1.1.2&quot;,
    &quot;node-sass&quot;: &quot;^4.12.0&quot;,
    &quot;sass-loader&quot;: &quot;^7.2.0&quot;,
    &quot;vue&quot;: &quot;^2.5.2&quot;,
    &quot;vue-hot-reload-api&quot;: &quot;^2.2.4&quot;,
    &quot;vue-html-loader&quot;: &quot;^1.2.4&quot;,
    &quot;vue-loader&quot;: &quot;^15.4.2&quot;,
    &quot;vue-style-loader&quot;: &quot;^3.0.3&quot;,
    &quot;vue-template-compiler&quot;: &quot;^2.5.9&quot;,
    &quot;webpack&quot;: &quot;^4.19.0&quot;,
    &quot;webpack-cli&quot;: &quot;^3.1.0&quot;
  &#125;
&#125;
</code></pre>
<ul>
<li><p>参数说明</p>
<ul>
<li><p><code>name</code> - 包名（包名应该是kebab-case, 即英文单词全小写或者中划线分割）</p>
</li>
<li><p><code>version</code> - 包的版本号（第一版建议<code>1.0.0</code>，具体命名规则<a href="https://www.npmjs.cn/getting-started/semantic-versioning/">看这里</a>）</p>
</li>
<li><p><code>description</code> - 包的描述。在<code>npmjs.com</code>上搜索时会显示，有助于用户在搜索时进行筛选）</p>
</li>
<li><p><code>keywords</code> - 关键字（在npm网站上搜索你这个npm包的关键词）</p>
</li>
<li><p><code>author</code> - 包的作者。格式一般是<code>name &lt;你的邮箱&gt;</code>，一般来说，用<code>vue/react</code>脚手架创建项目的时候会默认这个格式写法, 当然也可以是一个github地址，也可以自定义，但就不那么标准了</p>
</li>
<li><p><code>license</code> - 版权许可证，<code>MIT</code>还是<code>ISC</code>，或者其他都可以，只是我看很多包都是<code>MIT</code></p>
</li>
<li><p><code>contributors</code> - 包的其他贡献者(我没有写这个)</p>
</li>
<li><p>repository - 包代码的Repo信息，包括type和URL,<code>type</code>可以是<code>git</code>或<code>svn</code>，<code>URL</code>则是包的<code>Repo</code>地址,我这里写的<code>git</code>仓库的地址，放着我的组件项目代码，这样在npm包页面就有会个github的入口</p>
</li>
<li><p><code>main</code> - 该字段指定了程序的主入口文件（最好写<code>dist文件夹</code>内已经压缩后的文件）,main文件定义了包的入口文件，在Node.js环境中，语句import  [pkg] from ‘pkg’其实就是导入的mian定义的文件</p>
</li>
<li><p><code>scripts</code> - 指定了运行脚本命令的npm命令行缩写。如 <code>npm start</code>、<code>npm run dev</code>、<code>npm run build</code>等</p>
</li>
<li><p><code>dependencies</code> / <code>devDependencies</code> - 生产/开发环境依赖包列表。它们将会被安装在 <code>node_module</code> 目录下</p>
</li>
<li><p>对于一个开发者来说，<code>dependencies</code>和<code>devDependencies</code>其实没太多区别，因为在执行<code>npm install/yarn add</code>时都会全部下载</p>
<p><code>dependencies</code> 是运行你的包必须安装的依赖，即当用户<code>npm install [package]</code>或者<code>yarn add [package]</code>时，这些依赖也会下载</p>
<p><strong><code>devDependencies</code> 是开发你的包时需要安装的依赖，比如<code>eslint</code>, <code>jest</code>等开发工具，当用户<code>npm install [package]</code>或<code>yarn add [package]</code> 时，这些依赖并不会下载！</strong></p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>我这里版本是1.0.1，是因为我自己后面迭代了一个版本，如果你是第一版，最好是1.0.0</p>
</blockquote>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/18/16ca39fa9623eebc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<ul>
<li><strong>（6）<code>README.md</code></strong></li>
</ul>
<p>这是我的<code>README.md</code>写的东西，最终都会显示在npm的内容介绍里面（也就是上图），各位童鞋如果发包，也请写好<code>README.md</code>哈，毕竟是给人使用的嘛</p>
<pre><code>## our-btn
&gt;一个测试的npm包

# install

​```
npm install our-btn
​```
# use
​```
// main.js
import btn from &#39;our-btn&#39;

Vue.use(btn)
​```
​```
// demo.js
&lt;template&gt;
  &lt;div class=&quot;demo&quot;&gt;
    &lt;btn :text=&quot;msg&quot;&gt;&lt;/btn&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  name: &#39;demo&#39;,
  data () &#123;
    return &#123;
      msg: &#39;成功&#39;
    &#125;
  &#125;
&#125;
&lt;/script&gt;
​```
</code></pre>
<ul>
<li><strong>（7）<code>.npmignore</code></strong></li>
</ul>
<p>这个文件同<code>.gitignore</code>的功能一样，<code>.gitignore</code>是忽略自选的文件上传到github仓库中，而<code>.npmignore</code>则是忽略自选的文件上传到npm上。</p>
<p>但是呢，如果你的项目没有<code>.npmignore</code>文件，但有 <code>.gitignore</code>文件，则发布时会忽略 <code>.gitignore</code>中定义的文件;也就是说，<code>.npmignore</code>的优先级是高于<code>.gitignore</code>的。</p>
<pre><code>.*
*.md
node_modules/
webpack.config.js
src/
</code></pre>
<ul>
<li><strong>（8）安装依赖</strong></li>
</ul>
<p>以上文件都配置好后就可以运行下面命令安装<code>package.json</code>的依赖了，然后就会在你们的目录中生成<code>node_modules</code>文件夹、<code>package-lock.json</code>文件</p>
<pre><code>npm install
复制代码
</code></pre>
<ul>
<li><strong>（9）打包我们的组件</strong></li>
</ul>
<pre><code>npm run build
复制代码
</code></pre>
<ul>
<li><strong>(10) 目录结构</strong></li>
</ul>
<p>下图就是我的目录结构，其中<code>.gitattributes</code>和<code>.gitignore</code>文件你可以忽略，因为我把这个项目放在github仓库，所以才会有这两个文件的。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/18/16ca3a01af177c35?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<h2 id="本地测试组件是否可以用"><a href="#本地测试组件是否可以用" class="headerlink" title="本地测试组件是否可以用"></a>本地测试组件是否可以用</h2><p>在项目中执行如下命令</p>
<pre><code>npm run build // 打包
npm pack // 本地生成一个our-btn-1.0.1.tgz的包
</code></pre>
<p>你自己在你本地新建一个<code>vue/react</code>项目，因为我是vue组件，所以我就新建一个vue项目，取名为<code>test-btn</code>，我们把<code>our-btn-1.0.1.tgz</code>放进我们的本地项目<code>test-btn</code>中</p>
<pre><code>npm install our-btn-1.0.1.tgz
npm run dev // 启动vue项目
</code></pre>
<p>然后在项目的<code>main.js</code>引入我们的包</p>
<pre><code>// src/main.js
// 注意：btn要保持和之前咱们封装组件的index.js一样
import btn from &#39;our-btn&#39; // 引入包

Vue.use(btn)
</code></pre>
<p>在我们demo页面中引用这个组件</p>
<pre><code>// demo.vue
&lt;template&gt;
  &lt;div class=&quot;demo&quot;&gt;
    &lt;btn :text=&quot;msg&quot;&gt;&lt;/btn&gt; 
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  name: &#39;demo&#39;,
  data () &#123;
    return &#123;
      msg: &#39;成功&#39;
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>若测试可用，在测试项目<code>test-btn</code>中运行<code>npm uninstall our-btn</code>卸载插件，然后那么就可以发布到npm包上了</p>
<h2 id="发布到npm"><a href="#发布到npm" class="headerlink" title="发布到npm"></a>发布到npm</h2><ul>
<li><strong>（1）注册npm账号</strong></li>
</ul>
<p>发布之前，你得注册一个npm账号吧，不然你怎么上传呢，建议上<a href="https://www.npmjs.com/signup">官网注册</a>一个账号（顺便熟悉那个网站），注册完账号之后，我们就要在本地登录并发布我们的组件了</p>
<blockquote>
<p>提示：因为有点童鞋会经常用cnpm源，所以呢，<strong>一定要切换到npm源上才可以</strong>，不然就会报出如下错误</p>
<pre><code>error: no_perms Private mode enable, only admin can publish this module
复制代码
</code></pre>
<p>因此你要切换到npm源，通过<code>npm config set registry http://registry.npmjs.org</code>命令</p>
</blockquote>
<ul>
<li><strong>（2）开始发布</strong></li>
</ul>
<p>在发包之前，先去npm官网搜索一下有没有和你包名相同的，如果相同就改一个其他的名字吧</p>
<pre><code>npm login // 登陆npm
// 然后输入你的账号、密码、邮箱
// 当你在控制台看到 Logged in as &lt;Username&gt; on https://registry.npmjs.org  说明登陆成功

// 如果你保证是最新版本且已经打包过，则跳过npm run build这一步
npm run build 
npm publish // 发布你的包（如果你出现👇，显示 +[package]@版本信息 ，那就发布成功了）
</code></pre>
<p>👇这是我的输入及其对应显示的东西</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/20/16cae60dc08d79bf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/20/16cae60eb2509ee4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p>🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉🎉此时此刻你的包已经发布成功！！！🎉🎉🎉🎉🎉🎉🎉🎉🎉</p>
<blockquote>
<p>⚠️<strong>拓展知识</strong>：一个版本只能发布一次，也就是你不能发了<code>1.0.0</code>，下次还继续<code>1.0.0</code>，理论上可以覆盖，但是npm不允许这样，因为你这样覆盖，就无法知道你的版本信息了啊，插件和项目都是迭代的，like git，是有版本信息的。</p>
<p>​    方法一：每一次<code>npm publish</code>前，自行手动更改<code>package.json</code>的version</p>
<p>​    方法二：通过以下命令来发布</p>
<pre><code>假设初始版本为1.0.0
➜ npm version preminor （执行这个命令，就会价格当前包发布为版本v0.1.0-0）
v1.0.0-0
➜ npm version prepatch
v1.0.1-0
➜ npm version patch    （执行这个命令，就会价格当前包发布为版本v1.0.1）
v1.0.1
</code></pre>
</blockquote>
<h2 id="查看npm-amp-amp-使用我们的包"><a href="#查看npm-amp-amp-使用我们的包" class="headerlink" title="查看npm &amp;&amp; 使用我们的包"></a>查看npm &amp;&amp; 使用我们的包</h2><p>​    这个时候，你稍微等几分钟去npm官网搜索一下你的包名字，就可以找到啦。如果搜不到，那就再等等，或许更新慢，没有完全更新，但是你在自己npm账号可以查看到自己发布的包</p>
<p>​    你自己在你本地新建一个<code>vue/react</code>项目，因为我是vue组件，所以我就新建一个vue项目，具体使用包的方法就是（以我的测试包为例）</p>
<pre><code class="pseudocode">npm install our-btn // 安装我们的包
</code></pre>
<p>然后在项目的<code>main.js</code>引入我们的包</p>
<pre><code class="javascript">// src/main.js
// 注意：btn要保持和之前咱们封装组件的index.js一样
import btn from &#39;our-btn&#39; // 引入包

Vue.use(btn)
</code></pre>
<p>在我们demo页面中引用这个组件</p>
<pre><code class="javascript">// demo.vue
&lt;template&gt;
  &lt;div class=&quot;demo&quot;&gt;
    &lt;btn :text=&quot;msg&quot;&gt;&lt;/btn&gt; 
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default &#123;
  name: &#39;demo&#39;,
  data () &#123;
    return &#123;
      msg: &#39;成功&#39;
    &#125;
  &#125;
&#125;
&lt;/script&gt;
</code></pre>
<p>转载于:<a href="https://juejin.cn/post/6844903918414102535">使用npm发布一个vue组件</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>转载</tag>
        <tag>Npm</tag>
      </tags>
  </entry>
  <entry>
    <title>前端中常见字节编码(base64、hex、utf8)及其转换</title>
    <url>/2021/05/07/%E5%89%8D%E7%AB%AF%E4%B8%AD%E5%B8%B8%E8%A7%81%E5%AD%97%E8%8A%82%E7%BC%96%E7%A0%81(base64%E3%80%81hex%E3%80%81utf8)%E5%8F%8A%E5%85%B6%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>前端中常见字节编码(base64、hex、utf8)及其转换…</p>
<span id="more"></span>

<p>本文章向大家介绍前端中常见字节编码(base64、hex、utf8)及其转换，主要包括前端中常见字节编码(base64、hex、utf8)及其转换使用实例、应用技巧、基本知识点总结和需要注意事项，具有一定的参考价值，需要的朋友可以参考一下。</p>
<pre><code class="javascript">/*
* 字节编码转换
* 首先都需要转为二级制数组 (ArrayBuffer)
* 然后才能转换对应的编码字符
* 前端常见编码：
* base64：就是将二进制转为字符串,将每6个字节转为一个特定的字符串(A-Za-z0-9/+=)。
* hex：将二进制每8个字节转为对应的2个十六进制的字符串
* */

// utf8 转为 base64/hex
let output = Buffer.from(&#39;utf8的字符串&#39;, &#39;utf8&#39;)
console.log(output.toString(&#39;base64&#39;))
console.log(output.toString(&#39;hex&#39;))


// base64/hex 转为 utf8
output = Buffer.from(&#39;75746638e79a84e5ad97e7aca6e4b8b2&#39;, &#39;hex&#39;)
console.log(output.toString(&#39;utf8&#39;))
output = Buffer.from(&#39;dXRmOOeahOWtl+espuS4sg==&#39;, &#39;base64&#39;)
console.log(output.toString(&#39;utf8&#39;))


// 读取文件传入编码
input = fs.readFileSync(&#39;test.txt&#39;)  // 默认是二进制 Buffer
console.log(input)
let input = fs.readFileSync(&#39;test.txt&#39;, &#39;utf8&#39;)
console.log(input)
input = fs.readFileSync(&#39;test.txt&#39;, &#39;base64&#39;)
console.log(input)
input = fs.readFileSync(&#39;test.txt&#39;, &#39;hex&#39;)
console.log(input)
</code></pre>
<p>　　</p>
<pre><code>/*
* 加密需注意
* 加密数据类型：Buffer 或者 字符串(hex/base64/utf8)
* 参数传入参数：vi - 填充
* 参数传入参数：mode - 模式
* 参数传入参数：padding - 填充类型
* 加密输出类型：Buffer 或者 字符串(hex/base64/utf8)
* */
</code></pre>
<p>　　</p>
<p>原文地址：<a href="https://www.cnblogs.com/jiebba/p/12023652.html">https://www.cnblogs.com/jiebba/p/12023652.html</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>前端鉴权的兄弟们：cookie、session、token、jwt、单点登录</title>
    <url>/2021/08/17/%E5%89%8D%E7%AB%AF%E9%89%B4%E6%9D%83%E7%9A%84%E5%85%84%E5%BC%9F%E4%BB%AC%EF%BC%9Acookie%E3%80%81session%E3%80%81token%E3%80%81jwt%E3%80%81%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95/</url>
    <content><![CDATA[<p>cookie、session、token、jwt、单点登录…</p>
<span id="more"></span>


<p>本文你将看到：</p>
<ul>
<li>基于 HTTP 的前端鉴权背景</li>
<li>cookie 为什么是最方便的存储方案，有哪些操作 cookie 的方式</li>
<li>session 方案是如何实现的，存在哪些问题</li>
<li>token 方案是如何实现的，如何进行编码和防篡改？jwt 是做什么的？refresh token 的实现和意义</li>
<li>session 和 token 有什么异同和优缺点</li>
<li>单点登录是什么？实现思路和在浏览器下的处理</li>
</ul>
<blockquote>
<p>小广告：长期内推滴滴：<a href="https://link.juejin.cn/?target=mailto:why318why@gmail.com">why318why@gmail.com</a></p>
</blockquote>
<hr>
<h1 id="从状态说起"><a href="#从状态说起" class="headerlink" title="从状态说起"></a>从状态说起</h1><p><strong>HTTP 无状态</strong></p>
<p>我们知道，HTTP 是无状态的。也就是说，HTTP 请求方和响应方间无法维护状态，都是一次性的，它不知道前后的请求都发生了什么。</p>
<p>但有的场景下，我们需要维护状态。最典型的，一个用户登陆微博，发布、关注、评论，都应是在登录后的用户状态下的。</p>
<p><strong>标记</strong></p>
<p>那解决办法是什么呢？::标记::。</p>
<blockquote>
<p>在学校或公司，入学入职那一天起，会录入你的身份、账户信息，然后给你发个卡，今后在园区内，你的门禁、打卡、消费都只需要刷这张卡。</p>
</blockquote>
<p><strong>前端存储</strong></p>
<p>这就涉及到一发、一存、一带，发好办，登陆接口直接返回给前端，存储就需要前端想办法了。</p>
<blockquote>
<p>前提是，你要把卡带在身上。</p>
</blockquote>
<p>前端的存储方式有很多。</p>
<ul>
<li>最矬的，挂到全局变量上，但这是个「体验卡」，一次刷新页面就没了</li>
<li>高端点的，存到 cookie、localStorage 等里，这属于「会员卡」，无论怎么刷新，只要浏览器没清掉或者过期，就一直拿着这个状态。</li>
</ul>
<p>前端存储这里不展开了。</p>
<p>有地方存了，请求的时候就可以拼到参数里带给接口了。</p>
<hr>
<h1 id="基石：cookie"><a href="#基石：cookie" class="headerlink" title="基石：cookie"></a>基石：cookie</h1><blockquote>
<p>可是前端好麻烦啊，又要自己存，又要想办法带出去，有没有不用操心的？</p>
</blockquote>
<p>有，cookie。</p>
<p>cookie 也是前端存储的一种，但相比于 localStorage 等其他方式，借助 HTTP 头、浏览器能力，cookie 可以做到前端无感知。</p>
<p>一般过程是这样的：</p>
<ul>
<li>在提供标记的接口，通过 HTTP 返回头的 Set-Cookie 字段，直接「种」到浏览器上</li>
<li>浏览器发起请求时，会自动把 cookie 通过 HTTP 请求头的 Cookie 字段，带给接口<br>1</li>
</ul>
<p><strong>配置：Domain / Path</strong></p>
<blockquote>
<p>你不能拿清华的校园卡进北大。</p>
</blockquote>
<p>cookie 是要限制::「空间范围」::的，通过 Domain（域）/ Path（路径）两级。</p>
<blockquote>
<p>Domain属性指定浏览器发出 HTTP 请求时，哪些域名要附带这个 Cookie。如果没有指定该属性，浏览器会默认将其设为当前 URL 的一级域名，比如 <a href="https://link.juejin.cn/?target=http://www.example.com">www.example.com</a> 会设为 example.com，而且以后如果访问example.com的任何子域名，HTTP 请求也会带上这个 Cookie。如果服务器在Set-Cookie字段指定的域名，不属于当前域名，浏览器会拒绝这个 Cookie。</p>
<p>Path属性指定浏览器发出 HTTP 请求时，哪些路径要附带这个 Cookie。只要浏览器发现，Path属性是 HTTP 请求路径的开头一部分，就会在头信息里面带上这个 Cookie。比如，PATH属性是/，那么请求/docs路径也会包含该 Cookie。当然，前提是域名必须一致。</p>
<p>—— <a href="https://link.juejin.cn/?target=https://javascript.ruanyifeng.com/bom/cookie.html">Cookie — JavaScript 标准参考教程（alpha）</a></p>
</blockquote>
<p><strong>配置：Expires / Max-Age</strong></p>
<blockquote>
<p>你毕业了卡就不好使了。</p>
</blockquote>
<p>cookie 还可以限制::「时间范围」::，通过 Expires、Max-Age 中的一种。</p>
<blockquote>
<p>Expires属性指定一个具体的到期时间，到了指定时间以后，浏览器就不再保留这个 Cookie。它的值是 UTC 格式。如果不设置该属性，或者设为null，Cookie 只在当前会话（session）有效，浏览器窗口一旦关闭，当前 Session 结束，该 Cookie 就会被删除。另外，浏览器根据本地时间，决定 Cookie 是否过期，由于本地时间是不精确的，所以没有办法保证 Cookie 一定会在服务器指定的时间过期。</p>
<p>Max-Age属性指定从现在开始 Cookie 存在的秒数，比如60 * 60 * 24 * 365（即一年）。过了这个时间以后，浏览器就不再保留这个 Cookie。</p>
<p>如果同时指定了Expires和Max-Age，那么Max-Age的值将优先生效。</p>
<p>如果Set-Cookie字段没有指定Expires或Max-Age属性，那么这个 Cookie 就是 Session Cookie，即它只在本次对话存在，一旦用户关闭浏览器，浏览器就不会再保留这个 Cookie。</p>
<p>—— <a href="https://link.juejin.cn/?target=https://javascript.ruanyifeng.com/bom/cookie.html">Cookie — JavaScript 标准参考教程（alpha）</a></p>
</blockquote>
<p><strong>配置：Secure / HttpOnly</strong></p>
<blockquote>
<p>有的学校规定，不带卡套不让刷（什么奇葩学校，假设）；有的学校不让自己给卡贴贴纸。</p>
</blockquote>
<p>cookie 可以限制::「使用方式」::。</p>
<blockquote>
<p>Secure属性指定浏览器只有在加密协议 HTTPS 下，才能将这个 Cookie 发送到服务器。另一方面，如果当前协议是 HTTP，浏览器会自动忽略服务器发来的Secure属性。该属性只是一个开关，不需要指定值。如果通信是 HTTPS 协议，该开关自动打开。</p>
<p>HttpOnly属性指定该 Cookie 无法通过 JavaScript 脚本拿到，主要是Document.cookie属性、XMLHttpRequest对象和 Request API 都拿不到该属性。这样就防止了该 Cookie 被脚本读到，只有浏览器发出 HTTP 请求时，才会带上该 Cookie。</p>
<p>—— <a href="https://link.juejin.cn/?target=https://javascript.ruanyifeng.com/bom/cookie.html">Cookie — JavaScript 标准参考教程（alpha）</a></p>
</blockquote>
<p><strong>HTTP 头对 cookie 的读写</strong></p>
<p>回过头来，HTTP 是如何写入和传递 cookie 及其配置的呢？</p>
<p>HTTP 返回的一个 Set-Cookie 头用于向浏览器写入「一条（且只能是一条）」cookie，格式为 cookie 键值 + 配置键值。例如：</p>
<pre><code>Set-Cookie: username=jimu; domain=jimu.com; path=/blog; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly
</code></pre>
<p>那我想一次多 set 几个 cookie 怎么办？多给几个 Set-Cookie 头（一次 HTTP 请求中允许重复）</p>
<pre><code>Set-Cookie: username=jimu; domain=jimu.com
Set-Cookie: height=180; domain=me.jimu.com
Set-Cookie: weight=80; domain=me.jimu.com
</code></pre>
<p>HTTP 请求的 Cookie 头用于浏览器把符合当前「空间、时间、使用方式」配置的所有 cookie 一并发给服务端。因为由浏览器做了筛选判断，就不需要归还配置内容了，只要发送键值就可以。</p>
<pre><code>Cookie: username=jimu; height=180; weight=80
</code></pre>
<p><strong>前端对 cookie 的读写</strong></p>
<p>前端可以自己创建 cookie，如果服务端创建的 cookie 没加<code>HttpOnly</code>，那恭喜你也可以修改他给的 cookie。</p>
<p>调用<code>document.cookie</code>可以创建、修改 cookie，和 HTTP 一样，一次<code>document.cookie</code>能且只能操作一个 cookie。</p>
<pre><code class="js">document.cookie = &#39;username=jimu; domain=jimu.com; path=/blog; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly&#39;;
</code></pre>
<p>调用<code>document.cookie</code>也可以读到 cookie，也和 HTTP 一样，能读到所有的非<code>HttpOnly</code> cookie。</p>
<pre><code class="js">console.log(document.cookie);
// username=jimu; height=180; weight=80
</code></pre>
<p>（就一个 cookie 属性，为什么读写行为不一样？get / set 了解下）</p>
<p><strong>cookie 是维持 HTTP 请求状态的基石</strong></p>
<p>了解了 cookie 后，我们知道 cookie 是最便捷的维持 HTTP 请求状态的方式，大多数前端鉴权问题都是靠 cookie 解决的。当然也可以选用别的存储方式（后面也会多多少少提到）。</p>
<p>那有了存储工具，接下来怎么做呢？</p>
<hr>
<h1 id="应用方案：服务端-session"><a href="#应用方案：服务端-session" class="headerlink" title="应用方案：服务端 session"></a>应用方案：服务端 session</h1><p>现在回想下，你刷卡的时候发生了什么？</p>
<blockquote>
<p>其实你的卡上只存了一个 id（可能是你的学号），刷的时候物业系统去查你的信息、账户，再决定「这个门你能不能进」「这个鸡腿去哪个账户扣钱」。</p>
</blockquote>
<p>这种操作，在前后端鉴权系统中，叫 session。</p>
<p>典型的 session 登陆/验证流程：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/37adb2019d064967923a659848870771~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p>
<ul>
<li>浏览器登录发送账号密码，服务端查用户库，校验用户</li>
<li>服务端把用户登录状态存为 Session，生成一个 sessionId</li>
<li>通过登录接口返回，把 sessionId set 到 cookie 上</li>
<li>此后浏览器再请求业务接口，sessionId 随 cookie 带上</li>
<li>服务端查 sessionId 校验 session</li>
<li>成功后正常做业务处理，返回结果</li>
</ul>
<p><strong>Session 的存储方式</strong></p>
<p>显然，服务端只是给 cookie 一个 sessionId，而 session 的具体内容（可能包含用户信息、session 状态等），要自己存一下。存储的方式有几种：</p>
<ul>
<li>Redis（推荐）：内存型数据库，<a href="https://link.juejin.cn/?target=http://www.redis.cn/">redis中文官方网站</a>。以 key-value 的形式存，正合 sessionId-sessionData 的场景；且访问快。</li>
<li>内存：直接放到变量里。一旦服务重启就没了</li>
<li>数据库：普通数据库。性能不高。</li>
</ul>
<p><strong>Session 的过期和销毁</strong></p>
<p>很简单，只要把存储的 session 数据销毁就可以。</p>
<p><strong>Session 的分布式问题</strong></p>
<p>通常服务端是集群，而用户请求过来会走一次负载均衡，不一定打到哪台机器上。那一旦用户后续接口请求到的机器和他登录请求的机器不一致，或者登录请求的机器宕机了，session 不就失效了吗？</p>
<p>这个问题现在有几种解决方式。</p>
<ul>
<li>一是从「存储」角度，把 session 集中存储。如果我们用独立的 Redis 或普通数据库，就可以把 session 都存到一个库里。</li>
<li>二是从「分布」角度，让相同 IP 的请求在负载均衡时都打到同一台机器上。以 nginx 为例，可以配置 ip_hash 来实现。</li>
</ul>
<p>但通常还是采用第一种方式，因为第二种相当于阉割了负载均衡，且仍没有解决「用户请求的机器宕机」的问题。</p>
<p><strong>node.js 下的 session 处理</strong></p>
<p>前面的图很清楚了，服务端要实现对 cookie 和 session 的存取，实现起来要做的事还是很多的。在<code>npm</code>中，已经有封装好的中间件，比如 <a href="https://link.juejin.cn/?target=https://www.npmjs.com/package/express-session">express-session  -  npm</a>，用法就不贴了。</p>
<p>这是它种的 cookie：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c32c502d26149808bed72c85fea5a97~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p>
<p><a href="https://link.juejin.cn/?target=https://www.npmjs.com/package/express-session">express-session  -  npm</a> 主要实现了：</p>
<ul>
<li>封装了对cookie的读写操作，并提供配置项配置字段、加密方式、过期时间等。</li>
<li>封装了对session的存取操作，并提供配置项配置session存储方式（内存/redis）、存储规则等。</li>
<li>给req提供了session属性，控制属性的set/get并响应到cookie和session存取上，并给req.session提供了一些方法。</li>
</ul>
<hr>
<h1 id="应用方案：token"><a href="#应用方案：token" class="headerlink" title="应用方案：token"></a>应用方案：token</h1><p>session 的维护给服务端造成很大困扰，我们必须找地方存放它，又要考虑分布式的问题，甚至要单独为了它启用一套 Redis 集群。有没有更好的办法？</p>
<blockquote>
<p>我又想到学校，在没有校园卡技术以前，我们都靠「学生证」。 门卫小哥直接对照我和学生证上的脸，确认学生证有效期、年级等信息，就可以放行了。</p>
</blockquote>
<p>回过头来想想，一个登录场景，也不必往 session 存太多东西，那为什么不直接打包到 cookie 中呢？这样服务端不用存了，每次只要核验 cookie 带的「证件」有效性就可以了，也可以携带一些轻量的信息。</p>
<p>这种方式通常被叫做 token。</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a1c57a08eb204f528256f3980c721148~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p>
<p>token 的流程是这样的：</p>
<ul>
<li>用户登录，服务端校验账号密码，获得用户信息</li>
<li>把用户信息、token 配置编码成 token，通过 cookie set 到浏览器</li>
<li>此后用户请求业务接口，通过 cookie 携带 token</li>
<li>接口校验 token 有效性，进行正常业务接口处理</li>
</ul>
<p><strong>客户端 token 的存储方式</strong></p>
<p>在前面 cookie 说过，cookie 并不是客户端存储凭证的唯一方式。token 因为它的「无状态性」，有效期、使用限制都包在 token 内容里，对 cookie 的管理能力依赖较小，客户端存起来就显得更自由。但 web 应用的主流方式仍是放在 cookie 里，毕竟少操心。</p>
<p><strong>token 的过期</strong></p>
<p>那我们如何控制 token 的有效期呢？很简单，把「过期时间」和数据一起塞进去，验证时判断就好。</p>
<h2 id="token-的编码"><a href="#token-的编码" class="headerlink" title="token 的编码"></a>token 的编码</h2><p>编码的方式丰俭由人。</p>
<p><strong>base64</strong></p>
<p>比如 node 端的 <a href="https://link.juejin.cn/?target=https://www.npmjs.com/package/cookie-session">cookie-session  -  npm</a> 库</p>
<blockquote>
<p>不要纠结名字，其实是个 token 库，但保持了和 <a href="https://link.juejin.cn/?target=https://www.npmjs.com/package/express-session">express-session  -  npm</a> 高度一致的用法，把要存的数据挂在 session 上</p>
</blockquote>
<p>默认配置下，当我给他一个 userid，他会存成这样：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f05aee1b10d24bc7a6a9a42d99529562~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p>
<p>这里的 <code>eyJ1c2VyaWQiOiJhIn0=</code>，就是 <code>&#123;&quot;userid&quot;:&quot;abb”&#125;</code> 的 base64 而已。</p>
<p><strong>防篡改</strong></p>
<blockquote>
<p>那问题来了，如果用户 cdd 拿<code>&#123;&quot;userid&quot;:&quot;abb”&#125;</code>转了个 base64，再手动修改了自己的 token 为 <code>eyJ1c2VyaWQiOiJhIn0=</code>，是不是就能直接访问到 abb 的数据了？</p>
</blockquote>
<p>是的。所以看情况，如果 token 涉及到敏感权限，就要想办法避免 token 被篡改。</p>
<p>解决方案就是给 token 加签名，来识别 token 是否被篡改过。例如在 <a href="https://link.juejin.cn/?target=https://www.npmjs.com/package/cookie-session">cookie-session  -  npm</a> 库中，增加两项配置：</p>
<pre><code>secret: &#39;iAmSecret&#39;,
signed: true,
</code></pre>
<p>这样会多种一个 .sig cookie，里面的值就是 <code>&#123;&quot;userid&quot;:&quot;abb”&#125;</code> 和 <code>iAmSecret</code>通过加密算法计算出来的，常见的比如<a href="https://link.juejin.cn/?target=https://docs.microsoft.com/zh-cn/dotnet/api/system.security.cryptography.hmacsha256?redirectedfrom=MSDN&view=netframework-4.8">HMACSHA256 类 (System.Security.Cryptography) | Microsoft Docs</a>。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fb5955e681724ee084e6f46aa6e45666~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p>
<p>好了，现在 cdd 虽然能伪造出<code>eyJ1c2VyaWQiOiJhIn0=</code>，但伪造不出 sig 的内容，因为他不知道 secret。</p>
<p><strong>JWT</strong></p>
<p>但上面的做法额外增加了 cookie 数量，数据本身也没有规范的格式，所以 <a href="https://link.juejin.cn/?target=https://jwt.io/introduction/">JSON Web Token Introduction - jwt.io</a> 横空出世了。</p>
<blockquote>
<p>JSON Web Token (JWT) 是一个开放标准，定义了一种传递 JSON 信息的方式。这些信息通过数字签名确保可信。</p>
</blockquote>
<p>它是一种成熟的 token 字符串生成方案，包含了我们前面提到的数据、签名。不如直接看一下一个 JWT token 长什么样：</p>
<pre><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyaWQiOiJhIiwiaWF0IjoxNTUxOTUxOTk4fQ.2jf3kl_uKWRkwjOP6uQRJFqMlwSABcgqqcJofFH5XCo 
</code></pre>
<p>这串东西是怎么生成的呢？看图：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65b5e67305f84e9391de2d5b436600e7~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p>
<p>类型、加密算法的选项，以及 JWT 标准数据字段，可以参考 <a href="https://link.juejin.cn/?target=https://tools.ietf.org/html/rfc7519%23section-4.1">RFC 7519 - JSON Web Token (JWT)</a></p>
<p>node 上同样有相关的库实现：<a href="https://link.juejin.cn/?target=https://www.npmjs.com/package/express-jwt">express-jwt  -  npm</a> <a href="https://link.juejin.cn/?target=https://www.npmjs.com/package/koa-jwt">koa-jwt  -  npm</a></p>
<h2 id="refresh-token"><a href="#refresh-token" class="headerlink" title="refresh token"></a>refresh token</h2><p>token，作为权限守护者，最重要的就是「安全」。</p>
<p>业务接口用来鉴权的 token，我们称之为 access token。越是权限敏感的业务，我们越希望 access token 有效期足够短，以避免被盗用。但过短的有效期会造成 access token 经常过期，过期后怎么办呢？</p>
<p>一种办法是，让用户重新登录获取新 token，显然不够友好，要知道有的 access token 过期时间可能只有几分钟。</p>
<p>另外一种办法是，再来一个 token，一个专门生成 access token 的 token，我们称为 refresh token。</p>
<ul>
<li>access token 用来访问业务接口，由于有效期足够短，盗用风险小，也可以使请求方式更宽松灵活</li>
<li>refresh token 用来获取 access token，有效期可以长一些，通过独立服务和严格的请求方式增加安全性；由于不常验证，也可以如前面的 session 一样处理</li>
</ul>
<p>有了 refresh token 后，几种情况的请求流程变成这样：</p>
<p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b764b256211b4ea182388fd92674fe70~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p>
<p>如果 refresh token 也过期了，就只能重新登录了。</p>
<h2 id="session-和-token"><a href="#session-和-token" class="headerlink" title="session 和 token"></a>session 和 token</h2><p>session 和 token 都是边界很模糊的概念，就像前面说的，refresh token 也可能以 session 的形式组织维护。</p>
<p>狭义上，我们通常认为 session 是「种在 cookie 上、数据存在服务端」的认证方案，token 是「客户端存哪都行、数据存在 token 里」的认证方案。对 session 和 token 的对比本质上是「客户端存 cookie / 存别地儿」、「服务端存数据 / 不存数据」的对比。</p>
<p><strong>客户端存 cookie / 存别地儿</strong></p>
<p>存 cookie 固然方便不操心，但问题也很明显：</p>
<ul>
<li>在浏览器端，可以用 cookie（实际上 token 就常用 cookie），但出了浏览器端，没有 cookie 怎么办？</li>
<li>cookie 是浏览器在域下自动携带的，这就容易引发 CSRF 攻击（<a href="https://link.juejin.cn/?target=https://tech.meituan.com/2018/10/11/fe-security-csrf.html">前端安全系列（二）：如何防止CSRF攻击？ - 美团技术团队</a>）</li>
</ul>
<p>存别的地方，可以解决没有 cookie 的场景；通过参数等方式手动带，可以避免 CSRF 攻击。</p>
<p><strong>服务端存数据 / 不存数据</strong></p>
<ul>
<li>存数据：请求只需携带 id，可以大幅缩短认证字符串长度，减小请求体积</li>
<li>不存数据：不需要服务端整套的解决方案和分布式处理，降低硬件成本；避免查库带来的验证延迟</li>
</ul>
<hr>
<h1 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h1><p>前面我们已经知道了，在同域下的客户端/服务端认证系统中，通过客户端携带凭证，维持一段时间内的登录状态。</p>
<p>但当我们业务线越来越多，就会有更多业务系统分散到不同域名下，就需要「一次登录，全线通用」的能力，叫做「单点登录」。</p>
<h2 id="“虚假”的单点登录（主域名相同）"><a href="#“虚假”的单点登录（主域名相同）" class="headerlink" title="“虚假”的单点登录（主域名相同）"></a>“虚假”的单点登录（主域名相同）</h2><p>简单的，如果业务系统都在同一主域名下，比如<code>wenku.baidu.com</code> <code>tieba.baidu.com</code>，就好办了。可以直接把 cookie domain 设置为主域名 <code>baidu.com</code>，百度也就是这么干的。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/65e37941080a4aceb234b74845647f6c~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p>
<h2 id="“真实”的单点登录（主域名不同）"><a href="#“真实”的单点登录（主域名不同）" class="headerlink" title="“真实”的单点登录（主域名不同）"></a>“真实”的单点登录（主域名不同）</h2><p>比如滴滴这么潮的公司，同时拥有<code>didichuxing.com</code> <code>xiaojukeji.com</code> <code>didiglobal.com</code>等域名，种 cookie 是完全绕不开的。</p>
<p>这要能实现「一次登录，全线通用」，才是真正的单点登录。</p>
<p>这种场景下，我们需要独立的认证服务，通常被称为 SSO。</p>
<p><strong>一次「从 A 系统引发登录，到 B 系统不用登录」的完整流程</strong></p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf2e8ba61fc94b52be164c207b9d8358~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p>
<ul>
<li>用户进入 A 系统，没有登录凭证（ticket），A 系统给他跳到 SSO</li>
<li>SSO 没登录过，也就没有 sso 系统下没有凭证（注意这个和前面 A ticket 是两回事），输入账号密码登录</li>
<li>SSO 账号密码验证成功，通过接口返回做两件事：一是种下 sso 系统下凭证（记录用户在 SSO 登录状态）；二是下发一个 ticket</li>
<li>客户端拿到 ticket，保存起来，带着请求系统 A 接口</li>
<li>系统 A 校验 ticket，成功后正常处理业务请求</li>
<li>此时用户第一次进入系统 B，没有登录凭证（ticket），B 系统给他跳到 SSO</li>
<li>SSO 登录过，系统下有凭证，不用再次登录，只需要下发 ticket</li>
<li>客户端拿到 ticket，保存起来，带着请求系统 B 接口</li>
</ul>
<p><strong>完整版本：考虑浏览器的场景</strong></p>
<p>上面的过程看起来没问题，实际上很多 APP 等端上这样就够了。但在浏览器下不见得好用。</p>
<p>看这里：</p>
<p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a2513e31953c457fa4245f6a0f525b5a~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p>
<p>对浏览器来说，SSO 域下返回的数据要怎么存，才能在访问 A 的时候带上？浏览器对跨域有严格限制，cookie、localStorage 等方式都是有域限制的。</p>
<p>这就需要也只能由 A 提供 A 域下存储凭证的能力。一般我们是这么做的：</p>
<p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e5a94e9c990d4d69a4a0845c4f8dc6a1~tplv-k3u1fbpfcp-watermark.awebp" alt="img"></p>
<p>图中我们通过颜色把浏览器当前所处的域名标记出来。注意图中灰底文字说明部分的变化。</p>
<ul>
<li>在 SSO 域下，SSO 不是通过接口把 ticket 直接返回，而是通过一个带 code 的 URL 重定向到系统 A 的接口上，这个接口通常在 A 向 SSO 注册时约定</li>
<li>浏览器被重定向到 A 域下，带着 code 访问了 A 的 callback 接口，callback 接口通过 code 换取 ticket</li>
<li>这个 code 不同于 ticket，code 是一次性的，暴露在 URL 中，只为了传一下换 ticket，换完就失效</li>
<li>callback 接口拿到 ticket 后，在自己的域下 set cookie 成功</li>
<li>在后续请求中，只需要把 cookie 中的 ticket 解析出来，去 SSO 验证就好</li>
<li>访问 B 系统也是一样</li>
</ul>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>HTTP 是无状态的，为了维持前后请求，需要前端存储标记</li>
<li>cookie 是一种完善的标记方式，通过 HTTP 头或 js 操作，有对应的安全策略，是大多数状态管理方案的基石</li>
<li>session 是一种状态管理方案，前端通过 cookie 存储 id，后端存储数据，但后端要处理分布式问题</li>
<li>token 是另一种状态管理方案，相比于 session 不需要后端存储，数据全部存在前端，解放后端，释放灵活性</li>
<li>token 的编码技术，通常基于 base64，或增加加密算法防篡改，jwt 是一种成熟的编码方案</li>
<li>在复杂系统中，token 可通过 service token、refresh token 的分权，同时满足安全性和用户体验</li>
<li>session 和 token 的对比就是「用不用cookie」和「后端存不存」的对比</li>
<li>单点登录要求不同域下的系统「一次登录，全线通用」，通常由独立的 SSO 系统记录登录状态、下发 ticket，各业务系统配合存储和认证 ticket</li>
</ul>
<p>转载于:<a href="https://juejin.cn/post/6898630134530752520">前端鉴权的兄弟们：cookie、session、token、jwt、单点登录</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>在微信小程序中使用ProtocolBuffer的方法</title>
    <url>/2021/10/14/%E5%9C%A8%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E4%BD%BF%E7%94%A8ProtocolBuffer%E7%9A%84%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>在微信小程序中使用 Protocol Buffer 的方法…</p>
<span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我去年写过一套自用的微服务网关系统，投入线上使用后效果良好，响应格式采用的是使用广泛的 JSON。最近为了使其支持二进制数据的传输，考虑到对二进制数据进行 base64 等格式的编码同时降低了时空性能，一番简单的搜索后，决定采用 Google 推出的 Protocol Buffer(后文简称 protobuf) 作为消息载体格式替换掉 JSON。</p>
<p>在服务端部分完全升级至 protobuf 以后，微信小程序客户端方面的支持却让我恼火了很久，因为官方对于 protobuf 的支持是无动于衷的。在这之前，我本以为在微信小程序端发起请求就像前端一样简单容易。</p>
<h2 id="尝试"><a href="#尝试" class="headerlink" title="尝试"></a>尝试</h2><p>protobuf 是强约定的消息格式，消息必须预先编写语言无关的 proto 文件进行消息定义，然后通过 protoc 编译成目标语言的模型文件。</p>
<p>Google 官方提供的 Javascript 的支持无法在微信小程序平台使用，因为出于安全考虑，微信禁止了诸如动态执行 eval, function 等功能。</p>
<p>社区实现的 protobufjs 的最新版<strong>原版似乎</strong>也不能够在微信小程序平台使用，原因同上。未深入研究。</p>
<p>最终找到的可行的方案：<a href="https://github.com/Zhang19910325/protoBufferForWechat%EF%BC%8C%E6%98%AF%E7%94%B1%E5%9B%BD%E4%BA%BA%E5%AF%B9">https://github.com/Zhang19910325/protoBufferForWechat，是由国人对</a> protobufjs 项目进行修改后的微信适配版，虽然较长时间得不到维护，但依然可用。</p>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>与 Google 的方案一样，protobufjs 也需要我们对 proto 文件进行解析，根据网络上的信息，我们需要首先安装 protobufjs 工具来将 proto 文件转制成 json 格式文件。</p>
<pre><code>npm install -g protobufjs
pbjs -t json my.proto &gt; my.json
</code></pre>
<p>为了方便项目导入，我们需要将 json 文件包装成 js 文件。将 json 文件用模块导出进行包裹：</p>
<pre><code>module.exports = &#123; /* some stuff */ &#125;;
</code></pre>
<p>准备好后，可以自行写一个包处理模块，来处理收发包：</p>
<pre><code class="javascript">&#39;use strict&#39;;

const protobuf = require(&#39;./weichatPb/protobuf.js&#39;);
const requestPacketDefinition = require(&#39;./RequestPacket.js&#39;);
const responsePacketDefinition = require(&#39;./ResponsePacket.js&#39;);
const RequestPacket = protobuf.Root.fromJSON(requestPacketDefinition).Collplex.Models.RequestPacket;
const ResponsePacket = protobuf.Root.fromJSON(responsePacketDefinition).Collplex.Models.ResponsePacket;

module.exports = &#123;
  makeRequestPacket: (payload, clientId, key) =&gt; (RequestPacket.lookup(&#39;RequestPacket&#39;).encode(&#123;
    clientId,
    action: RequestPacket.ActionType.SVC_REQUEST,
    data: RequestPacket.lookup(&#39;ServiceRequest&#39;).encode(&#123;
      key,
      data: JSON.stringify(payload),
    &#125;).finish()
  &#125;).finish()).slice().buffer,
  decodeResponsePacket: data =&gt; ResponsePacket.lookup(&#39;ResponsePacket&#39;).decode(data),
&#125;;
</code></pre>
<h2 id="填坑"><a href="#填坑" class="headerlink" title="填坑"></a>填坑</h2><pre><code class="javascript">wx.request(&#123;
      url: that.apiUrlPrefix,
      data: payload,
      method: &#39;POST&#39;,
      header: &#123;
        &#39;Content-Type&#39;: &#39;application/x-protobuf&#39;
      &#125;,
      dataType: &#39;other&#39;,
      responseType: &#39;arraybuffer&#39;,
&#125;);
</code></pre>
<p>虽然我们在模块里包装好了封包解包的方法，但是还是不能直接在微信小程序中发送的。让我们先来看看 wx.request() 的<a href="https://developers.weixin.qq.com/miniprogram/dev/api/network/request/wx.request.html">官方文档</a>：</p>
<blockquote>
<h3 id="data-参数说明"><a href="#data-参数说明" class="headerlink" title="data 参数说明"></a>data 参数说明</h3><p>最终发送给服务器的数据是 String 类型，<strong>如果传入的 data 不是 String 类型，会被转换成 String</strong> 。转换规则如下：</p>
<ul>
<li>对于 <code>GET</code> 方法的数据，会将数据转换成 query string（<code>encodeURIComponent(k)=encodeURIComponent(v)&amp;encodeURIComponent(k)=encodeURIComponent(v)...</code>）</li>
<li>对于 <code>POST</code> 方法且 <code>header[&#39;content-type&#39;]</code> 为 <code>application/json</code> 的数据，会对数据进行 JSON 序列化</li>
<li>对于 <code>POST</code> 方法且 <code>header[&#39;content-type&#39;]</code> 为 <code>application/x-www-form-urlencoded</code> 的数据，会将数据转换成 query string <code>（encodeURIComponent(k)=encodeURIComponent(v)&amp;encodeURIComponent(k)=encodeURIComponent(v)...）</code></li>
</ul>
</blockquote>
<p>实际测试下来，data 支持三种数据类型：String / Object（会被序列化或转换成 query string）/ ArrayBuffer。因为我们的 protobuf 在二进制序列化后，给出的类型是 Uint8Array，微信小程序会按照 Object 进行编码，导致服务端接收到异常的数据，所以我们应该将 Uint8Array 转换成 ArrayBuffer。</p>
<pre><code class="javascript">Uint8Array.slice().buffer
</code></pre>
<p>我们可以注意到，这里使用了 slice()。这是因为 protobufjs 转换出来的 ArrayBuffer 的缓冲区长度是 8912 字节，如果不进行处理，则会发送至少 8192 个字节给服务端。</p>
<p>准备好发送的数据后，我们就可以收到服务端发送的正确响应了。</p>
<p>如果你的 proto 中包含了以二进制格式存储的字符串，那么需要进行解码提取操作。在模拟器上，可以使用：</p>
<pre><code>new TextDecoder().decode(decodedResponsePacket);
</code></pre>
<p>但是，<strong>在真机上不可以这么做</strong>！因为微信把 TextEncoder 与 TextDecoder 给阉割掉了。我们必须寻找一种替代方案，来手动实现转码：</p>
<pre><code class="javascript">utf8ArrayToStr: array =&gt; &#123;
    let out, i, len, c;
    let char2, char3;
    out = &quot;&quot;;
    len = array.length;
    i = 0;
    while(i &lt; len) &#123;
      c = array[i++];
      switch(c &gt;&gt; 4)
      &#123; 
          case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:
          // 0xxxxxxx
          out += String.fromCharCode(c);
          break;
          case 12: case 13:
          // 110x xxxx   10xx xxxx
          char2 = array[i++];
          out += String.fromCharCode(((c &amp; 0x1F) &lt;&lt; 6) | (char2 &amp; 0x3F));
          break;
          case 14:
          // 1110 xxxx  10xx xxxx  10xx xxxx
          char2 = array[i++];
          char3 = array[i++];
          out += String.fromCharCode(((c &amp; 0x0F) &lt;&lt; 12) |
                        ((char2 &amp; 0x3F) &lt;&lt; 6) |
                        ((char3 &amp; 0x3F) &lt;&lt; 0));
          break;
        &#125;
      &#125;
      return out;
&#125;
</code></pre>
<p>以上代码来自网络，性能较低。可以基本正确地将二进制数据转换为 UTF-8 格式的字符串，但会丢失部分 Emoji 字符。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>如无必要，不要使用非官方支持的格式，太折腾且有风险。本次迁移数据格式也是为了让微服务网关能够兼容后续项目，支持二进制数据而进行的。</p>
<p>最后，新版本微服务框架工作情况尚可，可喜可贺~</p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/CollplexDemo-1024x494.png"></p>
<p>转载于:<a href="https://iedon.com/2020/08/18/790.html">在微信小程序中使用 Protocol Buffer 的方法</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>常用的js工具函数</title>
    <url>/2021/04/08/%E5%B8%B8%E7%94%A8%E7%9A%84js%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>整理一下前端开发中常用的工具方法，有了这些工具函数就可以高效的处理任务和信息了。</p>
<span id="more"></span>
<h4 id="1-邮箱"><a href="#1-邮箱" class="headerlink" title="1.邮箱"></a>1.邮箱</h4><pre><code class="javascript">export const isEmail = (s) =&gt; &#123;
    return /^([a-zA-Z0-9_-])+@([a-zA-Z0-9_-])+((.[a-zA-Z0-9_-]&#123;2,3&#125;)&#123;1,2&#125;)$/.test(s)
&#125;
</code></pre>
<h4 id="2-手机号码"><a href="#2-手机号码" class="headerlink" title="2.手机号码"></a>2.手机号码</h4><pre><code class="javascript">export const isMobile = (s) =&gt; &#123;
    return /^1[0-9]&#123;10&#125;$/.test(s)
&#125;
</code></pre>
<h4 id="3-电话号码"><a href="#3-电话号码" class="headerlink" title="3.电话号码"></a>3.电话号码</h4><pre><code class="javascript">export const isPhone = (s) =&gt; &#123;
    return /^([0-9]&#123;3,4&#125;-)?[0-9]&#123;7,8&#125;$/.test(s)
&#125;
</code></pre>
<h4 id="4-是否为url地址"><a href="#4-是否为url地址" class="headerlink" title="4.是否为url地址"></a>4.是否为url地址</h4><pre><code class="javascript">export const isURL = (s) =&gt; &#123;
    return /^http[s]?:\/\/.*/.test(s)
&#125;
</code></pre>
<h4 id="5-是否字符串"><a href="#5-是否字符串" class="headerlink" title="5.是否字符串"></a>5.是否字符串</h4><pre><code class="javascript">export const isString = (o) =&gt; &#123;
    return Object.prototype.toString.call(o).slice(8, -1) === &#39;String&#39;
&#125;
</code></pre>
<h4 id="6-是否数字"><a href="#6-是否数字" class="headerlink" title="6.是否数字"></a>6.是否数字</h4><pre><code class="javascript">export const isNumber = (o) =&gt; &#123;
    return Object.prototype.toString.call(o).slice(8, -1) === &#39;Number&#39;
&#125;
</code></pre>
<h4 id="7-是否为boolean"><a href="#7-是否为boolean" class="headerlink" title="7.是否为boolean"></a>7.是否为boolean</h4><pre><code class="javascript">export const isBoolean = (o) =&gt; &#123;
    return Object.prototype.toString.call(o).slice(8, -1) === &#39;Boolean&#39;
&#125;
</code></pre>
<h4 id="8-是否为函数"><a href="#8-是否为函数" class="headerlink" title="8.是否为函数"></a>8.是否为函数</h4><pre><code class="javascript">export const isFunction = (o) =&gt; &#123;
    return Object.prototype.toString.call(o).slice(8, -1) === &#39;Function&#39;
&#125;
</code></pre>
<h4 id="9-是否为null"><a href="#9-是否为null" class="headerlink" title="9.是否为null"></a>9.是否为null</h4><pre><code class="javascript">export const isNull = (o) =&gt; &#123;
    return Object.prototype.toString.call(o).slice(8, -1) === &#39;Null&#39;
&#125;
</code></pre>
<h4 id="10-是否为undefined"><a href="#10-是否为undefined" class="headerlink" title="10.是否为undefined"></a>10.是否为undefined</h4><pre><code class="javascript">export const isUndefined = (o) =&gt; &#123;
    return Object.prototype.toString.call(o).slice(8, -1) === &#39;Undefined&#39;
&#125;
</code></pre>
<h4 id="11-是否为对象"><a href="#11-是否为对象" class="headerlink" title="11.是否为对象"></a>11.是否为对象</h4><pre><code class="javascript">export const isObj = (o) =&gt; &#123;
    return Object.prototype.toString.call(o).slice(8, -1) === &#39;Object&#39;
&#125;
</code></pre>
<h4 id="12-是否为数组"><a href="#12-是否为数组" class="headerlink" title="12.是否为数组"></a>12.是否为数组</h4><pre><code class="javascript">export const isArray = (o) =&gt; &#123;
    return Object.prototype.toString.call(o).slice(8, -1) === &#39;Array&#39;
&#125;
</code></pre>
<h4 id="13-是否为时间"><a href="#13-是否为时间" class="headerlink" title="13.是否为时间"></a>13.是否为时间</h4><pre><code class="javascript">export const isDate = (o) =&gt; &#123;
    return Object.prototype.toString.call(o).slice(8, -1) === &#39;Date&#39;
&#125;
</code></pre>
<h4 id="14-是否为正则"><a href="#14-是否为正则" class="headerlink" title="14.是否为正则"></a>14.是否为正则</h4><pre><code class="javascript">export const isRegExp = (o) =&gt; &#123;
    return Object.prototype.toString.call(o).slice(8, -1) === &#39;RegExp&#39;
&#125;
</code></pre>
<h4 id="15-是否为错误对象"><a href="#15-是否为错误对象" class="headerlink" title="15.是否为错误对象"></a>15.是否为错误对象</h4><pre><code class="javascript">export const isError = (o) =&gt; &#123;
    return Object.prototype.toString.call(o).slice(8, -1) === &#39;Error&#39;
&#125;
</code></pre>
<h4 id="16-是否为Symbol函数"><a href="#16-是否为Symbol函数" class="headerlink" title="16.是否为Symbol函数"></a>16.是否为Symbol函数</h4><pre><code class="javascript">export const isSymbol = (o) =&gt; &#123;
    return Object.prototype.toString.call(o).slice(8, -1) === &#39;Symbol&#39;
&#125;
</code></pre>
<h4 id="17-是否为Promise对象"><a href="#17-是否为Promise对象" class="headerlink" title="17.是否为Promise对象"></a>17.是否为Promise对象</h4><pre><code class="javascript">export const isPromise = (o) =&gt; &#123;
    return Object.prototype.toString.call(o).slice(8, -1) === &#39;Promise&#39;
&#125;
</code></pre>
<h4 id="18-是否为Set对象"><a href="#18-是否为Set对象" class="headerlink" title="18.是否为Set对象"></a>18.是否为Set对象</h4><pre><code class="javascript">export const isSet = (o) =&gt; &#123;    
    return Object.prototype.toString.call(o).slice(8, -1) === &#39;Set&#39; 
&#125; 
</code></pre>
<h4 id="19-是否是微信浏览器"><a href="#19-是否是微信浏览器" class="headerlink" title="19.是否是微信浏览器"></a>19.是否是微信浏览器</h4><pre><code class="javascript">export const isWeiXin = () =&gt; &#123;
    return (navigator.userAgent.toLowerCase()).match(/microMessenger/i) == &#39;micromessenger&#39;
&#125;
</code></pre>
<h4 id="20-是否为移动端"><a href="#20-是否为移动端" class="headerlink" title="20.是否为移动端"></a>20.是否为移动端</h4><pre><code class="javascript">export const isDeviceMobile = () =&gt; &#123;
    return /android|webos|iphone|ipod|balckberry/i.test(ua)
&#125;
</code></pre>
<h4 id="21-是否是QQ浏览器"><a href="#21-是否是QQ浏览器" class="headerlink" title="21.是否是QQ浏览器"></a>21.是否是QQ浏览器</h4><pre><code class="javascript">export const isQQBrowser = () =&gt; &#123;
    return !!ua.match(/mqqbrowser|qzone|qqbrowser|qbwebviewtype/i)
&#125;
</code></pre>
<h4 id="22-是否为ios"><a href="#22-是否为ios" class="headerlink" title="22.是否为ios"></a>22.是否为ios</h4><pre><code class="javascript">export const isIos = () =&gt; &#123;
  var u = navigator.userAgent;
  if (u.indexOf(&#39;Android&#39;) &gt; -1 || u.indexOf(&#39;Linux&#39;) &gt; -1) &#123;  
    // 安卓手机
    return false
  &#125; else if (u.indexOf(&#39;iPhone&#39;) &gt; -1) &#123;
    // 苹果手机
    return true
  &#125; else if (u.indexOf(&#39;iPad&#39;) &gt; -1) &#123; 
    // iPad
    return false
  &#125; else if (u.indexOf(&#39;Windows Phone&#39;) &gt; -1) &#123;
    //winphone手机
    return false
  &#125; else &#123;
    return false
  &#125;
&#125;
</code></pre>
<h4 id="23-是否为PC端"><a href="#23-是否为PC端" class="headerlink" title="23.是否为PC端"></a>23.是否为PC端</h4><pre><code class="javascript">export const isPC = () =&gt; &#123;
  var userAgentInfo = navigator.userAgent;
  var Agents = [&quot;Android&quot;, &quot;iPhone&quot;,
    &quot;SymbianOS&quot;, &quot;Windows Phone&quot;,
    &quot;iPad&quot;, &quot;iPod&quot;];
  var flag = true;
  for (var v = 0; v &lt; Agents.length; v++) &#123;
    if (userAgentInfo.indexOf(Agents[v]) &gt; 0) &#123;
      flag = false;
      break;
    &#125;
  &#125;
  return flag;
&#125;
</code></pre>
<h4 id="24-去除html标签"><a href="#24-去除html标签" class="headerlink" title="24.去除html标签"></a>24.去除html标签</h4><pre><code class="javascript">export const removeHtmltag = (str) =&gt; &#123;
    return str.replace(/&lt;[^&gt;]+&gt;/g, &#39;&#39;)
&#125;
</code></pre>
<h4 id="25-获取url参数"><a href="#25-获取url参数" class="headerlink" title="25.获取url参数"></a>25.获取url参数</h4><pre><code class="javascript">export const getQueryString = (name) =&gt; &#123;
  const reg = new RegExp(&#39;(^|&amp;)&#39; + name + &#39;=([^&amp;]*)(&amp;|$)&#39;, &#39;i&#39;);
  const search = window.location.search.split(&#39;?&#39;)[1] || &#39;&#39;;
  const r = search.match(reg) || [];
  return r[2];
&#125;
</code></pre>
<h4 id="26-动态引入js"><a href="#26-动态引入js" class="headerlink" title="26.动态引入js"></a>26.动态引入js</h4><pre><code class="javascript">export const injectScript = (src) =&gt; &#123;
  const s = document.createElement(&#39;script&#39;);
  s.type = &#39;text/javascript&#39;;
  s.async = true;
  s.src = src;
  const t = document.getElementsByTagName(&#39;script&#39;)[0];
  t.parentNode.insertBefore(s, t);
&#125;
</code></pre>
<h4 id="27-根据url地址下载"><a href="#27-根据url地址下载" class="headerlink" title="27.根据url地址下载"></a>27.根据url地址下载</h4><pre><code class="javascript">export const download = (url) =&gt; &#123;
  var isChrome = navigator.userAgent.toLowerCase().indexOf(&#39;chrome&#39;) &gt; -1;
  var isSafari = navigator.userAgent.toLowerCase().indexOf(&#39;safari&#39;) &gt; -1;
  if (isChrome || isSafari) &#123;
    var link = document.createElement(&#39;a&#39;);
    link.href = url;
    if (link.download !== undefined) &#123;
      var fileName = url.substring(url.lastIndexOf(&#39;/&#39;) + 1, url.length);
      link.download = fileName;
    &#125;
    if (document.createEvent) &#123;
      var e = document.createEvent(&#39;MouseEvents&#39;);
      e.initEvent(&#39;click&#39;, true, true);
      link.dispatchEvent(e);
      return true;
    &#125;
  &#125;
  if (url.indexOf(&#39;?&#39;) === -1) &#123;
    url += &#39;?download&#39;;
  &#125;
  window.open(url, &#39;_self&#39;);
  return true;
&#125;
</code></pre>
<h4 id="28-el是否包含某个class"><a href="#28-el是否包含某个class" class="headerlink" title="28.el是否包含某个class"></a>28.el是否包含某个class</h4><pre><code class="javascript">export const hasClass = (el, className) =&gt; &#123;
  let reg = new RegExp(&#39;(^|\\s)&#39; + className + &#39;(\\s|$)&#39;)
  return reg.test(el.className)
&#125;
</code></pre>
<h4 id="29-el添加某个class"><a href="#29-el添加某个class" class="headerlink" title="29.el添加某个class"></a>29.el添加某个class</h4><pre><code class="javascript">export const addClass = (el, className) =&gt; &#123;
  if (hasClass(el, className)) &#123;
    return
  &#125;
  let newClass = el.className.split(&#39; &#39;)
  newClass.push(className)
  el.className = newClass.join(&#39; &#39;)
&#125;
</code></pre>
<h4 id="30-el去除某个class"><a href="#30-el去除某个class" class="headerlink" title="30.el去除某个class"></a>30.el去除某个class</h4><pre><code class="javascript">export const removeClass = (el, className) =&gt; &#123;
  if (!hasClass(el, className)) &#123;
    return
  &#125;
  let reg = new RegExp(&#39;(^|\\s)&#39; + className + &#39;(\\s|$)&#39;, &#39;g&#39;)
  el.className = el.className.replace(reg, &#39; &#39;)
&#125;
</code></pre>
<h4 id="31-获取滚动的坐标"><a href="#31-获取滚动的坐标" class="headerlink" title="31.获取滚动的坐标"></a>31.获取滚动的坐标</h4><pre><code class="javascript">export const getScrollPosition = (el = window) =&gt; (&#123;
  x: el.pageXOffset !== undefined ? el.pageXOffset : el.scrollLeft,
  y: el.pageYOffset !== undefined ? el.pageYOffset : el.scrollTop
&#125;);
</code></pre>
<h4 id="32-滚动到顶部"><a href="#32-滚动到顶部" class="headerlink" title="32.滚动到顶部"></a>32.滚动到顶部</h4><pre><code class="javascript">export const scrollToTop = () =&gt; &#123;
  const c = document.documentElement.scrollTop || document.body.scrollTop;
  if (c &gt; 0) &#123;
    window.requestAnimationFrame(scrollToTop);
    window.scrollTo(0, c - c / 8);
  &#125;
&#125;
</code></pre>
<h4 id="33-el是否在视口范围内"><a href="#33-el是否在视口范围内" class="headerlink" title="33.el是否在视口范围内"></a>33.el是否在视口范围内</h4><pre><code class="javascript">export const elementIsVisibleInViewport = (el, partiallyVisible = false) =&gt; &#123;
  const &#123; top, left, bottom, right &#125; = el.getBoundingClientRect();
  const &#123; innerHeight, innerWidth &#125; = window;
  return partiallyVisible
    ? ((top &gt; 0 &amp;&amp; top &lt; innerHeight) || (bottom &gt; 0 &amp;&amp; bottom &lt; innerHeight)) &amp;&amp;
    ((left &gt; 0 &amp;&amp; left &lt; innerWidth) || (right &gt; 0 &amp;&amp; right &lt; innerWidth))
    : top &gt;= 0 &amp;&amp; left &gt;= 0 &amp;&amp; bottom &lt;= innerHeight &amp;&amp; right &lt;= innerWidth;
&#125;
</code></pre>
<h4 id="34-洗牌算法随机"><a href="#34-洗牌算法随机" class="headerlink" title="34.洗牌算法随机"></a>34.洗牌算法随机</h4><pre><code class="javascript">export const shuffle = (arr) =&gt; &#123;
  var result = [],
    random;
  while (arr.length &gt; 0) &#123;
    random = Math.floor(Math.random() * arr.length);
    result.push(arr[random])
    arr.splice(random, 1)
  &#125;
  return result;
&#125;
</code></pre>
<h4 id="35-劫持粘贴板"><a href="#35-劫持粘贴板" class="headerlink" title="35.劫持粘贴板"></a>35.劫持粘贴板</h4><pre><code class="javascript">export const copyTextToClipboard = (value) =&gt; &#123;
  var textArea = document.createElement(&quot;textarea&quot;);
  textArea.style.background = &#39;transparent&#39;;
  textArea.value = value;
  document.body.appendChild(textArea);
  textArea.select();
  try &#123;
    var successful = document.execCommand(&#39;copy&#39;);
  &#125; catch (err) &#123;
    console.log(&#39;Oops, unable to copy&#39;);
  &#125;
  document.body.removeChild(textArea);
&#125;
</code></pre>
<h4 id="36-判断类型集合"><a href="#36-判断类型集合" class="headerlink" title="36.判断类型集合"></a>36.判断类型集合</h4><pre><code class="javascript">export const checkStr = (str, type) =&gt; &#123;
  switch (type) &#123;
    case &#39;phone&#39;:   //手机号码
      return /^1[3|4|5|6|7|8|9][0-9]&#123;9&#125;$/.test(str);
    case &#39;tel&#39;:     //座机
      return /^(0\d&#123;2,3&#125;-\d&#123;7,8&#125;)(-\d&#123;1,4&#125;)?$/.test(str);
    case &#39;card&#39;:    //身份证
      return /(^\d&#123;15&#125;$)|(^\d&#123;18&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)/.test(str);
    case &#39;pwd&#39;:     //密码以字母开头，长度在6~18之间，只能包含字母、数字和下划线
      return /^[a-zA-Z]\w&#123;5,17&#125;$/.test(str)
    case &#39;postal&#39;:  //邮政编码
      return /[1-9]\d&#123;5&#125;(?!\d)/.test(str);
    case &#39;QQ&#39;:      //QQ号
      return /^[1-9][0-9]&#123;4,9&#125;$/.test(str);
    case &#39;email&#39;:   //邮箱
      return /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/.test(str);
    case &#39;money&#39;:   //金额(小数点2位)
      return /^\d*(?:\.\d&#123;0,2&#125;)?$/.test(str);
    case &#39;URL&#39;:     //网址
      return /(http|ftp|https):\/\/[\w\-_]+(\.[\w\-_]+)+([\w\-\.,@?^=%&amp;:/~\+#]*[\w\-\@?^=%&amp;/~\+#])?/.test(str)
    case &#39;IP&#39;:      //IP
      return /((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.)&#123;3&#125;(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d))/.test(str);
    case &#39;date&#39;:    //日期时间
      return /^(\d&#123;4&#125;)\-(\d&#123;2&#125;)\-(\d&#123;2&#125;) (\d&#123;2&#125;)(?:\:\d&#123;2&#125;|:(\d&#123;2&#125;):(\d&#123;2&#125;))$/.test(str) || /^(\d&#123;4&#125;)\-(\d&#123;2&#125;)\-(\d&#123;2&#125;)$/.test(str)
    case &#39;number&#39;:  //数字
      return /^[0-9]$/.test(str);
    case &#39;english&#39;: //英文
      return /^[a-zA-Z]+$/.test(str);
    case &#39;chinese&#39;: //中文
      return /^[\\u4E00-\\u9FA5]+$/.test(str);
    case &#39;lower&#39;:   //小写
      return /^[a-z]+$/.test(str);
    case &#39;upper&#39;:   //大写
      return /^[A-Z]+$/.test(str);
    case &#39;HTML&#39;:    //HTML标记
      return /&lt;(&quot;[^&quot;]*&quot;|&#39;[^&#39;]*&#39;|[^&#39;&quot;&gt;])*&gt;/.test(str);
    default:
      return true;
  &#125;
&#125;
</code></pre>
<h4 id="37-严格的身份证校验"><a href="#37-严格的身份证校验" class="headerlink" title="37.严格的身份证校验"></a>37.严格的身份证校验</h4><pre><code class="javascript">export const isCardID = (sId) =&gt; &#123;
  if (!/(^\d&#123;15&#125;$)|(^\d&#123;17&#125;(\d|X|x)$)/.test(sId)) &#123;
    console.log(&#39;你输入的身份证长度或格式错误&#39;)
    return false
  &#125;
  //身份证城市
  var aCity = &#123; 11: &quot;北京&quot;, 12: &quot;天津&quot;, 13: &quot;河北&quot;, 14: &quot;山西&quot;, 15: &quot;内蒙古&quot;, 21: &quot;辽宁&quot;, 22: &quot;吉林&quot;, 23: &quot;黑龙江&quot;, 31: &quot;上海&quot;, 32: &quot;江苏&quot;, 33: &quot;浙江&quot;, 34: &quot;安徽&quot;, 35: &quot;福建&quot;, 36: &quot;江西&quot;, 37: &quot;山东&quot;, 41: &quot;河南&quot;, 42: &quot;湖北&quot;, 43: &quot;湖南&quot;, 44: &quot;广东&quot;, 45: &quot;广西&quot;, 46: &quot;海南&quot;, 50: &quot;重庆&quot;, 51: &quot;四川&quot;, 52: &quot;贵州&quot;, 53: &quot;云南&quot;, 54: &quot;西藏&quot;, 61: &quot;陕西&quot;, 62: &quot;甘肃&quot;, 63: &quot;青海&quot;, 64: &quot;宁夏&quot;, 65: &quot;新疆&quot;, 71: &quot;台湾&quot;, 81: &quot;香港&quot;, 82: &quot;澳门&quot;, 91: &quot;国外&quot; &#125;;
  if (!aCity[parseInt(sId.substr(0, 2))]) &#123;
    console.log(&#39;你的身份证地区非法&#39;)
    return false
  &#125;

  // 出生日期验证
  var sBirthday = (sId.substr(6, 4) + &quot;-&quot; + Number(sId.substr(10, 2)) + &quot;-&quot; + Number(sId.substr(12, 2))).replace(/-/g, &quot;/&quot;),
    d = new Date(sBirthday)
  if (sBirthday != (d.getFullYear() + &quot;/&quot; + (d.getMonth() + 1) + &quot;/&quot; + d.getDate())) &#123;
    console.log(&#39;身份证上的出生日期非法&#39;)
    return false
  &#125;

  // 身份证号码校验
  var sum = 0,
    weights = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2],
    codes = &quot;10X98765432&quot;
  for (var i = 0; i &lt; sId.length - 1; i++) &#123;
    sum += sId[i] * weights[i];
  &#125;
  var last = codes[sum % 11]; //计算出来的最后一位身份证号码
  if (sId[sId.length - 1] != last) &#123;
    console.log(&#39;你输入的身份证号非法&#39;)
    return false
  &#125;

  return true
&#125;
</code></pre>
<h4 id="38-随机数范围"><a href="#38-随机数范围" class="headerlink" title="38.随机数范围"></a>38.随机数范围</h4><pre><code class="javascript">export const random = (min, max) =&gt; &#123;
  if (arguments.length === 2) &#123;
    return Math.floor(min + Math.random() * ((max + 1) - min))
  &#125; else &#123;
    return null;
  &#125;
&#125;
</code></pre>
<h4 id="39-将阿拉伯数字翻译成中文的大写数字"><a href="#39-将阿拉伯数字翻译成中文的大写数字" class="headerlink" title="39.将阿拉伯数字翻译成中文的大写数字"></a>39.将阿拉伯数字翻译成中文的大写数字</h4><pre><code class="javascript">export const numberToChinese = (num) =&gt; &#123;
  var AA = new Array(&quot;零&quot;, &quot;一&quot;, &quot;二&quot;, &quot;三&quot;, &quot;四&quot;, &quot;五&quot;, &quot;六&quot;, &quot;七&quot;, &quot;八&quot;, &quot;九&quot;, &quot;十&quot;);
  var BB = new Array(&quot;&quot;, &quot;十&quot;, &quot;百&quot;, &quot;仟&quot;, &quot;萬&quot;, &quot;億&quot;, &quot;点&quot;, &quot;&quot;);
  var a = (&quot;&quot; + num).replace(/(^0*)/g, &quot;&quot;).split(&quot;.&quot;),
    k = 0,
    re = &quot;&quot;;
  for (var i = a[0].length - 1; i &gt;= 0; i--) &#123;
    switch (k) &#123;
      case 0:
        re = BB[7] + re;
        break;
      case 4:
        if (!new RegExp(&quot;0&#123;4&#125;//d&#123;&quot; + (a[0].length - i - 1) + &quot;&#125;$&quot;)
          .test(a[0]))
          re = BB[4] + re;
        break;
      case 8:
        re = BB[5] + re;
        BB[7] = BB[5];
        k = 0;
        break;
    &#125;
    if (k % 4 == 2 &amp;&amp; a[0].charAt(i + 2) != 0 &amp;&amp; a[0].charAt(i + 1) == 0)
      re = AA[0] + re;
    if (a[0].charAt(i) != 0)
      re = AA[a[0].charAt(i)] + BB[k % 4] + re;
    k++;
  &#125;

  if (a.length &gt; 1) // 加上小数部分(如果有小数部分)
  &#123;
    re += BB[6];
    for (var i = 0; i &lt; a[1].length; i++)
      re += AA[a[1].charAt(i)];
  &#125;
  if (re == &#39;一十&#39;)
    re = &quot;十&quot;;
  if (re.match(/^一/) &amp;&amp; re.length == 3)
    re = re.replace(&quot;一&quot;, &quot;&quot;);
  return re;
&#125;
</code></pre>
<h4 id="40-将数字转换为大写金额"><a href="#40-将数字转换为大写金额" class="headerlink" title="40.将数字转换为大写金额"></a>40.将数字转换为大写金额</h4><pre><code class="javascript">export const changeToChinese = (Num) =&gt; &#123;
  //判断如果传递进来的不是字符的话转换为字符
  if (typeof Num == &quot;number&quot;) &#123;
    Num = new String(Num);
  &#125;;
  Num = Num.replace(/,/g, &quot;&quot;) //替换tomoney()中的“,”
  Num = Num.replace(/ /g, &quot;&quot;) //替换tomoney()中的空格
  Num = Num.replace(/￥/g, &quot;&quot;) //替换掉可能出现的￥字符
  if (isNaN(Num)) &#123; //验证输入的字符是否为数字
    //alert(&quot;请检查小写金额是否正确&quot;);
    return &quot;&quot;;
  &#125;;
  //字符处理完毕后开始转换，采用前后两部分分别转换
  var part = String(Num).split(&quot;.&quot;);
  var newchar = &quot;&quot;;
  //小数点前进行转化
  for (var i = part[0].length - 1; i &gt;= 0; i--) &#123;
    if (part[0].length &gt; 10) &#123;
      return &quot;&quot;;
      //若数量超过拾亿单位，提示
    &#125;
    var tmpnewchar = &quot;&quot;
    var perchar = part[0].charAt(i);
    switch (perchar) &#123;
      case &quot;0&quot;:
        tmpnewchar = &quot;零&quot; + tmpnewchar;
        break;
      case &quot;1&quot;:
        tmpnewchar = &quot;壹&quot; + tmpnewchar;
        break;
      case &quot;2&quot;:
        tmpnewchar = &quot;贰&quot; + tmpnewchar;
        break;
      case &quot;3&quot;:
        tmpnewchar = &quot;叁&quot; + tmpnewchar;
        break;
      case &quot;4&quot;:
        tmpnewchar = &quot;肆&quot; + tmpnewchar;
        break;
      case &quot;5&quot;:
        tmpnewchar = &quot;伍&quot; + tmpnewchar;
        break;
      case &quot;6&quot;:
        tmpnewchar = &quot;陆&quot; + tmpnewchar;
        break;
      case &quot;7&quot;:
        tmpnewchar = &quot;柒&quot; + tmpnewchar;
        break;
      case &quot;8&quot;:
        tmpnewchar = &quot;捌&quot; + tmpnewchar;
        break;
      case &quot;9&quot;:
        tmpnewchar = &quot;玖&quot; + tmpnewchar;
        break;
    &#125;
    switch (part[0].length - i - 1) &#123;
      case 0:
        tmpnewchar = tmpnewchar + &quot;元&quot;;
        break;
      case 1:
        if (perchar != 0) tmpnewchar = tmpnewchar + &quot;拾&quot;;
        break;
      case 2:
        if (perchar != 0) tmpnewchar = tmpnewchar + &quot;佰&quot;;
        break;
      case 3:
        if (perchar != 0) tmpnewchar = tmpnewchar + &quot;仟&quot;;
        break;
      case 4:
        tmpnewchar = tmpnewchar + &quot;万&quot;;
        break;
      case 5:
        if (perchar != 0) tmpnewchar = tmpnewchar + &quot;拾&quot;;
        break;
      case 6:
        if (perchar != 0) tmpnewchar = tmpnewchar + &quot;佰&quot;;
        break;
      case 7:
        if (perchar != 0) tmpnewchar = tmpnewchar + &quot;仟&quot;;
        break;
      case 8:
        tmpnewchar = tmpnewchar + &quot;亿&quot;;
        break;
      case 9:
        tmpnewchar = tmpnewchar + &quot;拾&quot;;
        break;
    &#125;
    var newchar = tmpnewchar + newchar;
  &#125;
  //小数点之后进行转化
  if (Num.indexOf(&quot;.&quot;) != -1) &#123;
    if (part[1].length &gt; 2) &#123;
      // alert(&quot;小数点之后只能保留两位,系统将自动截断&quot;);
      part[1] = part[1].substr(0, 2)
    &#125;
    for (i = 0; i &lt; part[1].length; i++) &#123;
      tmpnewchar = &quot;&quot;
      perchar = part[1].charAt(i)
      switch (perchar) &#123;
        case &quot;0&quot;:
          tmpnewchar = &quot;零&quot; + tmpnewchar;
          break;
        case &quot;1&quot;:
          tmpnewchar = &quot;壹&quot; + tmpnewchar;
          break;
        case &quot;2&quot;:
          tmpnewchar = &quot;贰&quot; + tmpnewchar;
          break;
        case &quot;3&quot;:
          tmpnewchar = &quot;叁&quot; + tmpnewchar;
          break;
        case &quot;4&quot;:
          tmpnewchar = &quot;肆&quot; + tmpnewchar;
          break;
        case &quot;5&quot;:
          tmpnewchar = &quot;伍&quot; + tmpnewchar;
          break;
        case &quot;6&quot;:
          tmpnewchar = &quot;陆&quot; + tmpnewchar;
          break;
        case &quot;7&quot;:
          tmpnewchar = &quot;柒&quot; + tmpnewchar;
          break;
        case &quot;8&quot;:
          tmpnewchar = &quot;捌&quot; + tmpnewchar;
          break;
        case &quot;9&quot;:
          tmpnewchar = &quot;玖&quot; + tmpnewchar;
          break;
      &#125;
      if (i == 0) tmpnewchar = tmpnewchar + &quot;角&quot;;
      if (i == 1) tmpnewchar = tmpnewchar + &quot;分&quot;;
      newchar = newchar + tmpnewchar;
    &#125;
  &#125;
  //替换所有无用汉字
  while (newchar.search(&quot;零零&quot;) != -1)
    newchar = newchar.replace(&quot;零零&quot;, &quot;零&quot;);
  newchar = newchar.replace(&quot;零亿&quot;, &quot;亿&quot;);
  newchar = newchar.replace(&quot;亿万&quot;, &quot;亿&quot;);
  newchar = newchar.replace(&quot;零万&quot;, &quot;万&quot;);
  newchar = newchar.replace(&quot;零元&quot;, &quot;元&quot;);
  newchar = newchar.replace(&quot;零角&quot;, &quot;&quot;);
  newchar = newchar.replace(&quot;零分&quot;, &quot;&quot;);
  if (newchar.charAt(newchar.length - 1) == &quot;元&quot;) &#123;
    newchar = newchar + &quot;整&quot;
  &#125;
  return newchar;
&#125;
</code></pre>
<h4 id="41-判断一个元素是否在数组中"><a href="#41-判断一个元素是否在数组中" class="headerlink" title="41.判断一个元素是否在数组中"></a>41.判断一个元素是否在数组中</h4><pre><code class="javascript">export const contains = (arr, val) =&gt; &#123;
    return arr.indexOf(val) != -1 ? true : false;
&#125;
</code></pre>
<h4 id="42-数组排序-type-1：从小到大-2：从大到小-3：随机"><a href="#42-数组排序-type-1：从小到大-2：从大到小-3：随机" class="headerlink" title="42.数组排序, {type} 1：从小到大 2：从大到小 3：随机"></a>42.数组排序, {type} 1：从小到大 2：从大到小 3：随机</h4><pre><code class="javascript">export const sort = (arr, type = 1) =&gt; &#123;
  return arr.sort((a, b) =&gt; &#123;
    switch (type) &#123;
    case 1:
      return a - b;
    case 2:
      return b - a;
    case 3:
      return Math.random() - 0.5;
    default:
      return arr;
    &#125;
  &#125;)
&#125;
</code></pre>
<h4 id="43-数组去重"><a href="#43-数组去重" class="headerlink" title="43.数组去重"></a>43.数组去重</h4><pre><code class="javascript">export const unique = (arr) =&gt; &#123;
  if (Array.hasOwnProperty(&#39;from&#39;)) &#123;
    return Array.from(new Set(arr));
  &#125; else &#123;
    var n = &#123;&#125;, r = [];
    for (var i = 0; i &lt; arr.length; i++) &#123;
      if (!n[arr[i]]) &#123;
        n[arr[i]] = true;
        r.push(arr[i]);
      &#125;
    &#125;
    return r;
  &#125;
&#125;
</code></pre>
<h4 id="44-求两个集合的并集"><a href="#44-求两个集合的并集" class="headerlink" title="44.求两个集合的并集"></a>44.求两个集合的并集</h4><pre><code class="javascript">export const union = (a, b) =&gt; &#123;
  var newArr = a.concat(b);
  return this.unique(newArr); // 见43
&#125;
</code></pre>
<h4 id="45-求两个集合的交集"><a href="#45-求两个集合的交集" class="headerlink" title="45.求两个集合的交集"></a>45.求两个集合的交集</h4><pre><code class="javascript">export const intersect = (a, b) =&gt; &#123;
  var _this = this;
  a = this.unique(a);
  return this.map(a, function (o) &#123;
    return _this.contains(b, o) ? o : null; // contains方法见41
  &#125;);
&#125;
</code></pre>
<h4 id="46-删除数组指定元素"><a href="#46-删除数组指定元素" class="headerlink" title="46.删除数组指定元素"></a>46.删除数组指定元素</h4><pre><code class="javascript">export const remove = (arr, ele) =&gt; &#123;
  var index = arr.indexOf(ele);
  if (index &gt; -1) &#123;
    arr.splice(index, 1);
  &#125;
  return arr;
&#125;
</code></pre>
<h4 id="47-将类数组转换为数组"><a href="#47-将类数组转换为数组" class="headerlink" title="47.将类数组转换为数组"></a>47.将类数组转换为数组</h4><pre><code class="javascript">export const formArray = (ary) =&gt; &#123;
  var arr = [];
  if (Array.isArray(ary)) &#123;
    arr = ary;
  &#125; else &#123;
    arr = Array.prototype.slice.call(ary);
  &#125;;
  return arr;
&#125;
</code></pre>
<h4 id="48-找出数组最大值"><a href="#48-找出数组最大值" class="headerlink" title="48.找出数组最大值"></a>48.找出数组最大值</h4><pre><code class="javascript">export const max = (arr) =&gt; &#123;
  return Math.max.apply(null, arr);
&#125;
</code></pre>
<h4 id="49-找出数组最小值"><a href="#49-找出数组最小值" class="headerlink" title="49.找出数组最小值"></a>49.找出数组最小值</h4><pre><code class="javascript">export const min = (arr) =&gt; &#123;
    return Math.min.apply(null, arr);
&#125;
</code></pre>
<h4 id="50-数组求和"><a href="#50-数组求和" class="headerlink" title="50.数组求和"></a>50.数组求和</h4><pre><code class="javascript">export const sum = (arr) =&gt; &#123;
    return arr.reduce((pre, cur) =&gt; &#123;
        return pre + cur
    &#125;)
&#125;
</code></pre>
<h4 id="51-数组平均数"><a href="#51-数组平均数" class="headerlink" title="51.数组平均数"></a>51.数组平均数</h4><pre><code class="javascript">export const average = (arr) =&gt; &#123;
    return this.sum(arr) / arr.length
&#125;
</code></pre>
<h4 id="52-去除空格-type-1-所有空格-2-前后空格-3-前空格-4-后空格"><a href="#52-去除空格-type-1-所有空格-2-前后空格-3-前空格-4-后空格" class="headerlink" title="52.去除空格,type: 1-所有空格 2-前后空格 3-前空格 4-后空格"></a>52.去除空格,<code>type: 1-所有空格 2-前后空格 3-前空格 4-后空格</code></h4><pre><code class="javascript">export const trim = (str, type) =&gt; &#123;
  type = type || 1
  switch (type) &#123;
    case 1:
      return str.replace(/\s+/g, &quot;&quot;);
    case 2:
      return str.replace(/(^\s*)|(\s*$)/g, &quot;&quot;);
    case 3:
      return str.replace(/(^\s*)/g, &quot;&quot;);
    case 4:
      return str.replace(/(\s*$)/g, &quot;&quot;);
    default:
      return str;
  &#125;
&#125;
</code></pre>
<h4 id="53-字符转换-type-1-首字母大写-2：首字母小写-3：大小写转换-4：全部大写-5：全部小写"><a href="#53-字符转换-type-1-首字母大写-2：首字母小写-3：大小写转换-4：全部大写-5：全部小写" class="headerlink" title="53.字符转换,type: 1:首字母大写 2：首字母小写 3：大小写转换 4：全部大写 5：全部小写"></a>53.字符转换,type: 1:首字母大写 2：首字母小写 3：大小写转换 4：全部大写 5：全部小写</h4><pre><code class="javascript">export const changeCase = (str, type) =&gt; &#123;
  type = type || 4
  switch (type) &#123;
    case 1:
      return str.replace(/\b\w+\b/g, function (word) &#123;
        return word.substring(0, 1).toUpperCase() + word.substring(1).toLowerCase();

      &#125;);
    case 2:
      return str.replace(/\b\w+\b/g, function (word) &#123;
        return word.substring(0, 1).toLowerCase() + word.substring(1).toUpperCase();
      &#125;);
    case 3:
      return str.split(&#39;&#39;).map(function (word) &#123;
        if (/[a-z]/.test(word)) &#123;
          return word.toUpperCase();
        &#125; else &#123;
          return word.toLowerCase()
        &#125;
      &#125;).join(&#39;&#39;)
    case 4:
      return str.toUpperCase();
    case 5:
      return str.toLowerCase();
    default:
      return str;
  &#125;
&#125;
</code></pre>
<h4 id="54-检测密码强度"><a href="#54-检测密码强度" class="headerlink" title="54.检测密码强度"></a>54.检测密码强度</h4><pre><code class="javascript">export const checkPwd = (str) =&gt; &#123;
  var Lv = 0;
  if (str.length &lt; 6) &#123;
    return Lv
  &#125;
  if (/[0-9]/.test(str)) &#123;
    Lv++
  &#125;
  if (/[a-z]/.test(str)) &#123;
    Lv++
  &#125;
  if (/[A-Z]/.test(str)) &#123;
    Lv++
  &#125;
  if (/[\.|-|_]/.test(str)) &#123;
    Lv++
  &#125;
  return Lv;
&#125;
</code></pre>
<h4 id="55-函数节流器"><a href="#55-函数节流器" class="headerlink" title="55.函数节流器"></a>55.函数节流器</h4><pre><code class="javascript">export const debouncer = (fn, time, interval = 200) =&gt; &#123;
  if (time - (window.debounceTimestamp || 0) &gt; interval) &#123;
    fn &amp;&amp; fn();
    window.debounceTimestamp = time;
  &#125;
&#125;
</code></pre>
<h4 id="56-在字符串中插入新字符串"><a href="#56-在字符串中插入新字符串" class="headerlink" title="56.在字符串中插入新字符串"></a>56.在字符串中插入新字符串</h4><pre><code class="javascript">export const insertStr = (soure, index, newStr) =&gt; &#123;
  var str = soure.slice(0, index) + newStr + soure.slice(index);
  return str;
&#125;
</code></pre>
<h4 id="57-判断两个对象是否键值相同"><a href="#57-判断两个对象是否键值相同" class="headerlink" title="57.判断两个对象是否键值相同"></a>57.判断两个对象是否键值相同</h4><pre><code class="javascript">export const isObjectEqual = (a, b) =&gt; &#123;
  var aProps = Object.getOwnPropertyNames(a);
  var bProps = Object.getOwnPropertyNames(b);

  if (aProps.length !== bProps.length) &#123;
    return false;
  &#125;

  for (var i = 0; i &lt; aProps.length; i++) &#123;
    var propName = aProps[i];

    if (a[propName] !== b[propName]) &#123;
      return false;
    &#125;
  &#125;
  return true;
&#125;
</code></pre>
<h4 id="58-16进制颜色转RGBRGBA字符串"><a href="#58-16进制颜色转RGBRGBA字符串" class="headerlink" title="58.16进制颜色转RGBRGBA字符串"></a>58.16进制颜色转RGBRGBA字符串</h4><pre><code class="javascript">export const colorToRGB = (val, opa) =&gt; &#123;

  var pattern = /^(#?)[a-fA-F0-9]&#123;6&#125;$/; //16进制颜色值校验规则
  var isOpa = typeof opa == &#39;number&#39;; //判断是否有设置不透明度

  if (!pattern.test(val)) &#123; //如果值不符合规则返回空字符
    return &#39;&#39;;
  &#125;

  var v = val.replace(/#/, &#39;&#39;); //如果有#号先去除#号
  var rgbArr = [];
  var rgbStr = &#39;&#39;;

  for (var i = 0; i &lt; 3; i++) &#123;
    var item = v.substring(i * 2, i * 2 + 2);
    var num = parseInt(item, 16);
    rgbArr.push(num);
  &#125;

  rgbStr = rgbArr.join();
  rgbStr = &#39;rgb&#39; + (isOpa ? &#39;a&#39; : &#39;&#39;) + &#39;(&#39; + rgbStr + (isOpa ? &#39;,&#39; + opa : &#39;&#39;) + &#39;)&#39;;
  return rgbStr;
&#125;
</code></pre>
<h4 id="59-追加url参数"><a href="#59-追加url参数" class="headerlink" title="59.追加url参数"></a>59.追加url参数</h4><pre><code class="javascript">export const appendQuery = (url, key, value) =&gt; &#123;
  var options = key;
  if (typeof options == &#39;string&#39;) &#123;
    options = &#123;&#125;;
    options[key] = value;
  &#125;
  options = $.param(options);
  if (url.includes(&#39;?&#39;)) &#123;
    url += &#39;&amp;&#39; + options
  &#125; else &#123;
    url += &#39;?&#39; + options
  &#125;
  return url;
&#125;
</code></pre>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>开发工具-git设置代理模式</title>
    <url>/2021/03/18/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7-git%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>github不使用代理就可以访问, 但有的时候clone和push的速度很慢，我们可以使用git代理来提高速度…</p>
<span id="more"></span>

<h2 id="设置代理："><a href="#设置代理：" class="headerlink" title="设置代理："></a>设置代理：</h2><h3 id="全局代理-http和https代理"><a href="#全局代理-http和https代理" class="headerlink" title="全局代理(http和https代理)"></a>全局代理(http和https代理)</h3><pre><code class="code">git config --global http.proxy 127.0.0.1:19180
</code></pre>
<pre><code class="code">git config --global https.proxy 127.0.0.1:19180
</code></pre>
<h3 id="局部代理-http和https代理"><a href="#局部代理-http和https代理" class="headerlink" title="局部代理(http和https代理)"></a>局部代理(http和https代理)</h3><p>局部代理，在git仓库内执行</p>
<pre><code class="code">git config --local http.proxy 127.0.0.1:19180
</code></pre>
<pre><code class="code">git config --local https.proxy 127.0.0.1:19180
</code></pre>
<h2 id="取消代理："><a href="#取消代理：" class="headerlink" title="取消代理："></a>取消代理：</h2><h3 id="取消全局代理-http和https代理"><a href="#取消全局代理-http和https代理" class="headerlink" title="取消全局代理(http和https代理)"></a>取消全局代理(http和https代理)</h3><pre><code class="code">git config --global --unset http.proxy
</code></pre>
<pre><code class="code">git config --local --unset http.proxy
</code></pre>
<h3 id="取消局部代理-http和https代理"><a href="#取消局部代理-http和https代理" class="headerlink" title="取消局部代理(http和https代理)"></a>取消局部代理(http和https代理)</h3><pre><code class="code">git config --local --unset http.proxy
</code></pre>
<pre><code class="code">git config --local --unset https.proxy
</code></pre>
<hr>
<p>参考文档:<a href="https://www.jianshu.com/p/8c5bb8eee8b2">简述:git设置代理模式，仅为github设置代理</a></p>
]]></content>
      <categories>
        <category>开发工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>微信小程序常用工具函数封装</title>
    <url>/2021/05/27/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%E5%B0%81%E8%A3%85/</url>
    <content><![CDATA[<p>对微信小程序自身特性的功能进行封装使用</p>
<span id="more"></span>


<pre><code class="javascript">/**
 * 查询授权
 * @param &#123;*&#125; scope
 */
const wxGetSetting = (scope) =&gt; &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    wx.getSetting(&#123;
      success(res) &#123;
        if (!res.authSetting[&#39;scope.&#39; + scope]) &#123;
          wx.authorize(&#123;
            scope: &#39;scope.&#39; + scope,
            success(res) &#123;
              resolve(res)
            &#125;,
            fail(err) &#123;
              wx.showToast(&#123;
                title: &#39;请您到设置页面允许授权&#39;,
                icon: &#39;none&#39;
              &#125;)
              wx.openSetting()
              reject(err)
            &#125;
          &#125;)
        &#125; else &#123;
          resolve(&#123;&#125;)
        &#125;
      &#125;,
      fail(err) &#123;
        reject(err)
      &#125;
    &#125;)
  &#125;)
&#125;
/**
 * 微信登录功能
 */
const wxLogin = () =&gt; &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    wx.login(&#123;
      success: function (res) &#123;
        console.log(&#39;wx login success ===&#39;, res)
        resolve(res)
      &#125;,
      fail:function (err) &#123;
        console.log(&#39;login fail ===&#39;, err)
      &#125;
    &#125;)
  &#125;)
&#125;
/**
 * 获取个人信息
 */
const wxGetUserInfo = () =&gt; &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    wxGetSetting(&#39;userInfo&#39;).then(res =&gt; &#123;
      wx.getUserInfo(&#123;
        success: function (res) &#123;
          resolve(res)
        &#125;
      &#125;)
    &#125;).catch(err =&gt; &#123;
      reject(err)
    &#125;)
  &#125;)
&#125;

/**
 * 保存图片
 * @param &#123;*&#125; filePath
 */
const wxSaveImageToPhotosAlbum = (src,from=&quot;web&quot;) =&gt; &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    wxGetSetting(&#39;writePhotosAlbum&#39;).then(res =&gt; &#123;
      if(from == &quot;local&quot;)&#123;
        wx.saveImageToPhotosAlbum(&#123;
          filePath:src,
          success: function (res) &#123;
            resolve(res)
          &#125;,fail(e)&#123;
            reject(e)
          &#125;
        &#125;)
      &#125;else if(from == &quot;web&quot;)&#123;
        let fileName = new Date().valueOf();
        wx.downloadFile(&#123;
          url:src,
          filePath:wx.env.USER_DATA_PATH + &#39;/&#39; + fileName + &#39;.jpg&#39;,
          success(image)&#123;
            wx.saveImageToPhotosAlbum(&#123;
              filePath:image.filePath,
              success: function (res) &#123;
                resolve(res)
              &#125;,fail(e)&#123;
                reject(e)
              &#125;
            &#125;)
          &#125;,fail(err)&#123;
            reject(err)
          &#125;
        &#125;)
      &#125;else&#123;
        reject(&quot;wxSaveImageToPhotosAlbum:from is unknown&quot;)
      &#125;
    &#125;).catch(err =&gt; &#123;
      reject(err)
    &#125;)
  &#125;)
&#125;

/**
 * 复制文字到剪切板
 * @param &#123;*&#125; data
 */
const wxClipboardData = data =&gt; &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    wx.setClipboardData(&#123;
      data: data,
      success(res) &#123;
        wx.getClipboardData(&#123;
          success(res) &#123;
            resolve(res)
          &#125;,
          fail(err) &#123;
            reject(err)
          &#125;
        &#125;)
      &#125;,
      fail(err) &#123;
        reject(err)
      &#125;
    &#125;)
  &#125;)
&#125;

/**
 * 打开文档
 * @param &#123;*&#125; path
 */
const wxOpenDocument = (path,name=&#39;&#39;) =&gt;&#123;
  return new Promise((resolve, reject) =&gt; &#123;
    wx.downloadFile(&#123;
      url: path,
      filePath: wx.env.USER_DATA_PATH + &#39;/&#39;+ name +&#39;.pdf&#39;,
      success: function (res) &#123;
        const filePath = res.tempFilePath
        wx.openDocument(&#123;
          // filePath: filePath,
          filePath: res.filePath,
          showMenu:true,
          success: function (res) &#123;
            resolve(res)
          &#125;,fail(err)&#123;
            reject(err)
          &#125;
        &#125;)
      &#125;,fail(err)&#123;
        reject(err)
      &#125;
    &#125;)
  &#125;)
&#125;

const wxMakePhoneCall = phone =&gt;&#123;
  return new Promise((resolve, reject) =&gt; &#123;
  let type = Object.prototype.toString.call(phone);
  let phoneArray = []
  if(type == &quot;[object String]&quot;)&#123;
      phoneArray = [phone]
  &#125;else if(type == &quot;[object Number]&quot;)&#123;
    phoneArray = [phone.toString]
  &#125;else if(type == &quot;[object Array]&quot;)&#123;
    phoneArray = phone;
  &#125;else&#123;
    reject(&quot;wxMakePhoneCall:parameter type is error&quot;);
    return;
  &#125;
  wx.showActionSheet(&#123;
    itemList: phoneArray,
    success: function (res) &#123;
      wx.makePhoneCall(&#123;
        phoneNumber: phone, //此号码并非真实电话号码，仅用于测试
        success: function () &#123;
          resolve()
        &#125;,
        fail: function (e) &#123;
          reject(e)
        &#125;
      &#125;)
      if (!res.cancel) &#123;
        reject(res.tapIndex)
      &#125;
    &#125;
  &#125;);



&#125;)
&#125;

/**
 * 微信拉起支付
 * @param &#123;*&#125; data
 */
const wxPayment = data =&gt; &#123;
  return new Promise((resolve, reject) =&gt; &#123;
    let &#123;
      timeStamp,
      nonceStr,
      paySign
    &#125; = data;
    wx.requestPayment(&#123;
      timeStamp,
      nonceStr,
      package:data.package,
      signType: &#39;MD5&#39;,
      paySign,
      success(res) &#123;
        resolve(res)
      &#125;,
      fail(res) &#123;
        reject(res)
      &#125;
    &#125;)
  &#125;)
&#125;


export &#123;
  wxGetUserInfo,
  wxLogin,
  wxSaveImageToPhotosAlbum,
  wxClipboardData,
  wxOpenDocument,
  wxMakePhoneCall,
  wxPayment
&#125;
</code></pre>
<p>转载于:<a href="https://tangyuxian.com/2021/02/20/%E5%89%8D%E7%AB%AF/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F-%E5%B8%B8%E7%94%A8%E5%8E%9F%E7%94%9F%E5%8A%9F%E8%83%BD%E5%B0%81%E8%A3%85/">tangyuxian的文章 — 微信小程序-常用原生功能封装</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>微信小程序</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建ts简易开发环境</title>
    <url>/2021/06/01/%E6%90%AD%E5%BB%BAts%E7%AE%80%E6%98%93%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>用webpack搭建一个用于学习ts的简易的ts开发环境…</p>
<span id="more"></span>
<h4 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h4><pre><code class="code">mkdir ts-cli
cd ts-cli
npm init -y
</code></pre>
<h4 id="下载typescript依赖"><a href="#下载typescript依赖" class="headerlink" title="下载typescript依赖"></a>下载typescript依赖</h4><pre><code>npm i typescript -D
</code></pre>
<h4 id="初始化typescript配置项"><a href="#初始化typescript配置项" class="headerlink" title="初始化typescript配置项"></a>初始化typescript配置项</h4><pre><code>npx tsc --init
</code></pre>
<p>初始化配置成功会提示如下</p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210601133709223.png" alt="image-20210601133709223"></p>
<p>我们这里搭建的是便于学习ts的开发环境，我们再添加一些目录文件，index.html，和webpack配置文件build/webpack.config.js src/main.ts、tslint.json…</p>
<p>代码结构如下</p>
<pre><code class="pseudocode">ts-cli
└───build
│   │   webpack.config.js
└───index.html
└───node_modules
│   │
└─── package.json
└───src
│   │   main.ts
└─── tsconfig.json
└─── tslint.json
└─── REAME.md
</code></pre>
<h4 id="下载webpack依赖"><a href="#下载webpack依赖" class="headerlink" title="下载webpack依赖"></a>下载webpack依赖</h4><pre><code>&quot;cross-env&quot;: &quot;^6.0.3&quot;,
&quot;html-webpack-plugin&quot;: &quot;^3.2.0&quot;,
&quot;ts-loader&quot;: &quot;^6.2.1&quot;,
&quot;webpack&quot;: &quot;^4.41.4&quot;,
&quot;webpack-cli&quot;: &quot;^3.3.10&quot;,
&quot;webpack-dev-server&quot;: &quot;^3.10.1&quot;
</code></pre>
<h4 id="webpack-config-js"><a href="#webpack-config-js" class="headerlink" title="webpack.config.js"></a>webpack.config.js</h4><pre><code class="js">const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);

module.exports = &#123;
  entry: &quot;./src/main.ts&quot;,
  output: &#123;
    filename: &quot;build.js&quot;
  &#125;,
  resolve: &#123;
    extensions: [&quot;.tsx&quot;, &quot;.ts&quot;, &quot;.js&quot;]
  &#125;,
  module: &#123;
    rules: [
      &#123;
        test: /.tsx?$/,
        use: &quot;ts-loader&quot;,
        exclude: /node_modules/
      &#125;
    ]
  &#125;,
  devtool: process.env.NODE_ENV === &quot;production&quot; ? false : &quot;inline-source-map&quot;,
  devServer: &#123;
    contentBase: &quot;./dist&quot;,
    stats: &quot;errors-only&quot;,
    compress: false,
    host: &quot;localhost&quot;,
    port: 8080
  &#125;,
  plugins: [
    new HtmlWebpackPlugin(&#123;
      template: &quot;./index.html&quot;
    &#125;)
  ]
&#125;;
</code></pre>
<p>比较简单的webpack配置，设置好入口和出口文件，然后用插件HtmlWebpackPlugin插件把build.js引入到index.html里…</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>原创</tag>
        <tag>Webpack</tag>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>强缓存和协商缓存</title>
    <url>/2021/08/26/%E6%B8%85%E7%BC%93%E5%AD%98%E5%92%8C%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98/</url>
    <content><![CDATA[<p>强缓存和协商缓存…</p>
<span id="more"></span>

<p>为啥要缓存：</p>
<ol>
<li>缓存的优点：</li>
</ol>
<p>　　1）加快浏览器加载网页的速度，优化用户体验，让用户更快速的打开我们的网页；</p>
<p>　　2）减少对服务器的访问次数，减轻服务器的负担；</p>
<p>　　3）节省带宽（就是节省钱…，因为很多带宽服务其实是按流量来计费的，同样对用户也可以省4G、5G流量…也省钱了）</p>
<p>2.有啥缺点：</p>
<p>　　如果资源一直被缓存了，那当资源发生更改时，用户就无法获取最新的信息了！ 所以缓存虽好，可不能乱用。</p>
<p><strong>强缓存：</strong></p>
<p>　　什么是强缓存？强制？没错，就是强制把资源缓存起来？ 那不就是会有上面说的缺点了吗？</p>
<p>　　是的，那为啥还要用强缓存呢？什么情况下要用强缓存呢？又到底怎么用呢？</p>
<p>　　强缓存是利用http头中的Expires 和 Cache-Control两个字段来控制的：</p>
<p>　　<strong>Expires</strong></p>
<p>　　　<img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/345294-20200315151209819-889119830.png" alt="img"></p>
<p>　　从图中可以看到，它的值是一个绝对的时间，这个时间代表资源的失效时间，就是说在这个时间之前缓存始终有效，始终会读取缓存中的数据。但是，这里会有一个明显的缺点：因为它是一个绝对时间，当服务器时间与客户端时间有偏差时，就可能会导致缓存失效，比如用户随意修改了本地时间…</p>
<p>　　<strong>Cacha-Control</strong></p>
<p>　　<img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/345294-20200315144110905-1951470203.png" alt="img"></p>
<p>　　http1.1加入了Cache-Control ，上图中可以看到它的值：max-age=2592001，表示资源的最大有效时间的“秒数”，是一个相对值，不会因为用户修改本地时间而导致失效。除了<strong>mas-age</strong>之外还有其他一些值：</p>
<p>　　1）public/private: <strong>public</strong>表示客户端和代理服务器（如CDN）都可以缓存，<strong>private（默认值）</strong>表示只有客户端可以缓存；</p>
<p>　　2）no-cache/no-store: <strong>no-cache</strong>客户端缓存内容，但是是否使用缓存需要经过协商缓存来验证决定；<strong>no-store</strong> 所有内容都不会被缓存，即不使用强缓存，也不使用协商缓存；</p>
<p><strong>PS: Expires和Cache-Control可以在服务端配置为同时启用，同时启用的时候Cache-Control优先级更高</strong></p>
<p><strong>协商缓存：</strong></p>
<p>　　协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程：</p>
<p>　　协商缓存是通过两对值来设置的： Last-Modified/If-Modified-Since 和 ETag/If-None-Match</p>
<p>　　<img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/345294-20200315150811750-447549739.png" alt="img"></p>
<p>　　<strong>Last-Modified/If-Modified-Since：</strong></p>
<p>　　1) 浏览器第一次发送请求，让服务端在response header中返回请求的资源上次更新时间（Last-Modified的值），浏览器会存下这个时间；</p>
<p>　　2）当浏览器下次请求时，request header中带上If-Modified-Since(即保存的Last-Modified的值)。根据浏览器发送的修改时间和服务端的wh修改时间进行比对，一致的话代码资源没有改变，服务端返回正文为空的响应，让浏览器在缓存中读取资源，从而减少请求消耗。</p>
<p>　　<strong>缺点：</strong></p>
<p>　　<strong>1、从上图可以看到Last-Modified保存的是绝对时间，并且是精确到秒，所以如果资源在1秒内修改了多次的话，那就无法识别；</strong></p>
<p>　　<strong>2、对于文件只改变了修改时间，内容不变，这时候也会使缓存失效，其实这个时候我们是不希望客户端重新请求的；</strong></p>
<p>　　<strong>3、某些服务器不能精确的得到文件的最后修改时间；</strong></p>
<p>　　</p>
<p>　　<strong>ETag/If-None-Match:</strong></p>
<p>　　1) 浏览器第一次发送一个请求得到ETag的值，然后在下一次请求request header中带上If-none-match（即保存的ETag的值）；</p>
<p>　　2）通过发送的ETag的值和服务器重新生成的ETag的值进行比对，如果一致代表资源没有改变，服务器返回的正文为空的响应，让浏览器从缓存中读取资源，从而减少请求消耗。</p>
<p>　　ETag的工作机制跟Last-Modified基本一样。但是，ETag是对资源内容使用抗碰撞散列函数（我也不知道是啥），使用最近修改的时间戳的哈希值。ETag解决了Last-Modified上述问题。</p>
<p>　　<strong>缺点：ETag虽然能解决问题，但也并非完美，ETag每次服务端生成都需要进行读写操作（因为要生成hash），而Last-Modified只需要读取操作，ETag消耗更大一些。</strong></p>
<p>　　Last-Modified 和 ETag同样可以同时配置，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。</p>
<p>　　精确度上，ETag更高，性能上Etag稍微低一点（因为要生成hash）</p>
<p>　　由此可见，协商缓存其实受强缓存的影响，强缓存过期了且Cache-Control不为no-store时是否缓存才由协商缓存决定。</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title>移动端H5页面返回并且刷新页面（BFcache）</title>
    <url>/2021/04/27/%E7%A7%BB%E5%8A%A8%E7%AB%AFH5%E9%A1%B5%E9%9D%A2%E8%BF%94%E5%9B%9E%E5%B9%B6%E4%B8%94%E5%88%B7%E6%96%B0%E9%A1%B5%E9%9D%A2%EF%BC%88BFcache%EF%BC%89/</url>
    <content><![CDATA[<p>什么是BF叉车呢…</p>
<span id="more"></span>

<p>​    项目中的需求：点击浏览器中的返回按钮，要让页面重新加载资源。因为这部分的资源每次去加载的内容都不一样，如果返回的时候，还是看到原先的内容，那做这个内容块的意义就很小了；而如果用户看完了这部分内容，再返回来的时候，这个地方换成了新的内容，这样就能体现这部分的价值了。</p>
<p>​    而对于浏览器来说，大部分浏览器的返回是直接使用缓存的，不会执行任何的javascript代码。原因：部分浏览器在后退时不会触发onload事件，這是HTML5世代浏览器新增的特性之一——Back-Forward Cache(简称bfcache)。</p>
<h3 id="什么是bfcache"><a href="#什么是bfcache" class="headerlink" title="什么是bfcache?"></a>什么是bfcache?</h3><p>​    bfcache，即back-forward cache，可称为“往返缓存”，可以在用户使用浏览器的“后退”和“前进”按钮时加快页面的转换速度。这个缓存不仅保存页面数据，还保存了DOM和JS的状态，实际上是将整个页面都保存在内存里。如果页面位于bfcache中，那么再次打开该页面就不会触发onload事件</p>
<h3 id="pageshow事件"><a href="#pageshow事件" class="headerlink" title="pageshow事件"></a>pageshow事件</h3><p>​    这个事件在用户浏览网页时触发，pageshow 事件类似于 onload 事件，onload 事件在页面第一次加载时触发， pageshow 事件在每次加载页面时触发，即 onload 事件在页面从浏览器缓存中读取时不触发。</p>
<h3 id="pagehide事件"><a href="#pagehide事件" class="headerlink" title="pagehide事件"></a>pagehide事件</h3><p>​    该事件会在用户离开网页时触发。离开网页有多种方式。如点击一个链接，刷新页面，提交表单，关闭浏览器等。pagehide 事件有时可以替代 unload事件，但 unload 事件触发后无法缓存页面。</p>
<h3 id="persisted属性"><a href="#persisted属性" class="headerlink" title="persisted属性"></a>persisted属性</h3><p>​    pageshow事件和pagehide事件的event对象还包含一个名为persisted的布尔值属性。</p>
<p>​    对于pageshow事件，如果页面是从bfcache中加载的，则这个属性的值为true；否则，这个属性的值为false。<br>​    对于pagehide事件，如果页面在卸载之后被保存在bfcache中，则这个属性的值为true；否则，这个属性的值为false。</p>
<p>​    不同的浏览器在对当前窗口‘打开’历史记录中的前一个页面的表现上并不统一，这和浏览器的实现以及页面本身的设置有关系。</p>
<p><strong>解决方案：</strong></p>
<p><strong>javascript监听pageshow事件阻止页面进入bfcache</strong></p>
<pre><code class="javascript"> window.addEventListener(&#39;pageshow&#39;, function (e) &#123;
     if (e.persisted) &#123;
         window.location.reload()
     &#125;
&#125;)
</code></pre>
<p>​    在uc和微信中测试通过，但是在某些安卓手机自带的浏览器中无效。</p>
<p><strong>javascript监听pagehide事件阻止页面进入bfcache</strong></p>
<pre><code class="javascript">window.addEventListener(&#39;pagehide&#39;, function (e) &#123;
    var dom = document.body;
    dom.children.remove();
    setTimeout(function () &#123;
        dom.appendChild(&quot;&lt;script type=&#39;text/javascript&#39;&gt;window.location.reload();&lt;\/script&gt;&quot;);
    &#125;);
&#125;);
</code></pre>
<p><strong>设置meta标签，清除页面缓存</strong></p>
<pre><code class="html">&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-cache, no-store, must-revalidate&quot; /&gt;
&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot; /&gt;
&lt;meta http-equiv=&quot;Expires&quot; content=&quot;0&quot; /&gt;
</code></pre>
<p>​    Cache-Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、only-if-cached，响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。各个消息中的指令含义如下<br>Public指示响应可被任何缓存区缓存<br>Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效<br>no-cache指示请求或响应消息不能缓存<br>no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。<br>max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应<br>min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应<br>max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。<br>注：有些情况下设置清除缓存也没有起到作用，我自己做的这个h5页面就没有起到效果。具体情况还是要具体分析。</p>
<p><strong>我遇到的情况：</strong></p>
<pre><code class="javascript">&lt;div class=&quot;content&quot;&gt;
     &lt;iframe id=&quot;iframe&quot; src=&quot;https://cpu.baidu.com/xx/xx/xxx&quot; frameborder=&quot;no&quot; scrolling=&quot;no&quot;&gt;&lt;/iframe&gt;
&lt;/div&gt;
</code></pre>
<p>​    这个iframe中的地址每次刷新页面都会有不同的内容推送给用户。进入iframe中的内容之后，按返回按钮返回来想进行页面自动刷新，为的就是让用户看到新的内容。</p>
<p><strong>做法</strong></p>
<p>​    使用pageshow进行整个页面刷新</p>
<pre><code class="javascript"> window.addEventListener(&#39;pageshow&#39;, function (e) &#123;
     if (e.persisted) &#123;
         window.location.reload()
     &#125;
 &#125;)
</code></pre>
<p>​    这样可以实现。</p>
<p>​    后面又觉得不妥，没有因为这个小部分而进行整个页面刷新，想到了另一种思路：因为这个iframe中的内容是动态的，可以对其进行定时器设置，如下：</p>
<pre><code class="javascript"> let iframe = document.getElementById(&#39;iframe&#39;)
 setInterval(() =&gt; &#123;
     iframe.setAttribute(&quot;src&quot;, &quot;https://cpu.baidu.com/xx/xx/xx&quot;);
 &#125;,15000)
</code></pre>
<p>​    这样也可以实现自己的功能。</p>
<p>​    最后可以结合一下：</p>
<pre><code class="javascript">let iframe = document.getElementById(&#39;iframe&#39;)
window.addEventListener(&#39;pageshow&#39;, function (e) &#123;
    if (e.persisted) &#123;
        iframe.setAttribute(&quot;src&quot;, &quot;https://cpu.baidu.com/xx/xx/xx&quot;);
    &#125;
&#125;)
</code></pre>
<p>​    这样做也有好处，可以避免使用定时器，对网页的性能也是比较好。但是这个方法在返回的时候，可以看到iframe里面内容的重新加载，会有一个时间间隙。</p>
<p>转载自:<a href="https://www.cnblogs.com/zengfp/p/9910473.html">CSDN文章: 移动端H5页面返回并且刷新页面（BFcache）</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Html</tag>
        <tag>转载</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>解决浏览器自动填充账号input出现背景色的问题</title>
    <url>/2021/04/28/%E8%A7%A3%E5%86%B3%E6%B5%8F%E8%A7%88%E5%99%A8%E8%87%AA%E5%8A%A8%E5%A1%AB%E5%85%85%E8%B4%A6%E5%8F%B7input%E5%87%BA%E7%8E%B0%E8%83%8C%E6%99%AF%E8%89%B2%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>记录一下如何解决浏览器自动填充账号input出现背景色的问题…</p>
<span id="more"></span>

<h5 id="解决前"><a href="#解决前" class="headerlink" title="解决前:"></a>解决前:</h5><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210428160033842.png" alt="image-20210428160033842"></p>
<h5 id="解决后："><a href="#解决后：" class="headerlink" title="解决后："></a>解决后：</h5><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/image-20210428160115081.png" alt="image-20210428160115081"></p>
<h5 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h5><ul>
<li><p>css设置背景色</p>
<pre><code class="css">input:-webkit-autofill &#123; 
    box-shadow: 0 0 0px 1000px white inset !important;
&#125;
</code></pre>
</li>
<li><p>input标签添加<strong>autocomplete=“off”</strong> 指定某个文本框取消自动填充</p>
<pre><code class="html">&lt;el-input type=&quot;text&quot; v-model=&quot;name&quot;  placeholder=&quot;请输入账号&quot; autocomplete=&quot;off&quot; &gt;&lt;/el-input&gt;
</code></pre>
</li>
<li><p>form表单添加<strong>autocomplete=“off”</strong> 取消所有文本框元素的自动填充</p>
<pre><code class="html">&lt;el-form autocomplete=&quot;off&quot;&gt;
   ...
&lt;/el-form&gt;
</code></pre>
<p>转载自:<a href="https://blog.csdn.net/weixin_45899022/article/details/105860397">CSDN文章: 解决input输入框自动填充账号密码出现背景色的问题</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Html</tag>
        <tag>转载</tag>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>那些你常用又记不住的Css</title>
    <url>/2021/03/18/%E9%82%A3%E4%BA%9B%E4%BD%A0%E5%B8%B8%E7%94%A8%E5%8F%88%E8%AE%B0%E4%B8%8D%E4%BD%8F%E7%9A%84css/</url>
    <content><![CDATA[<p>记录一些常用Css效果</p>
<span id="more"></span>


<h1 id="一、设置input-的placeholder的字体样式"><a href="#一、设置input-的placeholder的字体样式" class="headerlink" title="一、设置input 的placeholder的字体样式"></a>一、设置input 的placeholder的字体样式</h1><pre><code class="less">input::-webkit-input-placeholder &#123;    /* Chrome/Opera/Safari */
    color: red;
&#125;
input::-moz-placeholder &#123; /* Firefox 19+ */  
    color: red;
&#125;
input:-ms-input-placeholder &#123; /* IE 10+ */
    color: red;
&#125;
input:-moz-placeholder &#123; /* Firefox 18- */
    color: red;
&#125;
</code></pre>
<h2 id="设置input聚焦时的样式"><a href="#设置input聚焦时的样式" class="headerlink" title="设置input聚焦时的样式"></a>设置input聚焦时的样式</h2><pre><code class="css">input:focus &#123;   
    background-color: red;
&#125;
</code></pre>
<h2 id="取消input的边框"><a href="#取消input的边框" class="headerlink" title="取消input的边框"></a>取消input的边框</h2><pre><code class="css">input &#123;
    border: none;
    outline: none;
&#125;
</code></pre>
<h1 id="二、隐藏滚动条或更改滚动条样式"><a href="#二、隐藏滚动条或更改滚动条样式" class="headerlink" title="二、隐藏滚动条或更改滚动条样式"></a>二、隐藏滚动条或更改滚动条样式</h1><pre><code class="css">/*css主要部分的样式*//*定义滚动条宽高及背景，宽高分别对应横竖滚动条的尺寸*/
::-webkit-scrollbar &#123;
    width: 10px; /*对垂直流动条有效*/
    height: 10px; /*对水平流动条有效*/
&#125;

/*定义滚动条的轨道颜色、内阴影及圆角*/
::-webkit-scrollbar-track&#123;
    -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,.3);
    background-color: rosybrown;
    border-radius: 3px;
&#125;

/*定义滑块颜色、内阴影及圆角*/
::-webkit-scrollbar-thumb&#123; 
    border-radius: 7px;
    -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,.3);
    background-color: #E8E8E8;
&#125;

/*定义两端按钮的样式*/
::-webkit-scrollbar-button &#123;
    background-color:cyan;
&#125;

/*定义右下角汇合处的样式*/
::-webkit-scrollbar-corner &#123;
    background:khaki;
&#125;
</code></pre>
<h1 id="三、文字超出隐藏并显示省略号"><a href="#三、文字超出隐藏并显示省略号" class="headerlink" title="三、文字超出隐藏并显示省略号"></a>三、文字超出隐藏并显示省略号</h1><h2 id="单行（一定要有宽度）"><a href="#单行（一定要有宽度）" class="headerlink" title="单行（一定要有宽度）"></a>单行（一定要有宽度）</h2><pre><code class="css">p &#123;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    width:200px;
&#125;
</code></pre>
<h2 id="多行"><a href="#多行" class="headerlink" title="多行"></a>多行</h2><pre><code class="css">p &#123;
    word-break: break-all;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
&#125;
</code></pre>
<h1 id="四、控制div内的元素自动换行"><a href="#四、控制div内的元素自动换行" class="headerlink" title="四、控制div内的元素自动换行"></a>四、控制div内的元素自动换行</h1><pre><code class="css">div &#123;
    word-wrap: break-word;
    word-break：break-all;
&#125;
</code></pre>
<h1 id="五、-纯css画三角形"><a href="#五、-纯css画三角形" class="headerlink" title="五、 纯css画三角形"></a>五、 纯css画三角形</h1><pre><code class="css">#demo &#123;
    width: 0;
    height: 0;
    border-width: 20px;
    border-style: solid;
    border-color: transparent transparent red transparent;
&#125;
</code></pre>
<h1 id="六、-绝对定位元素居中（水平和垂直方向）"><a href="#六、-绝对定位元素居中（水平和垂直方向）" class="headerlink" title="六、 绝对定位元素居中（水平和垂直方向）"></a>六、 绝对定位元素居中（水平和垂直方向）</h1><pre><code class="css">#demo &#123;
    width: 200px;
    height: 200px;
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%,-50%);
    background-color: green;
&#125;
</code></pre>
<h1 id="七、表格边框合并"><a href="#七、表格边框合并" class="headerlink" title="七、表格边框合并"></a>七、表格边框合并</h1><pre><code class="css">table,tr,td&#123;
    border: 1px solid #333;
&#125;
table&#123;
  border-collapse: collapse;
&#125;
</code></pre>
<p>参考文档:<a href="https://zhuanlan.zhihu.com/p/228168219">那些你总是记不住但又总是要用的css</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title>本溪大石湖一日游</title>
    <url>/2021/05/04/%E6%97%85%E8%A1%8C/%E6%9C%AC%E6%BA%AA%E5%A4%A7%E7%9F%B3%E6%B9%96%E4%B8%80%E6%97%A5%E6%B8%B8/</url>
    <content><![CDATA[<p>五一放假期间去了一趟本溪大石湖，喜欢水的又离得比较近小伙伴们可以去耍耍…</p>
<span id="more"></span>

<h6 id="国际惯例，景区门口留影，哈哈"><a href="#国际惯例，景区门口留影，哈哈" class="headerlink" title="国际惯例，景区门口留影，哈哈"></a>国际惯例，景区门口留影，哈哈</h6><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/IMG_20210501_123345.jpg"></p>
<h6 id="这个也好意思叫岛，哈哈"><a href="#这个也好意思叫岛，哈哈" class="headerlink" title="这个也好意思叫岛，哈哈"></a>这个也好意思叫岛，哈哈</h6><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/IMG_20210501_123915.jpg"></p>
<h6 id="老婆大人夸我照相技术有点好-感谢煮师爷，哈哈"><a href="#老婆大人夸我照相技术有点好-感谢煮师爷，哈哈" class="headerlink" title="老婆大人夸我照相技术有点好(感谢煮师爷，哈哈)"></a>老婆大人夸我照相技术有点好(感谢煮师爷，哈哈)</h6><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/IMG_20210501_124037.jpg"></p>
<h6 id="小瀑布"><a href="#小瀑布" class="headerlink" title="小瀑布"></a>小瀑布</h6><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/IMG_20210501_124203.jpg"></p>
<h6 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/IMG_20210501_124529.jpg"></h6><h6 id="仙桃"><a href="#仙桃" class="headerlink" title="仙桃"></a>仙桃</h6><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/IMG_20210501_124855.jpg"></p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/IMG_20210501_124859.jpg"></p>
<h6 id="这个叫什么松，挺直"><a href="#这个叫什么松，挺直" class="headerlink" title="这个叫什么松，挺直"></a>这个叫什么松，挺直</h6><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/IMG_20210501_125853.jpg"></p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/IMG_20210501_125923.jpg"></p>
<h6 id="水很清"><a href="#水很清" class="headerlink" title="水很清"></a>水很清</h6><p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/IMG_20210501_130725.jpg"></p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/IMG_20210501_134533.jpg"></p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/laopo.jpg"></p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/IMG_20210501_135202.jpg"></p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/IMG_20210501_135204.jpg"></p>
<p><img src="https://cdn.jsdelivr.net/gh/houpai/hp-cdn@latest/picGo/IMG_20210501_144430.jpg"></p>
]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>旅行</tag>
      </tags>
  </entry>
</search>
